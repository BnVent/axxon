<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 75 - SECCIÓN: - ET AL Virtual</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">ET AL Virtual</h1>
<p class="calibre5"><b class="calibre4">Eduardo J. Carletti</b></p><p class="calibre5"></p>
<div class="document">
<!-- # :maxLineLen=120:folding=explicit:mode=rest:wrap=soft:collapseFolds=1:encoding=windows-1252: -->
<p class="calibre5">Las fuentes de información de este revista son las propias y además:</p>
<pre class="literal-block1">
AMB : Ambito Financiero
ANA : Analog
ASI : Asimov's
AXX : Fuentes propias
BEM : BEM
CCO : Cronista Comercial
CGA : Computer Graphics and Applications
CGW : Computer Graphics World
CLA : Clarín
CUA : Cuasar
FAN : Fandom
FSF : Fantasy &amp; Science Fiction
INT : Internet
INZ : Interzone
LAN : La Nación
LAP : La Prensa
LOC : Locus
MEX : Corresponsal en México
P12 : Página 12
POR : Pórtico
SF  : Revista SF
SFA : Science Fiction Age
SFC : Science Fiction Chronicle
STA : Starlog
USA : Corresponsal en EE.UU.
WIR : Wired
</pre>
<div class="line" id="revista-virtual-de-informatica">
<h2 class="indiceautor">REVISTA VIRTUAL DE INFORMATICA</h2>
<div class="contents" id="contents">
<ul class="calibre2">
<li class="calibre3"><a href="#el-ultimo-ser-humano-sin-windows-95" id="id1">EL ULTIMO SER HUMANO SIN WINDOWS 95</a></li>
<li class="calibre3"><a href="#lenguaje-ensamblador-8086-8088-parte-3" id="id2">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 3)</a><ul class="calibre26">
<li class="calibre3"><a href="#direccionamiento" id="id3">6. Direccionamiento</a></li>
<li class="calibre3"><a href="#instrucciones-basicas" id="id4">7. Instrucciones básicas</a></li>
<li class="calibre3"><a href="#soluciones" id="id5">SOLUCIONES</a></li>
</ul>
</li>
</ul>
</div>
<div class="line" id="el-ultimo-ser-humano-sin-windows-95">
<h3 class="calibre27"><a class="toc-backref" href="#id1">EL ULTIMO SER HUMANO SIN WINDOWS 95</a></h3>
<p class="calibre5">Podría ser la historia del Dire de Axxón…</p>
<ol class="upperalpha" start="2">
<li class="calibre3">James Philippe</li>
</ol>
<p class="calibre5">Fernando Cassia (lector de Axxón) nos dijo:
<em class="calibre11">Encontre esta joya hoy y pensé que les interesaría:</em></p>
<div class="resumen3">
<p class="calibre24">EL ULTIMO SER HUMANO SIN WINDOWS 95</p>
<p class="calibre24">(Texto Original por B. James Philippe, publicado para
distribución pública en varios newsgroups de Internet.
Traducción libre por Fernando Cassia)</p>
</div>
<!-- :: -->
<p class="calibre5">Y bueno, nos interesó…</p>
<p class="pri">Golpearon la puerta. Era
el hombre de Microsoft.</p>
<p class="calibre5">—¡No! ¡Tú de nuevo! —le
dije.</p>
<p class="calibre5">—Lo siento —dijo un poco
avergonzado—. Supongo que sabes
por qué estoy aquí.</p>
<p class="calibre5">—Claro que lo sé. La campaña
de 300 millones de dólares para
promover Windows 95 supuestamente iba a ser efectiva en el universo entero, iba a convencer a
cada ser humano en el planeta de
que Windows 95 es una parte
esencial, casi diríamos integral, de la vida. El problema es
que no todos compraron Windows
95.</p>
<p class="calibre5">Específicamente, YO no lo había comprado. Yo era el Ultimo
Ser Humano Sin Windows 95. Y
ahora este pequeño hombre de
Microsoft estaba en mi puerta, y
no podía aceptar un “No” como
respuesta.</p>
<p class="calibre5">—No —le dije.</p>
<p class="calibre5">—Tú sabes que no puedo aceptar eso —dijo, mientras sacaba
una copia de Windows 95 de su
maletín—. Vamos, sólo una copia, es todo lo que te pedimos.</p>
<p class="calibre5">—No estoy interesado —le
dije—. Mira, ¿no hay alguien
más a quien puedas ir a molestar
un rato?, tiene que haber algún
otro en el planeta que no tenga
una copia.</p>
<p class="calibre5">—Bueno, no —dijo el hombre
de Microsoft—. Usted es el
único.</p>
<p class="calibre5">—No puedes estar hablando en
serio. No toda la gente del mundo tiene una computadora —le
dije—. Demonios, ¡no todo el
mundo tiene una PC! Alguna gente
tiene Macs, que usan su propio
sistema operativo. Y alguna gente que tiene PC’s usa OS/2, aunque he oído que es sólo un rumor. En resumen, hay alguna gente que no le encontrará utilidad
a Windows 95.</p>
<p class="calibre5">El pequeño tipo de Microsoft
se veía perplejo. —No lo entiendo —dijo.</p>
<p class="calibre5">—¡USAR! —le grité—. ¡Usar!
¡Usar! ¡Usar! ¿Para qué comprarlo, si no lo van a poder USAR?</p>
<p class="calibre5">—Mire, no sé nada sobre esto
de ‘Usar’ que me está diciendo
—dijo el hombre de Microsoft—.
Todo lo que sé es que, según
nuestros registros, todas las
demás personas en este planeta
tienen una copia.</p>
<p class="calibre5">—¿Gente que no tiene computadoras? —pregunté.</p>
<p class="calibre5">—Lo tienen.</p>
<p class="calibre5">—¿Los indios del Amazonas?</p>
<p class="calibre5">—Tuvimos algunos casos de
malaria al entrar allí, pero SI.</p>
<p class="calibre5">—¿Los menonitas?</p>
<p class="calibre5">—Sí.</p>
<p class="calibre5">—¡Oh, vamos! —le dije—,
esta gente ni siquiera usa botones en su ropa. ¿Cómo hicieron
para que compren un sistema operativo de computadoras?</p>
<p class="calibre5">—Les dijimos que dentro de
la caja hay 95 pequeñas ventanitas —admitió el hombre de Microsoft. De alguna manera, mentimos. Esto significa que todos
nosotros iremos al infierno, todos y cada uno de los empleados
de Microsoft. —…por un momento se quedó serio… pero se
reanimó en seguida—. ¡Pero ese
no es el punto! —dijo—. El
punto es que TODOS tienen una
copia, excepto usted.</p>
<p class="calibre5">—¿Y qué? —le dije—. ¿Si
todo el mundo saltara a un precipicio, también esperarías que
lo haga yo?</p>
<p class="calibre5">—¿Si nosotros gastamos 300
millones promocionándolo? Por
supuesto.</p>
<p class="calibre5">—No —le dije.</p>
<p class="calibre5">—Uff, otra vez con eso —dijo el hombre de Microsoft—.
Hey, te diré una cosa. Te DARÉ
una copia. Gratis. Sólo tómala e
instálala en tu computadora. —Y
movió la caja frente a mi cara.</p>
<p class="calibre5">—No —le dije nuevamente—.
No te ofendas, amigo. ¡Pero no
necesito Windows 95! Y, francamente, toda tu parafernalia publicitaria me molesta. Es decir,
¡es sólo un sistema operativo de
computadoras! Grandioso. Bueno.
O lo que sea. Pero ustedes lo
están promocionando como si
creara la Paz Mundial, o algo
así.</p>
<p class="calibre5">—Lo hizo —respondió el hombre de Microsoft.</p>
<p class="calibre5">—¿Perdón?</p>
<p class="calibre5">—La paz mundial. Era parte
del diseño original. En serio.
Acceso con un solo botón. Con
sólo clickear en él, <em class="calibre11">puf</em>, el fin
del hambre y el sufrimiento.
Simple.</p>
<p class="calibre5">—¿Y entonces qué pasó?</p>
<p class="calibre5">—Bueno, tú sabes —dijo—,
ocupaba un montón de espacio en
el disco rígido. Tuvimos que decidir entre eso y el Microsoft
Network. De todas maneras, no
sabíamos cómo ganar plata con la
Paz Mundial…</p>
<p class="calibre5">—Basta. Fuera de aquí —le
dije.</p>
<p class="calibre5">—No puedo —me dijo—. Me
matarían si fracaso.</p>
<p class="calibre5">—Tienes que estar bromeando
—le dije.</p>
<p class="calibre5">—Mira —dijo el hombre de
Microsoft—, ¡les vendimos esto
a los menonitas! ¡Los menonitas!
En este momento, ellos están
abriendo sus cajas y viendo lo
que han comprado en realidad.
Nos van a linchar si alguna vez
volvemos a pisar ese lugar. Pero
lo hicimos. Así que nos quedas
tú. Mira, es vergonzoso. Es vergonzoso para la Companía. Es
vergonzoso para el producto. Es
vergonzoso para Bill.</p>
<p class="calibre5">—A Bill Gates no le importa
lo que haga yo —le dije.</p>
<p class="calibre5">—Él está mirando ahora —dijo el hombre de Microsoft—. Alquiló uno de esos satélites
espía de los militares sólo para
esta ocasión. También tiene uno
de esos lásers de alta potencia.
Si me cierras la puerta, <em class="calibre11">zap</em>,
soy un montón de cenizas.</p>
<p class="calibre5">—Él no haría eso. Podría pegarle a esa caja de Windows 95
por accidente —le dije.</p>
<p class="calibre5">—Oh no, Bill es bastante
bueno con ese láser —dijo, nervioso, el hombre de Microsoft—.
Okey. Se supone que no debo hacer esto, pero no me dejas alternativa. Si aceptas esta copia
de Windows ‘95 te premiaremos
merecidamente. De hecho, ¡te daremos tu propia isla en el Caribe! ¿Qué tal Montserrat?</p>
<p class="calibre5">—Terrible. Hay un volcán activo allí.</p>
<p class="calibre5">—¡Pero es uno pequeño! —dijo el hombre de Microsoft.</p>
<p class="calibre5">—Mira —le dije—, si me
convencieras de aceptar esa copia de Windows ‘95, ¿que harías
después? Habrías saturado totalmente el mercado. Ese sería tu
fin. No más nuevos mundos que
conquistar. ¿Que harías entonces?</p>
<p class="calibre5">El hombre de Microsoft sacó
otra caja del maletín y me la
dio.</p>
<p class="calibre5">Windows 95… ¡Para mascotas!</p>
<p class="calibre5">—¡Sí!, hay un MONTON de
animales domésticos ahí afuera
—dijo.</p>
<p class="calibre5">De un portazo, le cerré la
puerta en la cara. Se escuchó
un grito como de sorpresa, el
zumbido de un láser, y luego
nada.</p>
</div>
<div class="line" id="lenguaje-ensamblador-8086-8088-parte-3">
<h3 class="calibre27"><a class="toc-backref" href="#id2">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 3)</a></h3>
<p class="calibre5">Cómo adentrarse en el alma de la PC</p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<div class="line" id="direccionamiento">
<h4 class="calibre28"><a class="toc-backref1" href="#id3">6. Direccionamiento</a></h4>
<p class="calibre5"><strong class="calibre4">6.1. Más sobre el direccionamiento</strong></p>
<p class="calibre5">El procesador 8086 toma datos de la memoria y también los
graba en ella. Cuando hace esto, debe indicar de alguna
manera la dirección de la memoria donde están ubicados los
datos. Esto es lo que se llama direccionamiento.</p>
<p class="calibre5">A continuación veremos el mecanismo que usa a tal fin.</p>
<p class="calibre5"><em class="calibre11">A)</em> En la propia instrucción hay un OFFSET (desplazamiento) de
8 o de 16 bits. En caso de que sea de 8 bits, se lo extiende
con su signo a 16 bits. Cuando es de 16 bits, este desplazamiento no aparece en el orden parte alta - parte baja, sino
en el inverso. Así, un desplazamiento de 1B4C hexadecimal
aparecerá como 4C1B hexadecimal; ésta es una característica
de todos los datos que el procesador 8086 maneja en la memoria, no sólo del desplazamiento, y que oportunamente hemos
explicado. Algunas instrucciones y formatos de instrucciones
no tienen OFFSET, en cuyo caso se lo considera de valor 0.</p>
<p class="calibre5"><em class="calibre11">B)</em> La instrucción puede especificar la inclusión de un registro base y de un registro índice en el direccionamiento de la
memoria. También hay instrucciones que tienen implícito el
registro que usarán. Se puede indicar un registro base sin
registro índice, un registro índice sin registro base, ambos
o ninguno. Los registros base posibles son BX y BP. Los
registros índice posibles son SI y DI. El contenido de los
registros especificados se suma al desplazamiento.</p>
<p class="calibre5"><em class="calibre11">C)</em> El resultado de esta suma es tomado sin considerar los
bits de orden alto que se pierdan más allá de los 16 bits y
sin provocar indicaciones de desborde o de acarreo fuera del
acumulador. Dicho de otra manera, el resultado se toma módulo
216. Ésta es la llamada dirección efectiva. Esto, desde el
punto de vista práctico, significa que es posible usar valores negativos en el desplazamiento y en los registros base e
índice. En efecto, supongamos que el desplazamiento valga 12,
lo que en binario es 0000 0000 0000 1100, y que se use el
registro base BX, con contenido -1, que en binario es 1111
1111 1111 1111. Si sumamos ambos valores despreciando el
acarreo fuera del acumulador, tendremos como resultado 0000
0000 0000 1011, o sea 11 decimal, lo que demuestra una vez
más como funciona la notación de complemento y su porqué.</p>
<p class="calibre5"><em class="calibre11">D)</em> Finalmente, se toma un registro de segmento, que puede ser
CS, DS, SS o ES. Muchas veces este registro está implícito en
el tipo de operación; otras veces se lo especifica con un
prefijo de contrarrestación. Si se trata de una operación de
manipulación de datos, tal como un movimiento o una suma, el
registro implícito es DS. Si se trata de una instrucción para
manejo de cadenas, uno de sus operandos lleva implícito el
registro DS y el otro el ES (estas instrucciones tienen operandos también implícitos). Si se ha especificado el registro
base BP, el registro de segmento implícito es el SS. Las operaciones de PUSH y POP tienen también implícito el registro
SS.</p>
<p class="calibre5"><em class="calibre11">E)</em> Al contenido del registro de segmento elegido se lo desplaza 4 bits a la izquierda, lo cual equivale a multiplicarlo
por 24 = 16. Este número se suma a la dirección efectiva. El
resultado final tiene 20 bits y por lo tanto va desde 0 hasta
220 - 1, y es la dirección absoluta de memoria que usará la
instrucción. Excepción: en máquinas que permiten direccionar
más allá del Megabyte, es posible pasar 64K - 16 bytes más
allá del límite del Megabyte usando este método de direccionamiento; para ello, se da un valor muy alto al registro de
segmento, por ejemplo FFFF hexadecimal.</p>
<p class="calibre5">Cada registro de segmento identifica el comienzo de un
segmento de memoria de 65.536 bytes. Como hay 4 registros de
segmento, en un instante dado habrá 4 segmentos de memoria
seleccionados de 65.536 bytes cada uno. Cualquier dirección
generada deberá entonces apuntar a una ubicación dentro del
rango de uno de estos 4 segmentos y específicamente el que
corresponda al registro de segmento usado.</p>
<p class="calibre5">No hay restricciones con respecto al contenido de los registros de segmento. Por consiguiente, a diferencia de otros
equipos, la memoria a la que tiene acceso un procesador 8086
no está dividida en segmentos invariables. Los 4 segmentos
pueden superponerse o coincidir.</p>
<p class="calibre5">Todo este procedimiento parece en extremo complejo, pero
el procesador lo hace automáticamente en un tiempo brevísimo.
El programador debe comprender cómo funciona, pero cuando
programa se limitará normalmente a usar un rótulo y dejar que
el Ensamblador y el procesador efectúen cada uno su tarea y
lo alivien de las complejidades.</p>
<p class="calibre5"><strong class="calibre4">6.2. Modos de direccionamiento</strong></p>
<p class="calibre5">Veremos a continuación las formas en que las instrucciones
direccionan los datos. En los ejemplos usaremos siempre el
segundo operando de una instrucción MOV. Supondremos que
existen las siguientes definiciones en el segmento de datos,
cuyo comienzo está indicado por la directiva .DATA:</p>
<pre class="literal-block1">
|              .DATA
|     Palabras  DW   45, 72, -10
|     Mensaje   DB   'Hola'
|     K65       EQU  65
</pre>
<p class="calibre5">La directiva EQU especifica que, cada vez que se use su
rótulo, debe reemplazárselo por lo que está a la derecha de
EQU.</p>
<p class="calibre5">Luego de:</p>
<pre class="literal-block1">
|  .CODE
</pre>
<p class="calibre5">vendrán las instrucciones que ejemplificamos.</p>
<p class="calibre5">A) Datos inmediatos</p>
<pre class="literal-block1">
|     mov   al, 65         ; Constante decimal
</pre>
<p class="calibre5">El dato aparece directamente en la instrucción. En el ejemplo
es un dato escrito en decimal, pero se lo puede indicar de
varias otras maneras:</p>
<pre class="literal-block1">
|     mov   al, K65        ; Rótulo = const. decimal
|     mov   al, 1000001b   ; Constante binaria
|     mov   al, 41h        ; Constante hexadecimal
|     mov   al, 'A'        ; Constante alfanumérica
</pre>
<p class="calibre5">Todas estas notaciones son aquí equivalentes, pues 6510 =
10000012 = 4116 = ‘A’.</p>
<p class="calibre5">En el caso de que una constante hexadecimal comience con
una letra, se la debe preceder por un 0 para evitar que se
confunda con un rótulo; entonces debe escribirse 0fc1h y no
fc1h.</p>
<p class="calibre5">Luego de ejecutada una de las instrucciones precedentes,
el registro AL contendrá el carácter A, o lo que es lo mismo,
el valor decimal 65, o 41 hexadecimal, o 01000001 binario.</p>
<pre class="literal-block1">
|    mov   al, Mensaje - Palabras   ; Const. de longitud
</pre>
<p class="calibre5">La diferencia entre dos direcciones de memoria da como resultado una constante, que en este caso vale 6 (longitud del
dato Palabras). La suma de dos direcciones no produce un
resultado válido. Lo que sí puede usarse es una constante que
sume o reste, por ejemplo Mensaje - Palabras + 2.</p>
<pre class="literal-block1">
|    mov   ax, OFFSET Mensaje   ; Const. de dirección
|    mov   ax, SEG Mensaje      ; Const. de dirección
</pre>
<p class="calibre5">Al tomar el OFFSET (desplazamiento) de un rótulo, queda en la
instrucción un dato inmediato. Lo mismo ocurre cuando se toma
el segmento. El valor del OFFSET lo calcula el Ensamblador en
base a la ubicación del rótulo dentro del segmento de datos;
en cambio, el valor que debe tener el registro de segmento es
calculado en el momento de la carga del programa, pues el
programa puede ser cargado en cualquier lugar de la memoria.</p>
<p class="calibre5">Estos operandos inmediatos pueden ocupar 1 o 2 bytes. El
Ensamblador decide cuál tamaño emplear en base a su valor, al
registro usado y al código de operación, de manera tal que se
genere una instrucción válida con la menor longitud posible.</p>
<p class="calibre5">B) Contenido de registros</p>
<pre class="literal-block1">
|    mov   ax, bx   ; Contenido de BX
</pre>
<p class="calibre5">Esta instrucción copia el contenido de un registro a otro. Es
posible usar registros de segmento con la instrucción MOV,
como vimos en nuestro primer programa. Lo que no se puede es
copiar un registro de 8 bits a otro de 16 bits y viceversa.
Una instrucción tal como:</p>
<pre class="literal-block1">
|    mov   ax, ax
</pre>
<p class="calibre5">no hace nada; pero si se tratara de una suma:</p>
<pre class="literal-block1">
|    add   ax, ax   ; AX = AX + AX
</pre>
<p class="calibre5">duplicaría el contenido de AX; y si fuera una resta:</p>
<pre class="literal-block1">
|    sub   ax, ax   ; AX = AX - AX
</pre>
<p class="calibre5">borraría a 0 el contenido de AX.</p>
<p class="calibre5">C) Direccionamiento directo</p>
<pre class="literal-block1">
|    mov   al, [Mensaje]
|    mov   al, Mensaje   ; Lo mismo
</pre>
<p class="calibre5">El Ensamblador reemplaza el rótulo Mensaje por su
desplazamiento, usándolo para direccionar la memoria con el
esquema de direccionamiento que incluye el registro de
segmento DS, como ya se explicó. En el ejemplo se copiará el
carácter “H” al registro AL.</p>
<p class="calibre5">En este modo de direccionamiento, el desplazamiento tiene
siempre 2 bytes de longitud.</p>
<p class="calibre5">En este caso los corchetes, como se ve, son optativos.
Cuando el Ensamblador encuentra un rótulo cuya definición
indica que se trata de un área de memoria dentro del segmento
de datos, lo reemplaza por el desplazamiento correspondiente
y genera un código de instrucción que direccione la memoria
con el mismo. En la instrucción aparecerá el desplazamiento
tal como lo hace en el caso de que se use la especificación
OFFSET. Esto indica claramente que algo debe diferenciar una
instrucción de otra; y, en efecto, los códigos de instrucción
generados son distintos. En otras palabras, no siempre un
código mnemotécnico como MOV genera el mismo código de instrucción. En este texto no entraremos en el detalle de los
códigos y formatos de las instrucciones generadas en lenguaje
de máquina, porque son muchos y muy variados; quien desee
informarse, puede recurrir a un libro tal como “The 8086
Book”, por Russell Rector y George Alexy.</p>
<p class="calibre5">Los corchetes significan “dirección en memoria”. Mientras
que hay quien recomienda la sintaxis con corchetes en este
caso, muchos otros sostienen que los corchetes están de más,
pues es claro que el rótulo se refiere a una dirección de
memoria y no puede usarse como dato inmediato. En este texto
adoptaremos este último criterio.</p>
<pre class="literal-block1">
|    mov   al, Mensaje + 3
</pre>
<p class="calibre5">Es posible ajustar una dirección en una constante, ya sea en
más o en menos. En este caso particular, la instrucción
copiará al registro AL el carácter “a”.</p>
<p class="calibre5">D) Dirección indirecta con registro base</p>
<pre class="literal-block1">
|    mov   bx, OFFSET Mensaje + 1   ; Preparación
|    mov   ax, [bx]                 ; Memoria apuntada por BX
</pre>
<p class="calibre5">En este ejemplo, el contenido del registro BX se usa como
dirección efectiva. Aquí los corchetes no son optativos, pues
la instrucción sin ellos copiaría el contenido de BX a AX.
Dado que previamente se cargó la dirección de Mensaje + 1 en
BX, los caracteres “ol” serán tomados de esa dirección y
cargados en AX. El valor numérico resultante no interesa por
ahora.</p>
<p class="calibre5">El registro base BP por sí mismo no puede usarse con este
modo de direccionamiento. Como reemplazo, puede emplearse el
modo indicado bajo F más adelante con desplazamiento 0.</p>
<p class="calibre5">E) Dirección indirecta con registro índice</p>
<pre class="literal-block1">
|    mov   si, OFFSET Mensaje + 1   ; Preparación
|    mov    ax, [si]                ; Memoria apuntada por SI
</pre>
<p class="calibre5">Este caso es similar al anterior; la única diferencia es el
uso de un registro índice (SI) en lugar de uno base (BX).
Recordemos que los registros base son BX y BP (éste con
segmento implícito SS), y los índice SI y DI.</p>
<p class="calibre5">F) Dirección indirecta con registro base y OFFSET</p>
<pre class="literal-block1">
|    mov   bx, OFFSET Mensaje   ; Preparación
|    mov   al, 1 [bx]           ; O también [1 + bx]
</pre>
<p class="calibre5">La dirección cargada en BX se ajusta en 1 para tomar datos de
la memoria, de manera que el carácter “o” va al registro AL.</p>
<pre class="literal-block1">
|    mov   bx, 1                ; Preparación
|    mov   al, Mensaje [bx]     ; O también [Mensaje + bx]
</pre>
<p class="calibre5">Esto es igual a lo anterior en su resultado. La diferencia
consiste en que el registro BX contiene 1 y el desplazamiento
es el valor de Mensaje.</p>
<p class="calibre5">En este modo de direccionamiento, el desplazamiento puede
tener 1 o 2 bytes de longitud. Si tiene 1, se extiende con su
signo a 16 bits para el cálculo de la dirección efectiva.</p>
<p class="calibre5">G) Dirección indirecta con registro índice y OFFSET</p>
<pre class="literal-block1">
|    mov   di, OFFSET Mensaje   ; Preparación
|    mov   al, 1 [di]           ; O también [di + 1]
</pre>
<p class="calibre5">O si no:</p>
<pre class="literal-block1">
|    mov   di, 1                ; Preparación
|    mov   al, Mensaje [di]     ; O también [di + Mensaje]
</pre>
<p class="calibre5">Este caso es similar al anterior, con la diferencia de que se
usa un registro índice (DI) en lugar de uno base (BX).</p>
<p class="calibre5">También aquí el desplazamiento puede tener 1 o 2 bytes.</p>
<p class="calibre5">H) Dirección indirecta con registro base y registro índice</p>
<pre class="literal-block1">
|    mov   bx, OFFSET Mensaje   ; Preparación
|    mov   si, 2                ; Idem
|    mov   ax, [bx] [si]        ; O también [bx + si]
</pre>
<p class="calibre5">Aquí se suman los contenidos de los registros BX y SI para
obtener la dirección efectiva, la cual resulta ser la de
Mensaje + 2, o sea que los caracteres “la” van al registro
AX.</p>
<p class="calibre5">I) Dirección indirecta con registro base, registro índice y
OFFSET</p>
<pre class="literal-block1">
|    mov   bx, 1                 ; Preparación
|    mov   si, 2                 ; Idem
|    mov   al, Mensaje [bx] [si] ; O Mensaje [bx + si]
</pre>
<p class="calibre5">O si no:</p>
<pre class="literal-block1">
|    mov   bx, 1                 ; Preparación
|    mov   si, OFFSET Mensaje    ; Idem
|    mov   al, 2 [bx] [si]       ; O también [2 + bx + si]
</pre>
<p class="calibre5">Se suman los contenidos de los registros BX y SI al desplazamiento de la instrucción, lo cual da como resultado copiar al
registro AL el carácter “a”.</p>
<p class="calibre5">El desplazamiento puede tener 1 o 2 bytes.</p>
<p class="calibre5">Además de las variantes de notación expuestas en los
diversos casos, hay otras muchas, por ejemplo:</p>
<pre class="literal-block1">
|        Mensaje [bx + si + 1]
|        [1 + Mensaje + bx + si]
|        Mensaje [bx + 1] [si]
</pre>
<p class="calibre5">etc. (estas notaciones dan el mismo resultado)</p>
<p class="calibre5">De cualquier manera, siempre que se use un registro base o
índice para contener un valor que se sumará al desplazamiento, el mismo debe escribirse entre corchetes.</p>
<p class="calibre5">Puede uno preguntarse en qué casos debe usarse una dirección directa y cuándo conviene una afectada por registros. En
general, se usa una dirección directa cuando la ubicación del
dato en memoria es fija, y en cambio se usa una dirección
afectada por registros cuando la ubicación varía durante la
ejecución del programa.</p>
<p class="calibre5">Recordemos una vez más que la dirección efectiva así
determinada es sólo la parte de desplazamiento; se le debe
sumar el contenido del registro de segmento respectivo,
multiplicado por 16, para obtener la dirección absoluta de
memoria. A menos que se indique lo contrario de una manera
que veremos más adelante, el registro de segmento usado para
los datos es el DS, salvo cuando se emplea el registro base
BP, en cuyo caso el registro de segmento es el SS.</p>
</div>
<div class="line" id="instrucciones-basicas">
<h4 class="calibre28"><a class="toc-backref1" href="#id4">7. Instrucciones básicas</a></h4>
<p class="calibre5"><strong class="calibre4">7.1. Mover</strong></p>
<p class="calibre5">Hemos visto los ejemplos de direccionamiento utilizando la
instrucción MOV (mover, o más propiamente copiar), una de las
más frecuentes en los programas en lenguaje Assembly. En todos los casos hemos explicado variantes del segundo operando
(origen de los datos). El primer operando puede tomar los
mismos formatos que el segundo, con algunas excepciones que
detallamos a continuación:</p>
<p class="calibre5">A) El primer operando no puede ser un dato inmediato, lo cual
es lógico. En efecto, suponiendo que fuera un dato inmediato
o sea una constante, la propia instrucción lo modificaría sin
ningún provecho, pues luego no se lo podría emplear en otras
instrucciones. Por lo tanto, no es válido por ejemplo:</p>
<pre class="literal-block1">
|    mov   3, ax   ; Error
</pre>
<p class="calibre5">B) Los dos operandos no pueden ser a la vez referencias a
memoria. Por lo tanto, instrucciones como las siguientes no
son válidas:</p>
<pre class="literal-block1">
|    mov   Rotulo, Mensaje            ; Error
|    mov   Rotulo [si], Mensaje + 3   ; Error
</pre>
<p class="calibre5">(donde Rotulo y Mensaje son dos rótulos que se refieren a
datos en memoria).</p>
<p class="calibre5">En cambio, instrucciones como las siguientes son perfectamente válidas:</p>
<pre class="literal-block1">
|    mov   Rotulo, 5h
|    mov   Mensaje [bx], al
</pre>
<p class="calibre5">El Ensamblador detecta discordancias entre operandos. Por
ejemplo, marcará como errónea una instrucción MOV cuyo primer
operando sea un registro de 16 bits y cuyo segundo operando
sea un rótulo definido como DB:</p>
<pre class="literal-block1">
|           .DATA
|     Dato   DB   'ESTO'
|           .CODE
|           mov    ax, Dato              ; Error
</pre>
<p class="calibre5">Si se desea que la palabra que comienza en la dirección
indicada por Dato vaya al registro AX, se lo puede indicar de
esta manera:</p>
<pre class="literal-block1">
|       mov   ax, WORD PTR Dato   ; Correcto
</pre>
<p class="calibre5">El Ensamblador puede indicar que una instrucción es ambigua,
por ejemplo:</p>
<pre class="literal-block1">
|       mov   [bx], 3   ; Ambigua
</pre>
<p class="calibre5">En efecto, tanto el primer operando como el segundo pueden
referirse a datos de 1 o de 2 bytes, y el Ensamblador no
“sabe” cuál usar; por eso marca la instrucción como errónea.
También en este caso la solución consiste en indicar WORD PTR
o BYTE PTR, así:</p>
<pre class="literal-block1">
|    mov   BYTE PTR [bx], 3   ; Correcto
</pre>
<p class="calibre5">Hay operaciones detectadas como errores por el Ensamblador
que no pueden ser ejecutadas de ninguna manera, pues no
existe la instrucción en lenguaje de máquina que haga lo que
se pretende. Por ejemplo:</p>
<pre class="literal-block1">
|    mov   ax, bl   ; Error
</pre>
<p class="calibre5">Esta instrucción no tiene equivalente en lenguaje de máquina,
pues uno de los registros (el AX) es de 16 bits, mientras que
el otro es de 8 bits.</p>
<p class="calibre5">Tampoco existe una instrucción que cargue un registro de
segmento con un dato inmediato, tal como:</p>
<pre class="literal-block1">
|    mov   ds, 15h   ; Error
</pre>
<p class="calibre5">Las instrucciones MOV no modifican ninguna de las banderas.</p>
<p class="calibre5"><strong class="calibre4">7.2. Suma y resta</strong></p>
<p class="calibre5">La suma y la resta tienen casi los mismos formatos que la
instrucción MOV, con una importante excepción: no es posible
realizar operaciones aritméticas con los registros de segmento. Por lo demás, operaciones como las siguientes son
perfectamente válidas:</p>
<pre class="literal-block1">
|     add   ax, 10                ; Suma 10 a AX
|     add   Rotulo, bl            ; Suma BL a Rotulo
|     add   cl, Rotulo [bx]       ; Suma Rotulo [bx] a CL
|     sub   ch, dl                ; Resta BL de CH
|     sub   ax, WORD PTR Rotulo   ; Resta Rotulo de AX
</pre>
<p class="calibre5">En cuanto a la descripción detallada de las operaciones de
suma y resta, debe consultarse el capítulo “Aritmética
binaria y hexadecimal”.</p>
<p class="calibre5">Las instrucciones de suma y resta afectan las banderas de
acarreo fuera del acumulador (CF), indicación de cero (ZF),
signo (SF), desborde (OF), acarreo auxiliar (AF) y paridad
(PF). Veremos a continuación cómo lo hacen. Recordemos que
las instrucciones MOV no modifican ninguna bandera; por lo
tanto, si una instrucción de suma o de resta es seguida por
una o más instrucciones MOV, el valor de una bandera quedará
como estaba tras la última instrucción de suma, de resta u
otra que modifique esa bandera.</p>
<p class="calibre5">La bandera de acarreo fuera del acumulador (CF) se pone de
acuerdo con el último acarreo (suma) o pedido (resta) fuera
del acumulador en la última operación que la modifica. Si
hubo un acarreo o un pedido, su valor será 1, y en caso contrario 0.</p>
<p class="calibre5">La bandera de signo (SF) se coloca en 1 cuando el resultado de la instrucción de suma o de resta es negativo, y en 0
en caso contrario.</p>
<p class="calibre5">La bandera de cero (ZF) se coloca en 1 cuando el resultado
de la instrucción de suma o de resta es cero, y en 0 en caso
contrario. Esto puede parecer contradictorio, pero no lo es
si uno lo piensa detenidamente.</p>
<p class="calibre5">La bandera de desborde (OF) se coloca en 1 cuando al sumar
dos operandos positivos se obtiene un resultado negativo, y
viceversa; en caso contrario, OF se pone en 0. Para la resta,
esto ocurre cuando se resta un operando negativo de uno positivo y se obtiene un resultado negativo, o cuando se resta un
operando positivo de uno negativo y se obtiene un resultado
positivo. Una formulación equivalente consiste en decir que
OF se pone en 1 cuando el acarreo o pedido fuera del acumulador y el acarreo o pedido siguiente son distintos, y en 0
cuando son iguales.</p>
<p class="calibre5">La bandera de acarreo auxiliar (AF) se pone de acuerdo con
el acarreo o pedido desde el nibble de más bajo orden hacia
el siguiente. Si este acarreo o pedido fue 1, entonces AF se
pone en 1, y en 0 en caso contrario. Nótese que esto es independiente de que la operación sea con bytes o con palabras.
Esta bandera no tiene mucho uso, y ni siquiera hay una instrucción de bifurcación que la pruebe. La usan implícitamente
algunas instrucciones de ajuste para aritmética decimal.</p>
<p class="calibre5">La bandera de paridad (PF) se pone en 1 cuando es par la
cantidad de bits 1 en el resultado de una operación de suma o
de resta; en caso contrario, se pone en 0. Esta bandera tampoco tiene mucho uso, aunque hay instrucciones que la prueban.</p>
<p class="calibre5"><strong class="calibre4">7.3. Comparación</strong></p>
<p class="calibre5">La comparación puede verse como una resta que no almacena su
resultado. Por lo tanto, su única acción se ejerce sobre los
bits del registro de estado (ST), llamados banderas o flags.
En particular, resultan afectadas SF, CF, OF y ZF. También son
afectadas AF y PF, pero generalmente éstas carecen de interés.</p>
<p class="calibre5">Veamos algunos ejemplos de comparación, en todo similares
a los de suma o resta:</p>
<pre class="literal-block1">
|     cmp   al, 3
|     cmp   Rotulo, bh
|     cmp   cx, 2 [si] [bx]
</pre>
<p class="calibre5">Ya hemos visto cómo modifican las banderas las instrucciones
de suma y de resta. Veamos ahora el caso particular de la
comparación.</p>
<p class="calibre5">La comparación se realiza de la misma manera independientemente de que consideremos operandos con signo o sin signo.
Lo que varía son las pruebas (bifurcaciones condicionales que
en seguida veremos) que se efectúan después.</p>
<p class="calibre5">Si no deseamos considerar el signo, nos referiremos a la
bandera de acarreo (CF). Si CF = 0, el primer operando es
mayor o igual que el segundo. Si CF = 1, el primer operando
es menor que el segundo. Por ejemplo, cuando comparamos desplazamientos debemos considerarlos sin signo, pues el rango
de los mismos es desde 0 hasta 65.535.</p>
<p class="calibre5">Si en cambio deseamos considerar el signo de los operandos, nos referiremos a las banderas de signo (SF) y de
desborde (OF). Si SF es igual a OF, el primer operando es
mayor o igual que el segundo. Si SF es distinto de OF, el
primer operando es menor que el segundo.</p>
<p class="calibre5">Tanto en el caso con signo como en el caso sin signo, la
condición de igualdad se detecta porque la bandera de cero
(ZF) es 1. En caso de desigualdad es 0.</p>
<p class="calibre5">Para que la comparación tenga alguna utilidad, deben
existir instrucciones que usen las banderas, instrucciones
que veremos a continuación.</p>
<p class="calibre5"><strong class="calibre4">7.4. Bifurcaciones</strong></p>
<p class="calibre5">Normalmente, el flujo de un programa es secuencial, o sea que
después de una instrucción se ejecuta la que se halla en la
próxima dirección de memoria. Este flujo puede verse interrumpido por las bifurcaciones o saltos.</p>
<p class="calibre5">El primer tipo de bifurcación es la bifurcación incondicional. La misma hace que la próxima instrucción a ejecutarse
esté en una dirección especificada de la memoria; en otras
palabras, hace que el programa salte a tal dirección. Esta
instrucción tiene varios formatos, de los cuales el más
simple y empleado es:</p>
<pre class="literal-block1">
|    jmp   Lugar   ; Ir a Lugar
</pre>
<p class="calibre5">donde Lugar es un rótulo dentro del segmento de código. JMP
viene del inglés JUMP, saltar.</p>
<p class="calibre5">El segundo tipo de bifurcación es la bifurcación condicional. En este tipo, el salto se produce sólo si las banderas tienen la configuración especificada; en caso contrario, sigue la ejecución secuencial del programa. Las diversas
especificaciones son las siguientes:</p>
<pre class="literal-block1">
|     jz   Lugar   ; Ir si ZF = 1
|     je   Lugar   ; Idem
</pre>
<p class="calibre5">Tenemos dos códigos mnemotécnicos distintos para la misma
instrucción. JZ equivale a Jump if Zero (saltar si cero), y
JE equivale a Jump if Equal (saltar si igual). En ambos
casos, se bifurca si ZF = 1, por ejemplo como resultado de
una comparación o suma anterior.</p>
<pre class="literal-block1">
|     jnz   Lugar   ; Ir si ZF = 0
|     jne   Lugar   ; Idem
</pre>
<p class="calibre5">Otra vez vemos dos códigos mnemotécnicos para la misma instrucción, opuesta a la anterior: se bifurca si ZF = 0. En
inglés tenemos respectivamente Jump if Not Zero (saltar si no
es cero) y Jump if Not Equal (saltar si no es igual).</p>
<pre class="literal-block1">
|     js   Lugar   ; Ir si SF = 1
</pre>
<p class="calibre5">La bifurcación se produce cuando la bandera de signo (SF) es
1, o sea cuando el resultado de la última operación fue
negativo (Jump if Sign, saltar si signo).</p>
<pre class="literal-block1">
|     jns   Lugar   ; Ir si SF = 0
</pre>
<p class="calibre5">Es lo opuesto de la anterior (Jump if No Sign, saltar si no
signo).</p>
<pre class="literal-block1">
|     jc   Lugar   ; Ir si CF = 1
</pre>
<p class="calibre5">La bifurcación se produce cuando la bandera de acarreo (CF)
es 1 (Jump if Carry, saltar si acarreo).:</p>
<pre class="literal-block1">
|     jnc   Lugar   ; Ir si CF = 0
</pre>
<p class="calibre5">Lo opuesto de la anterior (Jump if No Carry, saltar si no
acarreo).:</p>
<pre class="literal-block1">
|     jo   Lugar   ; Ir si OF = 1
</pre>
<p class="calibre5">La bifurcación se produce cuando la bandera de desborde (OF)
es 1 (Jump if Overflow, saltar si desborde).:</p>
<pre class="literal-block1">
|     jno   Lugar   ; Ir si OF = 0
</pre>
<p class="calibre5">Lo opuesto de la anterior (Jump if No Overflow, saltar si no
desborde).:</p>
<pre class="literal-block1">
|     jb     Lugar   ; Ir si CF = 1
|     jnae   Lugar   ; Idem
</pre>
<p class="calibre5">JB significa Jump if Below (saltar si abajo), y JNAE es Jump
if Not Above or Equal (saltar si no arriba o igual). Se usa
cuando comparamos números sin signo o datos alfanuméricos. La
condición que se prueba es la misma de JC.</p>
<p class="calibre5">En todos los casos en que se bifurque por “abajo”, “arriba”, “menor” o “mayor”, conviene usar la siguiente regla
mnemotécnica: el que está abajo, arriba, es mayor o es menor
es el primer operando de la comparación precedente.:</p>
<pre class="literal-block1">
|     jae   Lugar   ; Ir si CF = 0
|     jnb   Lugar   ; Idem
</pre>
<p class="calibre5">Lo opuesto de la anterior (Jump if Above or Equal, saltar si
arriba o igual, o Jump if Not Below, saltar si no abajo.:</p>
<pre class="literal-block1">
|     jbe   Lugar   ; Ir si CF = 1 o ZF = 1
|     jna   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Below or Equal, saltar si abajo o igual, o Jump if
Not Above, saltar si no arriba.:</p>
<pre class="literal-block1">
|     ja     Lugar   ; Ir si CF = 0 y ZF = 0
|     jnbe   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Above, saltar si arriba, o Jump if Not Below or
Equal, saltar si no abajo o igual.:</p>
<pre class="literal-block1">
|     jl     Lugar   ; Ir si SF &lt;&gt; OF
|     jnge   Lugar   ; Idem
</pre>
<p class="calibre5">Entramos aquí en las bifurcaciones correspondientes a la
comparación de números con signo. Ésta es Jump if Less,
saltar si menor, o Jump if Not Greater or Equal, saltar si no
mayor o igual.:</p>
<pre class="literal-block1">
|     jge   Lugar   ; Ir si SF = OF
|     jnl   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Greater or Equal, saltar si mayor o igual, o Jump if
Not Less, saltar si no menor.:</p>
<pre class="literal-block1">
|     jle   Lugar   ; Ir si SF &lt;&gt; OF o ZF = 1
|     jng   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Less or Equal, saltar si menor o igual, o Jump if Not
Greater, saltar si no mayor.:</p>
<pre class="literal-block1">
|     jg     Lugar   ; Ir si SF = OF y ZF = 0
|     jnle   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Greater, saltar si mayor, o Jump if Not Less or
Equal, saltar si no menor o igual.:</p>
<pre class="literal-block1">
|     jpe   Lugar   ; Ir si PF = 1
|     jp    Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Parity Even, saltar si paridad par, o Jump if Parity,
saltar si paridad.:</p>
<pre class="literal-block1">
|     jpo   Lugar   ; Ir si PF = 0
|     jnp   Lugar   ; Idem
</pre>
<p class="calibre5">Jump if Parity Odd, saltar si paridad impar, o Jump if Not
Parity, saltar si no paridad.</p>
<p class="calibre5">Una instrucción de bifurcación condicional puede bifurcar
como máximo a una dirección 128 bytes atrás o 127 adelante de
la ubicación que sigue a la instrucción. Para remediar este
problema, puede recurrirse a usar la bifurcación opuesta a la
dirección inmediata, seguida de una bifurcación incondicional
a la dirección original, ya que la bifurcación incondicional
no tiene esta limitación al presentarse en dos formatos
(corto y cercano). Por ejemplo, este fragmento de programa:</p>
<pre class="literal-block1">
|        je   Lejos
|     Cerca:
|     ................................
|     Lejos:
|     ................................
</pre>
<p class="calibre5">puede reemplazarse por este otro:</p>
<pre class="literal-block1">
|        jne   Cerca
|        jmp   Lejos
|     Cerca:
|     ................................
|     Lejos:
|     ................................
</pre>
<p class="calibre5">Como veremos más adelante, el Ensamblador puede hacer esto
automáticamente.</p>
<p class="calibre5"><strong class="calibre4">7.5. Incremento y decremento</strong></p>
<p class="calibre5">Las operaciones de sumar o restar una unidad son tan comunes
que se han diseñado instrucciones especiales para las mismas.
Son INC y DEC, que tienen un solo operando:</p>
<pre class="literal-block1">
|     inc   cl                     ; CL = CL + 1
|     inc   bx                     ; BX = BX + 1
|     inc   Rotulo                 ; Byte o palabra
|     inc   BYTE PTR [si]          ; Byte
|     inc   Rotulo [bx] [di]       ; Byte o palabra
|     dec   ch                     ; CH = CH - 1
|     dec   ax                     ; AX = AX - 1
|     dec   Rotulo                 ; Byte o palabra
|     dec   Rotulo + 3 [di] [bx]   ; Byte o palabra
</pre>
<p class="calibre5">Estas instrucciones respectivamente incrementan o decrementan
sus operandos en una unidad, de modo que por ejemplo las dos
instrucciones siguientes serían prácticamente equivalentes:</p>
<pre class="literal-block1">
|     inc   cl
|     add   cl, 1
</pre>
<p class="calibre5">Además del ahorro de tiempo y de espacio, hay una diferencia
importante: las instrucciones INC y DEC no afectan la bandera
de acarreo (CF), contrariamente a las de suma o de resta;
siguen afectando las otras banderas: OF, SF, ZF, AF y PF.</p>
<p class="calibre5"><strong class="calibre4">7.6. Push y pop</strong></p>
<p class="calibre5">La instrucción PUSH toma una palabra y la inserta en la “cabeza” de la Pila (stack). La palabra insertada puede provenir
de la memoria o de uno de los registros de 16 bits AX, BX,
CX, DX, SI, DI, SP, BP, o de los registros de segmento CS,
DS, SS, ES. Para insertar el registro de estado ST (que contiene las banderas o flags), existe una instrucción especial,
PUSHF.</p>
<p class="calibre5">Insertar significa decrementar el registro SP en 2 unidades y copiar la palabra designada en el lugar donde apuntan
SP como desplazamiento y SS como segmento.</p>
<p class="calibre5">El caso de PUSH SP es especial. Mientras que los procesadores 8086, 8088 y 80186 decrementan SP y luego lo insertan,
los procesadores 80286, 80386, 80486 y Pentium insertan SP
como estaba antes de la instrucción y luego lo decrementan.
Esto crea cierta incompatibilidad entre estos grupos de
procesadores, pero de cualquier manera es raro que se ejecute
PUSH SP.</p>
<p class="calibre5">La instrucción POP hace lo inverso de PUSH, es decir, toma
una palabra desde la dirección donde apuntan SS:SP, la copia
a la ubicación de memoria o al registro designado, e incrementa en 2 unidades el contenido de SP. Hay una excepción:
POP CS no es válido, o sea que no es posible alterar la ubicación desde donde se ejecuta un programa por medio de POP.
Para cargar el registro ST existe una instrucción especial
POPF.</p>
<p class="calibre5">Veamos algunos ejemplos de instrucciones PUSH y POP:</p>
<pre class="literal-block1">
|     push   bx
|     push   Rotulo                 ; Debe ser palabra
|     push   [di]
|     pushf
|     pop    ax
|     pop    es
|     pop    Rotulo + 2 [si] [bx]   ; Debe ser palabra
|     popf
</pre>
<p class="calibre5">Al usar PUSH y POP debe tenerse cuidado de que se equilibren,
es decir, que se ejecuten tantos PUSH como POP durante el
transcurso de un programa. Si por ejemplo en un ciclo de un
programa se ejecuta repetidamente un PUSH sin el correspondiente POP, la Pila crecerá hasta desbordar su tamaño asignado. A la inversa, si se ejecuta repetidamente POP sin el
correspondiente PUSH, los datos finalmente no se tomarán de
la Pila sino de fuera de la misma.</p>
<p class="calibre5">Una de las tareas más frecuentes en que se usan PUSH y POP
es la de “salvar” registros, para usarlos a voluntad y después restaurar sus valores originales. Esto se hace en la
entrada y en la salida de las subrutinas, como después veremos. En ese caso, los POP deben darse en orden inverso a los
PUSH, para restaurar correctamente los registros. Por
ejemplo:</p>
<pre class="literal-block1">
|     push   ax   ; Salvar registros
|     push   bp
|     push   si
|     ................................
|     pop    si   ; Restaurar registros
|     pop    bp
|     pop    ax
</pre>
<p class="calibre5">De lo contrario, estaríamos restaurando valores en registros
que no les corresponden.</p>
<p class="calibre5">Sin embargo, en otras oportunidades lo que se pretende no
es salvar y restaurar registros. Por ejemplo, podríamos
intercambiar los contenidos de los registros BX y CX con la
siguiente secuencia de instrucciones:</p>
<pre class="literal-block1">
|     push  bx
|     push  cx
|     pop   bx
|     pop   cx
</pre>
<p class="calibre5">Esto nos ha servido como ejemplo, pero más adelante veremos
que hay maneras más eficientes para intercambiar el contenido
de dos registros de propósito general. En cambio, la secuencia de push y pop vista es eficiente para intercambiar registros de segmento.</p>
<p class="calibre5"><strong class="calibre4">7.7. Programa ejemplo</strong></p>
<p class="calibre5">A efectos de practicar con los conceptos vistos, escribiremos
un programa para leer desde el teclado una cadena de caracteres. Luego la invertiremos, dejándola en otra área (es decir,
pondremos el último carácter como primero, y así sucesivamente). Finalmente desplegaremos el resultado por la pantalla.</p>
<pre class="literal-block1">
|; Leer, invertir y desplegar una cadena de caracteres.
|            .MODEL   small
|            .STACK   100h
|            .DATA
|Longitud   EQU   100
|Dato       DB    Longitud DUP (?)
|Result     DB    Longitud DUP (?)
|            .CODE
|Comienzo:
|            mov   ax, @data         ; Apuntar a datos
|            mov   ds, ax
|            mov   ah, 3fh           ; Función de lectura
|            mov   bx, 0             ; Entrada estándar
|            mov   cx, Longitud      ; Longitud máxima
|            mov   dx, OFFSET Dato   ; Lugar donde guardar
|            int   21h               ; Llamar al DOS
|            cmp   ax, 0             ; Ver si se leyó algo
|            jz    Fin
|            mov   cx, ax            ; Guardar longitud leída
|            push  cx                ; Guardarla para después
|            mov   si, OFFSET Dato   ; Poner valor inicial
|            mov   di, OFFSET Result ; Idem
|            add   di, cx            ; Apuntar al fin + 1
|            dec   di                ; Corregir
|Volver:                            ; Aquí ciclaremos
|            mov   al, [si]          ; Tomar próximo carácter
|            mov   [di], al          ; Guardarlo
|            inc   si                ; Próximo byte de origen
|            dec   di                ; Próximo byte de destino
|            dec   cx                ; Contar uno menos
|            jnz   Volver            ; Ciclar si no llegó a 0
|            pop   cx                ; Restaurar longitud
|            mov   ah, 40h           ; Función de despliegue
|            mov   bx, 1             ; Salida estándar
|            mov   dx, OFFSET Result ; Arranque de la cadena
|            int   21h               ; Llamar al DOS
|Fin:
|            mov   ah, 4ch           ; Función de terminación
|            int   21h               ; Llamar al DOS
|            END   Comienzo
</pre>
<p class="calibre5">Explicaremos solamente las novedades que se observan en este
programa.:</p>
<pre class="literal-block1">
| Longitud   EQU   100
</pre>
<p class="calibre5">EQU es una directiva que indica que, cada vez que se use el
rótulo, se lo reemplazará por lo que sigue a EQU. Por lo
tanto, en este caso, cada vez que usemos Longitud, este
rótulo será reemplazado por el valor 100.</p>
<p class="calibre5">Esta directiva permite modificar rápida y fácilmente un
programa, al reemplazar una modificación en cada lugar donde
aparezca el rótulo por una sola modificación en el programa.:</p>
<pre class="literal-block1">
| Dato   DB   Longitud DUP (?)
</pre>
<p class="calibre5">Acá hay varios elementos nuevos para considerar. En primer
lugar, de acuerdo con lo anterior, reemplacemos Longitud por
su valor, 100. El signo de interrogación ? indica que no
interesa el valor inicial que contendrá el área de datos,
pues lo reemplazaremos por otro durante el transcurso del
programa. Un signo ? en una directiva DB equivale a un único
byte. La indicación DUP precedida por un número indica repetir lo que siga entre paréntesis tantas veces como especifique el número. O sea que todo esto significa asignarle al
rótulo Dato un área de memoria de 100 bytes, sin especificar
su contenido.:</p>
<pre class="literal-block1">
|      mov   ah, 3fh   ; Función de lectura
</pre>
<p class="calibre5">Cargamos 3fh en el registro AH para indicar otra función del
DOS, al que se llamará con la interrupción 21h. Esta función
lee datos desde un dispositivo de entrada.:</p>
<pre class="literal-block1">
|      mov   bx, 0   ; Entrada estándar
</pre>
<p class="calibre5">La función 3fh exige que se indique en el registro BX el
número de dispositivo por donde se leerán los datos. Un 0
indica la entrada estándar, que es el teclado (a menos que se
redirija; la redirección es una opción de los comandos del
DOS).:</p>
<pre class="literal-block1">
|      mov   cx, Longitud   ; Longitud máxima
</pre>
<p class="calibre5">La función 3fh necesita que se le especifique en el registro
CX la longitud máxima de los datos a leer.:</p>
<pre class="literal-block1">
|      mov   dx, OFFSET Dato   ; Lugar donde guardar
</pre>
<p class="calibre5">También hace falta indicar en el registro DX el desplazamiento del comienzo de los datos, dando por implícito el registro
de segmento DS.:</p>
<pre class="literal-block1">
|      cmp   ax, 0   ; Ver si se leyó algo
</pre>
<p class="calibre5">Una vez leída la cadena de caracteres, la función 3fh retorna
en el registro AX la longitud efectiva de los datos ingresados. Esta prueba para ver si se ingresó algo (y en caso
contrario bifurcar a Fin) es necesaria porque, si la longitud
fuera nula, una prueba posterior (jnz Volver) ciclaría 65.536
veces en lugar de no hacerlo nunca.:</p>
<pre class="literal-block1">
|      mov   cx, ax   ; Guardar longitud leída
</pre>
<p class="calibre5">Como usaremos el registro AX para otro fin, salvamos en CX
esta longitud.:</p>
<pre class="literal-block1">
|      push   cx   ; Guardarla para después
</pre>
<p class="calibre5">Pero como también modificaremos CX, guardamos su valor en la
Pila.:</p>
<pre class="literal-block1">
|     mov   si, OFFSET Dato     ; Poner valor inicial
|     mov   di, OFFSET Result   ; Idem
|     add   di, cx              ; Apuntar al fin + 1
|     dec   di                  ; Corregir
</pre>
<p class="calibre5">Estas instrucciones dan valores iniciales a dos apuntadores
que usaremos para invertir la cadena. El registro SI apunta
al comienzo de Dato (de donde se tomará la cadena). El
registro DI comienza apuntando al comienzo de Result (donde
se copiará la cadena, invertida); luego, al sumarle Longitud,
se lo lleva a una posición después del fin de Result; y
finalmente se lo decrementa en 1 para efectivamente apuntar
al fin.:</p>
<pre class="literal-block1">
| Volver:         ; Aquí ciclaremos
</pre>
<p class="calibre5">Este rótulo es el punto de comienzo del ciclo finalizado con
jnz Volver; en realidad, el comienzo es la próxima instrucción. Esta ubicación del rótulo permite insertar fácilmente
instrucciones que pudieran faltar al comienzo del ciclo.:</p>
<pre class="literal-block1">
|     mov   al, [si]   ; Tomar próximo carácter
|     mov   [di], al   ; Guardarlo
</pre>
<p class="calibre5">Estas dos instrucciones copian un carácter desde donde apunta
SI hasta donde apunta DI (la primera vez SI apunta al comienzo de Dato y DI al fin de Result; luego apuntarán al carácter
siguiente y al anterior, respectivamente, y así siguiendo).
No es posible hacerlo con una única instrucción mov [di],
[si] pues, como se explicó antes, no es válida al tener ambos
operandos en la memoria. Por lo tanto se usa el registro AL
como lugar intermedio.:</p>
<pre class="literal-block1">
|     inc   si   ; Próximo byte de origen
|     dec   di   ; Próximo byte de destino
</pre>
<p class="calibre5">Estas instrucciones modifican los apuntadores para que
apunten al próximo byte a copiar.:</p>
<pre class="literal-block1">
|     dec   cx       ; Contar uno menos
|     jnz   Volver   ; Ciclar si no llegó a 0
</pre>
<p class="calibre5">Con estas instrucciones seguimos ejecutando la parte de programa desde Volver en tanto CX, que se decrementa, no sea
cero. Por ejemplo, si CX contuviera originalmente 1, quedaría
en 0 luego del decremento y no se efectuaría el salto, con lo
que se hubiera copiado un solo carácter, que es lo correcto.
Nótese que si CX contuviera 0, quedaría en -1 luego del
decremento; como -1 equivale a 65.535 si se lo interpreta sin
signo, la copia de un carácter se ejecutaría un total de
65.536 veces, lo que por cierto no es lo deseado. Por consiguiente, debemos evitar que se llegue a este punto con CX
conteniendo 0 la primera vez, que es lo que hicimos en un
paso previo.</p>
<p class="calibre5">Aprovechamos para señalar una causa de error común en los
programas: si por descuido faltara la instrucción dec cx, el
programa no terminaría nunca y sería necesario reinicializar
la computadora.:</p>
<blockquote class="calibre25">
<div class="line-block">
<div class="line">pop   cx   ; Restaurar longitud</div>
</div>
</blockquote>
<p class="calibre5">Terminado el ciclo de copia, debemos recuperar la longitud
para usarla en la función de despliegue, que la requiere en
el registro CX.:</p>
<pre class="literal-block1">
|      mov   ah, 40h   ; Función de despliegue
</pre>
<p class="calibre5">Cargamos 40h en el registro AH para que, cuando llamemos al
DOS con la interrupción 21h, le estemos indicando una función
de despliegue. Esta función de despliegue 40h, a diferencia
de la 9h, no requiere el signo $ como carácter terminal, sino
la longitud del dato en CX.:</p>
<pre class="literal-block1">
|      mov   bx, 1   ; Salida estándar
</pre>
<p class="calibre5">Esta función también requiere en el registro BX el número del
dispositivo de salida. El número 1 corresponde a la salida
estándar, que es la pantalla (a no ser que se redirija).:</p>
<pre class="literal-block1">
|      mov   dx, OFFSET Result   ; Arranque de la cadena
</pre>
<p class="calibre5">También se requiere indicar en el registro DX el desplazamiento correspondiente al comienzo de la cadena que se desplegará.</p>
<p class="calibre5">Con esto llegamos al fin de la explicación.</p>
<p class="calibre5">Es necesario advertir que un problema dado, en Ensamblador
o en cualquier otro lenguaje, no tiene una solución única,
sino que, por lo contrario, el número de soluciones posibles
es prácticamente infinito. Por supuesto, algunas soluciones
serán más eficientes, más elegantes o más fáciles que otras.
En este texto trataremos de dar las soluciones más sencillas
e ilustrativas.</p>
<p class="calibre5"><strong class="calibre4">7.8. Ejercicio nº 1</strong></p>
<p class="calibre5">Sugerimos realizar el siguiente ejercicio como modificación
del programa precedente: dada una cadena de caracteres,
invertirla en el lugar, es decir, sin usar un área de resultado. Se supone que la longitud de la cadena ya está en el
registro CX, y no se requiere incluir la inicialización, la
lectura de los datos, el despliegue de los mismos ni la
finalización del programa, pues serían idénticos a los recién
vistos.</p>
<p class="calibre5">Tras realizar el ejercicio, consúltese una solución en
<a href="#soluciones">SOLUCIONES</a> (en el Apéndice A cuando completemos la
publicación de este manual) antes de proseguir con el texto.</p>
<p class="calibre5"><strong class="calibre4">7.9. Ejercicio nº 2</strong></p>
<p class="calibre5">Proponemos llenar de caracteres “blanco” (“espacio”) una
cadena. Como antes, no se requiere incluir inicialización,
etc. La longitud del dato se halla en el registro CX. En
SOLUCIONES (pág. 395) (Apéndice A cuando el manual esté completo) se ven dos soluciones distintas para este ejercicio.</p>
<p class="calibre5"><strong class="calibre4">7.10. Ejercicio nº 3</strong></p>
<p class="calibre5">Deseamos eliminar los blancos de una cadena de caracteres; el
resultado ocupará la misma cadena. Como la cadena probablemente quedará más corta, una cuestión pendiente es qué ocurre
con los caracteres de cola sobrantes. Un criterio consiste en
completar la cadena con blancos; otro, retornar una longitud
menor; adoptaremos aquí el primer criterio. Supondremos que
la longitud es fija de 80 caracteres. Véase una solución en
SOLUCIONES (pág. 395) (Apéndice A en el manual completo).</p>
</div>
<div class="line" id="soluciones">
<h4 class="calibre28"><a class="toc-backref1" href="#id5">SOLUCIONES</a></h4>
<p class="calibre5"><strong class="calibre4">Ejercicio nº 1.</strong></p>
<p class="calibre5">El método que se usará consiste en intercambiar caracteres
comenzando por ambos extremos. Cuando se llegue al medio, se
terminará el ciclo. En efecto, si se siguiera hasta alcanzar
los extremos opuestos, se habrían intercambiado los caracteres dos veces, con lo cual quedarían como estaban al principio.:</p>
<pre class="literal-block1">
| ; Invertir una cadena en el lugar.
|
|             .DATA
| Longitud   EQU   100
| Dato       DB   Longitud DUP (?)
|             .CODE
|      ................................
|             mov   si, OFFSET Dato   ; Dar valores iniciales
|             mov   di, si            ; Calcular fin del dato
|             add   di, cx
|             dec   di
| Volver:
|             cmp   di, si            ; Ver si se llegó al medio
|             jbe   Fin
|             mov   al, [si]          ; Intercambiar caracteres
|             mov   ah, [di]
|             mov   [di], al
|             mov   [si], ah
|             inc   si                ; Apuntar al byte
| siguiente
|             dec   di                ; Apuntar al byte anterior
|             jmp   Volver
| Fin:
|      ................................
</pre>
<p class="calibre5">Contrariamente al ejemplo del texto principal, la prueba de
fin se realiza antes de efectuar el intercambio, previendo
que la longitud pudiera ser nula, en cuyo caso no se efectuará ningún intercambio. La bifurcación JBE tiene en cuenta
varias cosas: primero, que el valor de CX pueda ser tan
grande (o negativo) que DI quede abajo de SI, en cuyo caso no
debería realizarse intercambio alguno, intercambio que ocurriría si la bifurcación fuese JE; segundo, si el valor de DI
fuera mayor que 32.767, no se lo debería considerar con signo
por medio de JLE; por eso usamos JBE, que lo trata como sin
signo.</p>
<p class="calibre5">En este ejercicio hemos usado una técnica para intercambiar datos distinta de la explicada al tratar la instrucciones PUSH y POP. Ambas tienen aproximadamente la misma eficiencia; no obstante, en este caso no habríamos podido usar
PUSH y POP, debido a que dichas instrucciones procesan palabras, y en este caso debemos procesar bytes.</p>
<p class="calibre5"><strong class="calibre4">Ejercicio nº 2</strong></p>
<pre class="literal-block1">
| ; Llenar de blancos una cadena de caracteres.
|
|             .DATA
| Longitud   EQU   80
| Cadena     DB   Longitud DUP (?)
|             .CODE
|      ................................
|             mov   si, OFFSET Cadena   ; Dar valores iniciales
|             mov   di, si
|             add   di, cx
| Sigue:
|             cmp   si, di              ; Ver si se llegó al fin
|             jae   Termina
|             mov   BYTE PTR [si], ' '   ; Poner un blanco
|             inc   si                   ; Ir al byte siguiente
|             jmp   Sigue
| Termina:
|      ................................
</pre>
<p class="calibre5">Es necesario añadir BYTE PTR a la instrucción que pone un
blanco, para eliminar la ambigüedad. En efecto, mov [si], ‘ ‘
podría referirse tanto a byte como a palabra, porque el segundo operando se toma con su valor ASCII independientemente
de que haya entre apóstrofos sólo un carácter.</p>
<p class="calibre5">Como en el ejercicio anterior, la prueba de fin se realiza
antes del ciclo, previendo una posible longitud nula.</p>
<p class="calibre5">Nótese que en este caso no hemos ajustado una posición
hacia abajo DI, porque no es necesario. Si lo hubiéramos
hecho, entonces deberíamos cambiar la instrucción JAE por JA.
Uno de los errores más comunes, tanto en Ensamblador como en
otros lenguajes, consiste en realizar un ciclo una vez más o
una vez menos de lo correcto. Incurriríamos en este error si
en el programa cambiáramos JAE por JA (ejecutaríamos el ciclo
una vez más), o si antes del rótulo Sigue agregáramos DEC DI
y dejáramos JAE (lo ejecutaríamos una vez menos).</p>
<p class="calibre5">Si en este ejercicio la longitud de la cadena no estuviera
en el registro CX sino que fuera constante e igual a Longitud, entonces podríamos acortar la solución como sigue:</p>
<pre class="literal-block1">
|      ................................
|             mov   si, OFFSET Cadena     ; Dar valor inicial
| Sigue:
|             cmp   si, OFFSET Cadena + Longitud  ; Ver si fin
|             jae   Termina
|             mov   BYTE PTR [si], ' '    ; Poner un blanco
|             inc   si                    ; Ir al byte siguiente
|             jmp   Sigue
| Termina:
|      ................................
</pre>
<p class="calibre5">Veamos otra solución, en la cual intentamos reducir el número
de instrucciones dentro del ciclo, para aumentar la velocidad
de proceso.</p>
<p class="calibre5">A efectos de aumentar la velocidad de proceso, es aconsejable reducir el tiempo de proceso dentro de los ciclos, aun
a expensas de aumentarlo afuera, porque el ciclo se ejecuta
muchas veces. En cuanto al espacio ocupado, obviamente no
importa si es dentro o fuera del ciclo.:</p>
<pre class="literal-block1">
| ; Llenar de blancos una cadena de caracteres,
| ; segunda solución
|
|             .DATA
| Longitud   EQU   80
| Cadena     DB   Longitud DUP (?)
|             .CODE
|      ................................
|             cmp   cx, 0   ; Probar longitud nula
|             je    Termina
|             mov   si, cx   ; Cargar índice
| Sigue:
|             mov   Cadena - 1 [si], ' '   ; Poner un blanco
|             dec   si   ; Ir al byte anterior
|             jnz   Sigue
| Termina:
|      ................................
</pre>
<p class="calibre5">Hemos recurrido a la siguiente técnica: en lugar de operar
con un apuntador en el registro SI, lo hacemos con el desplazamiento a partir del origen del vector de datos; y en lugar
de procesar en el sentido creciente de las direcciones, lo
hacemos en el decreciente, para poder probar si el desplazamiento es 0 directamente luego de la instrucción DEC, sin
necesidad de una comparación. Un beneficio adicional que trae
aparejado esto es que se elimina la bifurcación incondicional
al final. El ajuste Cadena - 1 es necesario para que la última vez que se ejecute el ciclo sea con el valor 1 en SI y por
lo tanto en el comienzo de Cadena. Por otra parte, esto también ayuda al comienzo del ciclo, pues la dirección Cadena 1 + Longitud es justamente la del fin de Cadena.</p>
<p class="calibre5">Antes de entrar en el ciclo debimos probar si la longitud
era nula, pues de lo contrario el ciclo se habría ejecutado
65.536 veces en lugar de 0, como se explicó oportunamente.
En este caso, la mejora en tiempo trajo aparejada una disminución del espacio ocupado, pero no siempre es así.</p>
<p class="calibre5"><strong class="calibre4">Ejercicio nº 3</strong></p>
<pre class="literal-block1">
| ; Eliminar los blancos de una cadena
|             .DATA
| Longitud   EQU   80
| Cadena     DB   Longitud DUP (?)
|             .CODE
|      ................................
|             mov   di, OFFSET Cadena   ; Indice de destino
|             mov   si, di              ; Indice de origen
| Otro:
|             cmp   si, OFFSET Cadena+Longitud  ; Si se completó
|             jae   Sigue
|             mov   al, [si]            ; Guardar byte
|             inc   si                  ; Incrementar origen
|             cmp   al, ' '             ; Ver si es blanco
|             je    Otro                ; Si es, tomar otro
|             mov   [di], al            ; Si no es, transferirlo
|             inc   di                  ; Incrementar destino
|             jmp   Otro
|
| Sigue:
| ; Completar cola con blancos
|             cmp   di, si              ; Ver si fin
|             jae   Fin
|             mov   BYTE PTR [di], ' '  ; Poner un blanco
|             inc   di   ; Ir al próximo
|             jmp   Sigue
| Fin:
|      ................................
</pre>
<p class="calibre5">La técnica consiste en copiar la cadena sobre sí misma, cada
carácter desplazado hacia atrás tantas posiciones como blancos había antes del mismo. Esto se logra simplemente evitando
incrementar el índice de destino cuando el carácter a transferir sea un blanco.</p>
<p class="calibre5">Obsérvese que es posible usar varias bifurcaciones distintas para el mismo fin; nos referimos a jae Sigue y jae Fin.
Por ejemplo, en lugar de JAE podríamos usar JE, ya que la
condición de igual es la primera que se producirá. La bifurcación JGE ya no es tan correcta; en efecto, con valores muy
grandes del desplazamiento de Cadena + Longitud podríamos
tener el resultado contrario al necesario, si el bit de mayor
orden de este desplazamiento llegara a ser 1.</p>
<hr class="docutils"/>
<p class="calibre5">En la próxima entrega de este manual:</p>
<p class="calibre5">Seccion 8:</p>
<ul class="calibre2">
<li class="calibre3">Aritmética de Precisión Múltiple.</li>
</ul>
<p class="calibre5">Sección 9:</p>
<ul class="calibre2">
<li class="calibre3">Operaciones Lógicas.</li>
</ul>
</div>
</div>
</div>
</div>

</div>

</body>
</html>
