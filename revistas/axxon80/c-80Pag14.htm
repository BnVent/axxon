<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 80 - SECCIÓN: - Revista virtual de Informática</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">Revista virtual de Informática</h1>
<p class="calibre5"><b class="calibre4">Ricardo M. Forno / Mark Fritz</b></p><p class="calibre5"></p>
<div class="calibre1">
<p class="resumen1">Prácticamente todas las actividades y profesiones humanas
tienen asociado un tipo de humor característico. Así,
está el humor militar o el de los médicos. La computación
no es una excepción, y presenta rasgos peculiares. Tenemos
por un lado los chistes gráficos, en general bastante malos,
que aparecen en las revistas del ramo. Mejores son los chistes
involuntarios: las bromas que a veces nos gastan las propias
computadoras, las gaffes de los manuales serios, los equívocos…
Hemos visto últimamente toques de humor en manuales
por otra parte perfectamente serios.</p>
<div class="line" id="el-humor-en-la-computacion">
<h2 class="indiceautor">EL HUMOR EN LA COMPUTACION</h2>
<p class="calibre5">Ing. Ricardo M. Forno  - 1996</p>
<p class="pcalibre1 pri1">En esta oportunidad presentaremos un caso de humor deliberado:
un artículo publicado en el Volumen 27, Número 4 (Abril de
1984) de la muy seria “Communications of the ACM”, el que es
a su vez reproducción de un memorándum técnico interno de los
Laboratorios Bell, del año 1959. En el mismo se satiriza la
pedantería de sesudos estudios y disquisiciones filosóficas,
pero… dejemos que el texto nos lo cuente.</p>
<p class="pcalibre1 pri1">EL CAOSTRON: UN ADELANTO IMPORTANTE EN MAQUINAS QUE APRENDEN
J. B. Cadwallader-Cohen, W. W. Zysiczk y R. B. Donnelly</p>
<p class="calibre5">Caostrón es una máquina que aprende, la cual incorpora varias
características de diseño radicalmente nuevas. Se describen
las mismas y se dan algunos resultados de experimentos con el
Caostrón.</p>
<p class="calibre5">El concepto del Caostrón se desarrolló a partir de informes
sobre el comportamiento de animales en relación al aprendizaje, en situaciones que inducen tensión. Dos ejemplos son
dignos de mencionar:</p>
<p class="calibre5">En 1948, Boosie estudió el comportamiento de gatos en un
ambiente acuoso. Típicamente, un gato confinado en una jaula
totalmente inmersa en agua exhibe un período inicial de
acción desorganizada aparentemente aleatoria, con gran
despliegue muscular. Este patrón de comportamiento cesa, a
menudo en forma completamente abrupta, cuando el animal
descubre que un estado de desgaste energético reducido
permite la detención de la actividad respiratoria. Que en
efecto el aprendizaje tiene lugar es incuestionable, pues la
presentación de estímulos adicionales no ocasiona que el
animal retorne a su condición inicialmente activa (y mal
adaptada).</p>
<p class="calibre5">J. C. Gottesohn ha informado sobre hallazgos notablemente
similares en su monumental estudio sobre las creencias religiosas de los chimpancés. Diferimos con respecto a Gottesohn
en la interpretación de algunos de sus resultados, pero los
puntos principales están claros: en una situación tensa hay
un período de prueba y error aleatorios que precede a la
solución del problema, y la misma es hallada usualmente de
manera totalmente repentina, en su forma completa y final.
Esto, entonces, provee la base del Caostrón. Los autores
creen firmemente que la clave para la automatización exitosa
de las tareas de aprendizaje se halla en la aleatorización
del modelo de respuesta de la máquina. La falla de varios
intentos previos en tal sentido, creemos, ha sido debida a
dos problemas: primero, la dificultad de obtener un grado
suficiente de aleatoriedad en la propia estructura de la
máquina, y segundo, el costo de crear un dispositivo lo
suficientemente grande como para exhibir comportamiento no
influido significativamente por la operación de cualquiera
de sus componentes. Estamos profundamente agradecidos al Dr.
R. Morgan por una sugestión que nos mostró la manera de eludir
tales dificultades: el diseño del Caostrón se logró obteniendo 14.000 planos de cableado de la Western Electric,
cortándolos en cuadrados de cinco centímetros de lado y, tras
mezclarlos a conciencia en una gran bolsa, haciéndolos pegar
en hojas de tamaño adecuado por un operario encapuchado.
Durante el proceso se efectuaron cuidadosas comprobaciones y
pruebas estadísticas para impedir la propagación de regularidades no sospechadas.</p>
<p class="calibre5">Desgraciadamente, todavía no hemos podido terminar el
cableado del Caostrón. Creímos, no obstante, que sería
posible estimar la efectividad del Caostrón aun antes de su
finalización, simulándolo en una computadora digital de alta
velocidad. Este procedimiento tuvo la ventaja adicional de
atraer el interés de representantes de la Oficina de Suministros y Cuentas de la Marina de los Estados Unidos, que halló
en el Caostrón una excelente ayuda para controlar el inventario de repuestos de la Marina. Como resultado, la Marina fue
tan generosa como para ofrecer tiempo de una computadora
BuShips para la simulación del Caostrón.</p>
<p class="calibre5">La computadora elegida para las corridas fue la máquina
IBM STRETCH, que no sólo opera a muy alta velocidad, sino que
también acepta programas fuente codificados en el Lenguaje
YAWN <a href="#id3" id="id1">[1]</a>, que se asemeja mucho al inglés popular. Estimamos
muy importante poder usar para los programas de simulación un
lenguaje fuente que contuviera tanta ambigüedad como el habla
ordinaria, ya que una precisión indebida en la especificación
de tales programas podría “soplarle” accidentalmente a la
máquina la naturaleza de las soluciones buscadas.</p>
<p class="calibre5">Circunstancialmente, no fue posible obtener una computadora STRETCH para el proyecto, y por consiguiente la simulación se efectuó en una IBM 704 simulando una STRETCH
simulando el Caostrón. Todas las corridas de simulación se
condujeron en universos ambientales esencialmente similares:
se presentó a la computadora una secuencia de círculos,
cuadrados y cruces representados en tarjetas perforadas, y se
le requirió imprimir una de las palabras “círculo”, “cuadrado” o “cruz” tras examinar cada estímulo. El experimentador
no proveyó recompensa alguna, pues se temió que tal recompensa podría desviar el proceso de aprendizaje y viciar por
consiguiente la validez de cualquier conclusión que pudiéramos desear extraer de los resultados.</p>
<p class="calibre5">Se corrieron las primeras pruebas con los estímulos de
entrada representados en las tarjetas perforadas como patrones geométricos de las formas apropiadas. Como control, se
efectuó una primera corrida sin tener inicialmente programa
alguno almacenado, para verificar que la tasa de aprendizaje
de la máquina librada a sí misma no fuera tan grande como
para interferir con futuros estudios. Para esta corrida, se
borró la memoria de la máquina, se colocaron las tarjetas con
las formas en el alimentador de lectura, y se presionó el
botón de carga desde tarjetas. Luego de tres horas, la
máquina no había impreso su respuesta a la primera forma
ingresada; evidentemente, la tasa de aprendizaje en tales
condiciones es muy baja (la estimamos en el orden de 10-6
conceptos por megaaño).</p>
<p class="calibre5">Consecuentemente, proseguimos con la serie principal de
experimentos, en la cual se cargó en la computadora un
programa aleatorio delante de cada lote de tarjetas de datos.
Se probó un total de 133 programas aleatorios, en secuencia
aleatoria. Aun en esta serie de experimentos, la máquina tomó
un tiempo sorprendentemente largo para responder a los estímulos; en la mayoría de los casos, se debió terminar la
corrida antes de que apareciera la primera respuesta. No
obstante, en la corrida número 73, la computadora respondió:</p>
<p class="calibre5">***/  $   A X$,  )U  ,,,,,</p>
<p class="calibre5">a la primera tarjeta de estímulo (¡que era un cuadrado!); en
la corrida 114, la computadora respondió:</p>
<p class="calibre5">66666666666666666666666666666666</p>
<p class="calibre5">a cada estímulo; y en la corrida 131 la computadora expulsó
el papel de la impresora por dos veces.</p>
<p class="calibre5">Desafortunadamente, dificultades de presupuesto nos obligaron a abandonar este enfoque luego de 133 corridas, pese a
la apariencia prometedora de los primeros resultados. Por lo
tanto, nuestras conclusiones se basan forzosamente en una
muestra de datos menor que la que hubiéramos deseado. Sin
embargo, han quedado claros ciertos puntos:</p>
<blockquote class="calibre28">
<ol class="arabic">
<li class="calibre3">El modelo de aprendizaje por recompensa correlativa, propuesto por Dewlap y otros, es insostenible en vista de nuestros resultados. Ningún sistema trifásico puede funcionar sin un grado de organización mayor que el usado en los estudios de simulación. Aun este grado de estructura, sin embargo, se reflejó en respuestas extremadamente lentas a estímulos comparativamente simples.</li>
<li class="calibre3">Parece evidente que una mayor comprensión del aprendi- zaje de las máquinas requiere resíntesis en términos opera- cionales del marco conceptual provisto por la sugerencia de Liebwald - Schurstein - Higgins de que las trazas de memoria son renovadas por incrementos estocásticos asociados a sendas ideométricas compartidas por elementos funcionales acoplados a estímulos.</li>
<li class="calibre3">No sólo es posible el aprendizaje de las máquinas, sino que en efecto ocurre en condiciones de considerable dificul- tad. Más aun, pareciera que hasta las máquinas más simples tienen una gran cantidad de “curiosidad” innata (donde con “curiosidad”, por supuesto, no queremos implicar que se deban aplicar categorías o juicios antropomórficos a máquinas, sino simplemente que las máquinas tienen el deseo de aprender).</li>
</ol>
</blockquote>
<p class="calibre5">Debemos reconocimiento y gratitud al Sr. J. B. Puffadder, por
su ayuda en el diseño detallado del Caostrón, y al Sr. V. A.
Vyssotsky <a href="#id4" id="id2">[2]</a> por simular manualmente la 704 simulando la
STRETCH simulando el Caostrón, para completar la corrida 133
luego de que se agotaran los fondos presupuestados. Debemos
también agradecimiento al Departamento de Marina, que proveyó
ayuda parcial para este proyecto bajo el contrato NsRD-BuS&amp;A111259.34a-GRQ1-77.C32.</p>
<table class="docutils1" frame="void" id="id3" rules="none">
<colgroup class="calibre17"><col class="label"/><col class="label"/></colgroup>
<tbody valign="top" class="calibre18">
<tr class="calibre19"><td class="label1"><a href="#id1">[1]</a></td><td class="label1"><ol class="first1" start="14">
<li class="calibre3">del T.: YAWN = Bostezo</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils1" frame="void" id="id4" rules="none">
<colgroup class="calibre17"><col class="label"/><col class="label"/></colgroup>
<tbody valign="top" class="calibre18">
<tr class="calibre19"><td class="label1"><a href="#id2">[2]</a></td><td class="label1"><ol class="first1" start="14">
<li class="calibre3">del T.: Mientras que el Sr. Vyssotsky no sólo existe sino que es bastante conocido en computación, probablemente el Sr. Puffadder sea ficticio y su apellido un rasgo de humor.</li>
</ol>
</td></tr>
</tbody>
</table>
<p class="pcalibre1 pri1">Traducción: R. M. Forno</p>
<hr class="docutils"/>
<p class="resumen1">Introducido a principio de los ‘80, y antes que la IBM PC,
el disco compacto le dio a mucha gente un primer contacto
con la era digital. Ahora este medio de almacenamiento
óptico es común, está siendo llevado a una mayor capacidad
y ha alcanzado la posición de reemplazar a la cinta de video,
al igual que lo que ocurrió con la grabación de discos
musicales sobre vinilo.</p>
</div>
<div class="line" id="discos-de-video-digital">
<h2 class="indiceautor">DISCOS DE VIDEO DIGITAL</h2>
<p class="calibre5">Mark Fritz - 1996</p>
<p class="pcalibre1 pri1">El disco compacto era, y todavía es, una maravilla de la
microingeniería. Estampado en un simple disco de policarbonato de 1,2 mm de grosor (es el mismo plástico que se usa en
las lentes de los anteojos), tiene más de dos mil millones de
pares de huecos y zonas planas, representando unos y ceros
digitales. Es una equivocación popular creer que cada hueco
representa un 1 y cada zona plana un 0. En realidad es la
transición, de llano a hueco o de hueco a llano, lo que representa un 1 lógico, mientras que la ausencia de transición
representa un 0 lógico. Estos huecos y llanos están ordenados
sobre una capa reflectiva en el disco en una única espiral
continua que está enroscada de un modo tan apretado (aproximadamente 40.000 pistas por centímetro) que un cabello humano
cubriría más de 50 pistas.</p>
<p class="calibre5">El aparato que lee estos discos, el reproductor de CD, es
igual de maravilloso. Sus dos características centrales (alojadas juntas en el mismo minúsculo componente: la cabeza) son
un diodo láser, que proyecta un rayo infrarrojo sobre los
huecos y llanos, y un lente colector que recibe la luz reflejada. A causa de que los llanos reflejan la luz del láser
directamente y los hoyos la dispersan, mientras el disco gira
se crea un patrón de reflexiones fuertes y débiles. El lente
colector reúne la luz reflejada y la dirige a un fotodiodo,
que convierte el patrón de fluctuaciones de luz a un patrón
de fluctuaciones de voltaje. Esta información digital se pasa
luego por un convertidor digital-analógico, de modo de poder
reproducirla como ondas sonoras por un sistema estéreo analógico.</p>
<p class="calibre5">Algunos años después de haber pasmado a los audiófilos, el
CD fue adaptado para su uso como medio de almacenamiento para
computadoras y llamado CD-ROM (memoria de sólo lectura en
disco compacto). La principal diferencia entre un CD de audio
y un CD-ROM es la necesidad del segundo de reservar mucho más
espacio en el disco para códigos de corrección de error, lo
cual asegura que una mota de polvo o una rayadura en el disco
no cambien la precisión con que el lector lea la información.</p>
<p class="calibre5">Casi todos estuvieron satisfechos con los 650 Mbytes de
capacidad del CD-ROM hasta que los estudios de Hollywood se
interesaron. Aún con la compresión de 200 a 1 suministrada
por el algoritmo MPEG 1, sólo se podrían meter 74 minutos de
video en un disco de densidad estándar. Fue claro para todos
que se necesitaban discos de mayor densidad. El resultado es
la teoría unificada del Disco de Video Digital (DVD), introducido por primera vez en diciembre de 1995.</p>
<p class="calibre5">Incrementar la capacidad de información del CD en realidad
no es tan difícil. Por años, los fabricantes de discos han
estado demostrando en sus laboratorios de desarrollo que pueden dominar CDs con densidades hasta 50 veces mayores que la
de un CD normal. Esencialmente, hacer un CD más denso significa hacer los huecos y llanos más pequeños y cercanos y
trazar más juntas las pistas en espiral.</p>
<p class="calibre5">La parte difícil es lograr compatibilidad con los modelos
anteriores, adaptando la capacidad de los reproductores de
CD-ROM para leer los nuevos discos de mayor densidad y sin
perder la capacidad de leer discos de audio estándar. El
verdadero truco es hacerlo sin aumentar significativamente
los costos de manufacturación.</p>
<p class="calibre5">El desafío más grande para los fabricantes de reproductores de CD-ROM es el desarrollo de mejores láseres. Piensen en
el rayo láser como en un spot de iluminación. La luz debe
estar enfocada con suficiente exactitud como para dar en los
huecos y llanos de una pista sin caer en las pistas adyacentes. La forma más directa de obtener un rayo más delgado es
usar un diodo láser que genere luz de una longitud más corta.</p>
<p class="calibre5">Los reproductores de CD-ROM actuales usan un láser
infrarrojo de luz invisible con una longitud de onda de 780
nanómetros. Lo ideal sería un láser de luz azul, puesto que
la luz azul tiene una longitud de onda mucho menor. Pero
después de casi una década de investigación el diodo láser de
luz azul compacto y de costo razonable sigue siendo esquivo.</p>
<p class="calibre5">Consecuentemente, los ingenieros electrónicos han vuelto
su atención hacia mejoras menos ambiciosas. Los investigadores de los DVD se centran en dos tipos de diodos láser de luz
roja visible que producen rayos con una longitud de onda de
635 o 650 nm. Tales diodos, que se pueden encontrar en muchos
lectores industriales de código de barras, están disponibles.</p>
<p class="calibre5">Otro factor importante en la adaptación de una unidad
lectora a densidades mayores es el poder de enfoque del
lente. La capacidad de enfocar la luz de un lente se mide por
una margnitud conocida como apertura numérica (NA). Un CD-ROM
estándar usa un lente con una NA de 0.45. La teoría DVD
incrementa la necesidad a una NA de 0.6. La mayoría de los
ingenieros electrónicos concuerdan en que esto es lo más
lejos que se puede llevar la NA sin acrecentar significativamente las tolerancias de falla en el mecanismo reproductor.</p>
<p class="calibre5">Combinando una disminución continua en la longitud de onda
con un incremento cada vez mayor en la calidad del lente, los
reproductores de DVD serán capaces de leer discos de siete
veces la densidad de los discos normales.</p>
<p class="calibre5">Para capacidades aún mayores, se planean los DVDs enlazados, o de doble faz, lo que significa que los usuarios
tendrán que dar vuelta sus discos manualmente. Aunque los
DVDs de doble faz serán esencialmente dos discos pegados
igual que los discos láser, es discutible si tendrán cabida
en el mercado.</p>
<p class="calibre5">Otro metodo de duplicación bajo investigación es el de
apilar dos capas de huecos y llanos mirando hacia arriba en
el mismo plástico. Las capas están separadas por un fotopolímero especial, semitransparente. Este fotopolímero es
suficientemente reflectivo como para devolver la luz láser de
la primer capa a la lente colectora y lo bastante transparente para permitir a la luz lo atraviese hacia la siguiente
capa de información, que yace debajo. Esto requiere una lente
colectora ajustable para reenfocar de una a otra, un desafío
mínimo de ingeniería, dado que los colectores actuales ya
pueden moverse ligeramente para compensar el alabeo del disco.</p>
<p class="calibre5">Sin embargo, a causa de que la señal láser es inevitablemente degradada al pasar a través del fotopolímero semitransparente, el método de la doble capa requiere que la segunda
capa sea tenga una densidad de datos ligeramente menor que la
primera. Por lo tanto, mientras que el disco de doble faz
aumentaría la capacidad total de un disco normal de 4,7 a 9,4
Gbytes, el disco de doble capa tendrá una capacidad ligeramente menor que el doble (8,5 Gbytes).</p>
<p class="calibre5">Por supuesto, eventualmente el CD se volverá obsoleto a
causa de alguna nueva tecnología, las más prometedoras son
los sistemas ópticos láser del “dominio de frecuencia” y la
holografía de información. Pero hablando a corto plazo, los
discos de mayor densidad nos ayudarán a llevarnos, junto a
mucha de nuestra información, al próximo siglo.</p>
</div>
<div class="line" id="lenguaje-ensamblador-8086-8088-parte-8">
<h2 class="indiceautor">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 8)</h2>
<p class="calibre5">Manejando el alma de la PC</p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<p class="pcalibre1 pri1"><strong class="calibre4">19. Distancias en memoria</strong></p>
<p class="calibre5">Hasta ahora no nos hemos preocupado mucho por los problemas
que pueden surgir cuando las distancias en memoria son
grandes, ya sea entre dos instrucciones o entre dos datos.
A continuación veremos los casos más importantes que se
producen por dicha circunstancia.</p>
<p class="calibre5"><strong class="calibre4">19.1. Bifurcaciones cortas, cercanas y lejanas</strong></p>
<p class="calibre5">Ya hemos visto que las instrucciones LOOP, LOOPE y LOOPNE
sólo pueden bifurcar a direcciones que como máximo estén a
128 bytes atrás o 127 adelante de la ubicación que sigue a la
instrucción. Ello se debe a que la diferencia de direcciones
está contenida en un byte. Esto es lo que se llama bifurcación corta (short). Lo mismo ocurre con las bifurcaciones
condicionales, por lo menos para el procesador 8086.</p>
<p class="calibre5">Las bifurcaciones incondicionales (JMP) también tienen
este formato corto. Pero además cuentan con un formato
distinto, llamado near (cercano). En el formato cercano, la
dirección relativa está contenida en dos bytes, por lo que su
valor va desde 0 hasta 65.535 considerándola sin signo. Esta
dirección relativa se suma al desplazamiento de la próxima
instrucción, y la suma reemplaza al IP. Como la suma se
realiza descartando el posible acarreo fuera de los 16 bits,
o sea módulo 216, la bifurcación se produce dentro del mismo
segmento, ya sea hacia adelante o hacia atrás.</p>
<p class="calibre5">Veamos un caso en el que se necesitaría este último
formato:</p>
<pre class="literal-block">
| ................................
|           .CODE
| ................................
|           jmp   Cerca
| Este:
|           cmp   al, 5
|           je   Cerca
|           mov   al, 8
|           jmp   Este
|           DB   500 DUP (0)
| Cerca:
|           mov   cx, 9
|           jmp   Este
| ................................
</pre>
<p class="calibre5">Es perfectamente posible incluir áreas de datos dentro del
segmento de código, como en este caso. Lo hemos hecho para
indicar fácilmente una separación de más de 127 bytes.</p>
<p class="calibre5">Dos de las tres bifurcaciones incondicionales de este
fragmento de programa son de tipo cercano, pero para el
Ensamblador representan problemas distintos. En efecto, el
Ensamblador va recorriendo el código fuente en forma secuencial. Cuando llega a la primera bifurcación (jmp Cerca)
todavía no ha encontrado el rótulo Cerca, de modo que no sabe
si está a más de 127 bytes de distancia o no, y por lo tanto
tampoco sabe si podrá generar una bifurcación corta o no, por
lo cual en principio la genera en formato cercano. Cuando
termina la compaginación, ya todas las instrucciones tienen
asignadas sus posiciones en la memoria, y el Ensamblador
verifica que su decisión fue correcta. Si en cambio la dirección de destino estuviera a menos de 128 bytes de distancia,
el Ensamblador cambiaría la bifurcación a formato corto (para
lograr mayor eficiencia) y, para dejar invariables las ubicaciones de las instrucciones, añadiría una instrucción de no
operación (NOP) luego de la bifurcación.</p>
<p class="calibre5">En el caso de la última bifurcación, el Ensamblador ya
conoce la ubicación del rótulo Este, y por consiguiente puede
tomar inmediatamente la decisión de dar el formato correspondiente (cercano) a la instrucción en lenguaje de máquina.</p>
<p class="calibre5">Por los mismos motivos, el formato de la segunda bifurcación incondicional será corto.</p>
<p class="calibre5">Este proceso se realiza como se describió si el Ensamblador efectúa una sola pasada por los datos. Sin embargo,
algunos ensambladores modernos como el Turbo de Borland
permiten realizar más de una pasada por los datos, y entonces
pueden ajustar el tamaño de las instrucciones a posteriori y
eliminar la necesidad de insertar códigos de no operación.</p>
<p class="calibre5">En el caso de la bifurcación condicional (je Cerca), no
existe para el procesador 8086 un formato que le permita
saltar más de 128 bytes hacia atrás o 127 hacia adelante. El
Ensamblador en este caso señala un error, a menos que tenga
la capacidad de modificar estas instrucciones. Si al Ensamblador Turbo de Borland se le introduce la directiva JUMPS,
el mismo modifica la bifurcación JE por una JNE a la instrucción siguiente, seguida de una bifurcación incondicional
al destino original. Esto puede hacerlo con todas las
bifurcaciones condicionales (excepto en el caso de JCXZ),
pues existe la opuesta de cada una.</p>
<p class="calibre5">Hemos visto que la instrucción JMP puede tener dos
formatos: corto, para distancias entre -128 y 127 bytes, y
cercano, para distancias dentro del segmento (65.536 bytes).
Pero como una PC puede tener hasta 220 bytes (1.048.576
bytes), en cualquiera de los cuales puede comenzar un fragmento de programa, se hace necesario proveer una bifurcación
de mayor alcance. Esto es lo que hace el formato far (lejano). Para usarlo, debe indicárselo explícitamente con FAR
PTR, así:</p>
<pre class="literal-block">
|           jmp   FAR PTR Otro
| ................................
| Otro:
| ................................
</pre>
<p class="calibre5">El Turbo Assembler de Borland necesita además que se agregue
el comando NOSMART (“no astuto”) para que genere un FAR PTR
cuando la dirección de destino se encuentra en el mismo
segmento, pues de lo contrario es lo suficientemente “astuto”
como para darse cuenta de que en ese caso basta con una
bifurcación cercana y por consiguiente no generarla lejana.</p>
<p class="calibre5">En el caso de los formatos corto y cercano, cuando se
produce la bifurcación se reemplaza el IP por el nuevo valor
obtenido sumando la dirección relativa al IP. En el caso del
formato lejano, en la misma instrucción aparecen nuevos valores para el segmento CS y para el IP (o sea el desplazamiento
con respecto al nuevo CS).</p>
<p class="calibre5"><strong class="calibre4">19.2. CALL cercanas y lejanas</strong></p>
<p class="calibre5">La instrucción CALL también cuenta con formatos cercano y
lejano, pero carece del formato corto.</p>
<p class="calibre5">Si no se lo indica explícitamente, el Ensamblador compaginará CALL en formato cercano. Para obtener el formato lejano
se puede prefijar el operando con FAR PTR, pero lo habitual y
más conveniente es dejar que el Ensamblador decida qué
formato usar basado en que el procedimiento llamado sea
cercano o lejano.</p>
<p class="calibre5">En oportunidad de la descripción de las subrutinas se vio
que el CALL cercano guarda en la Pila el IP, mientras que el
CALL lejano guarda en la Pila el CS y el IP, en ese orden. La
instrucción RET correspondiente debe tomar de la pila el IP
si la instrucción CALL fue cercana y el IP y el CS, en ese
orden, si CALL fue lejana. El Ensamblador determina qué tipo
de instrucciones CALL y RET debe generar en base al operando
de la directiva PROC.</p>
<p class="calibre5"><strong class="calibre4">19.3. Formato especial de RET</strong></p>
<p class="calibre5">La instrucción RET (Return, retornar) tiene un formato especial, RET n, donde n es el número de bytes adicionales que se
liberarán de la Pila tras la ejecución. Esta cantidad de
bytes es adicional a los 2 de IP (RET cercano) o 4 de IP y CS
(RET lejano) que se liberan al efectuar POP de la dirección
de retorno, y corresponde a los parámetros pasados a la subrutina. Por ejemplo, si la llamada fue:</p>
<pre class="literal-block">
|           push   Dato1
|           push   Dato2
|           call   Rutina
</pre>
<p class="calibre5">entonces la subrutina podría retornar con:</p>
<pre class="literal-block">
|           ret   4
</pre>
<p class="calibre5">o el programa llamador podría ejecutar después de CALL:</p>
<pre class="literal-block">
|           add   sp, 4
</pre>
<p class="calibre5">Esta es una excepción al consejo que oportunamente dimos de
no modificar directamente SP sino dejar que lo hagan las
instrucciones PUSH y POP.</p>
<p class="calibre5">19.4. Bifurcaciones y CALL indirectas</p>
<p class="calibre5">Además de los formatos ya vistos de las instrucciones JMP y
CALL, existen otros que se denominan indirectos. En primer
lugar, veamos el formato cercano con registro:</p>
<pre class="literal-block">
|           jmp   ax
|           call   si
</pre>
<p class="calibre5">En este formato, el contenido del registro de propósito
general de 16 bits especificado reemplaza el valor del IP,
con lo cual se produce la bifurcación o la llamada al nuevo
valor del IP. Por supuesto, el registro debe haber sido
cargado previamente con un valor adecuado, por ejemplo así:</p>
<pre class="literal-block">
| ................................
| Ese:
|           cmp   dx, si
| ................................
|           mov   ax, OFFSET Ese
|           jmp   ax
| ................................
</pre>
<p class="calibre5">Otro formato posible para JMP y CALL consiste en un nuevo
valor para el IP guardado en una dirección en memoria; por lo
tanto, también se trata de un formato cercano:</p>
<pre class="literal-block">
|           .DATA
| Lugar    DW   OFFSET Ese            ; Puede omitirse OFFSET
|           .CODE
| ................................
| Ese:
|           add   si, 8
| ................................
|           jmp   Lugar
| ................................
|           call   Lugar
| ................................
|           mov   bx, OFFSET Lugar
|           jmp   WORD PTR [bx]        ; Puede omitirse WORD PTR
| ................................
</pre>
<p class="calibre5">Como se ve, en este formato es posible afectar la dirección
por registros base e índice; todas las variantes están
disponibles, por ejemplo:</p>
<pre class="literal-block">
|           jmp   Lugar + 2 [bx] [si]
|           jmp   4 [bp]   ; Usa SS
</pre>
<p class="calibre5">Finalmente, tenemos el formato lejano indirecto:</p>
<pre class="literal-block">
|           .DATA
| Despl1   DD   Ese
|           DD   Este
|           .CODE
| ................................
| Este:
|           cmp   ax, 9
| ................................
| Ese:
|           sub   si, si
| ................................
|           mov   di, OFFSET Despl1
|           jmp   DWORD PTR 2 [di]
| ................................
|           mov   bx, 0
|           mov   si, OFFSET Despl1
|           call   DWORD PTR [bx] [si]
| ................................
</pre>
<p class="calibre5">DWORD PTR indica que la dirección está en una doble palabra,
con IP precediendo a CS. La palabra en la dirección especificada reemplaza el valor de IP, y la palabra siguiente hace lo
mismo con CS.</p>
<p class="calibre5"><strong class="calibre4">19.5. Tablas de saltos</strong></p>
<p class="calibre5">La principal utilidad de las formas indirectas de JMP y CALL
es la siguiente: supongamos que en un programa debemos
decidir qué camino seguir de acuerdo con un valor almacenado
en un registro; los valores posibles son varios. Podremos
buscar en una tabla un valor igual al dado; cada elemento de
la tabla tendrá asociada una dirección de bifurcación o de
llamada, la que será usada en una instrucción JMP o CALL con
estos formatos indirectos. Estas tablas se conocen como
“tablas de saltos” (“jump tables”). Un ejemplo más completo
aclarará el tema:</p>
<pre class="literal-block">
|           .DATA
| Tabla    DB   61
|           DW   Lugar1
|           DB   37
|           DW   Lugar2
|           DB   42
|           DW   Lugar3
| Resto    DB   ?
|           DW   Otra
|           .CODE
| ................................
|           mov   al, Resto           ; Cargar argumento
|           mov   si, OFFSET Tabla
| Repetir:
|           cmp   al, [si]            ; Buscar
|           je    Encontro
|           add   si, 3               ; Ir al próximo
|           jmp   Repetir
| Encontro:
|           jmp   1 [si]              ; Ir a dirección indirecta
| Lugar1:
| ................................
| Lugar2:
| ................................
| Lugar3:
| ................................
| Otra:
| ................................
</pre>
<p class="pcalibre1 pri1">El argumento de búsqueda original se halla en Resto. Hemos
usado una técnica ya explicada, consistente en poner un
“centinela”, de manera de evitar la pregunta de terminación
de la tabla, ya que de esta forma siempre se encontrará un
argumento igual al suministrado.</p>
<p class="calibre5">19.6. Cargar apuntador completo</p>
<p class="calibre5">Las instrucciones JMP y CALL que usan un FAR PTR cargan
simultáneamente dos registros, uno de ellos de segmento: el
IP y el CS. Veremos ahora un par de instrucciones que también
cargan simultáneamente dos registros, uno de ellos de
segmento.</p>
<p class="calibre5">Estas instrucciones se usan especialmente al tomar parámetros desde ciertas rutinas del sistema, que por ejemplo
requieren que se les pase en la Pila una dirección en formato
Segmento:Desplazamiento.</p>
<p class="calibre5">La instrucción LDS (Load Register and DS, cargar registro
y DS) carga el contenido de una palabra en un registro de
propósito general de 16 bits, y el contenido de la palabra
siguiente en DS. La instrucción LES (Load Register and ES,
cargar registro y ES) carga el contenido de una palabra en un
registro de propósito general de 16 bits, y el contenido de
la palabra siguiente en ES.</p>
<p class="calibre5">Normalmente, lo que habrá en la dirección señalada por el
segundo operando de LDS o LES es lo que se llama un apuntador
completo (full pointer), es decir, una dirección de memoria
en el formato Segmento:Desplazamiento. El primer operando es
el registro de propósito general de 16 bits que se cargará
con el desplazamiento. Veamos un ejemplo:</p>
<pre class="literal-block">
|           .DATA
| Apunta   DD   Lugar
|           .CODE
| ................................
|           mov   si, OFFSET Apunta
|           lds   bx, [si]
| ................................
|           les   ax, Apunta
| ................................
| Lugar:
|           mov   cx, si
| ................................
</pre>
<p class="calibre5">Especialmente en el caso de LDS es necesario tener en cuenta
de que, luego de ejecutarse la instrucción, el segmento de
datos que se direccionaba previamente no estará ya disponible, y que muy probablemente un acceso al mismo provoque
eventos no deseados. Por ejemplo, luego de lds bx, [si] el
registro SI (u otro) no apuntará al mismo lugar que antes,
aunque conserve su valor, porque el contenido de DS cambió.</p>
<p class="pcalibre1 pri1"><strong class="calibre4">19.7. Contrarrestación de segmentos (segment override)</strong></p>
<p class="calibre5">La mayoría de las instrucciones usa el registro de segmento
DS para direccionar la memoria, como se ha visto. Hay algunos
casos en que esto no ocurre:</p>
<p class="calibre5">A) Instrucciones de bifurcación incondicional y de llamada</p>
<p class="calibre5">Estas instrucciones usan el registro CS para direccionar
la memoria dentro del segmento de código. El ejemplo típico
es:</p>
<pre class="literal-block">
|           jmp   Lugar
| ................................
| Lugar:
| ................................
</pre>
<p class="calibre5">Cuando la bifurcación o llamada es indirecta, usa dos registros de segmento. Por ejemplo:</p>
<pre class="literal-block">
|           .DATA
| Salto    DW   Lugar
|           .CODE
| ................................
|           jmp   Salto
| ................................
| Lugar:
| ................................
</pre>
<p class="calibre5">JMP usa el registro DS para direccionar la palabra rotulada
Salto; en una segunda instancia usa el registro de segmento
CS para direccionar Lugar.</p>
<p class="calibre5">B) Instrucciones de bifurcación condicional (JE, JB, etc.)</p>
<p class="calibre5">El operando de estas instrucciones siempre usa el registro
de segmento CS para saltar.</p>
<p class="calibre5">C) Algunas instrucciones de cadena</p>
<p class="calibre5">Como vimos, algunas de las instrucciones de cadena usan el
registro de segmento ES para uno de sus operandos implícitos.</p>
<p class="calibre5">D) Instrucciones que usan el registro base BP.</p>
<p class="calibre5">Las instrucciones que usan el registro base BP no emplean
el registro de segmento DS sino el SS.</p>
<p class="calibre5">Es posible cambiar el registro de segmento que usan las
instrucciones, pero no en todos los casos. Para ello se
proveen prefijos de contrarrestación de segmento (segment
override). Estos prefijos, en lenguaje Ensamblador, se
anteponen al operando que afectan:</p>
<pre class="literal-block">
|           mov   al, CS:[bx]
</pre>
<p class="calibre5">En el caso del ejemplo, se tomará el contenido del byte
direccionado por CS:BX y se copiará al registro AL.</p>
<p class="calibre5">Es posible usar cualquiera de los prefijos CS:, DS:, ES: o
SS:, insertándolos delante del operando.</p>
<p class="calibre5">El Ensamblador traduce la instrucción a lenguaje de máquina insertando el prefijo, que consta de un byte, no delante
del operando sino delante de toda la instrucción. Esto es
posible porque las instrucciones (en general) tienen como
máximo un operando que direcciona la memoria.</p>
<p class="calibre5">Un prefijo de contrarrestación de segmento, como cualquier
otro prefijo, sólo afecta a la instrucción que lo sigue. Se
puede usar más de un prefijo para una misma instrucción (por
ejemplo combinando CS:, REP y LOCK), pero en general debe
evitarse esta práctica, pues se presentarán problemas si la
instrucción es interrumpida.</p>
<p class="calibre5">Hay instrucciones que no tienen operandos explícitos y sin
embargo direccionan la memoria. Un caso es la instrucción
XLATB; otros casos son las instrucciones de cadena (MOVSB,
etc.). Para prefijarlas puede recurrirse a uno de estos
arbitrios:</p>
<p class="calibre5">A) Se le agrega a la instrucción (en lenguaje ensamblador) un operando ficticio, al cual se le antepone el prefijo, y se modifica el código de operación por razones sintácticas. Por ejemplo:</p>
<pre class="literal-block">
|           xlat   ES:Tabla
</pre>
<p class="calibre5">B) Antes de la instrucción se inserta otra que es sólo un prefijo. Estas instrucciones - prefijo son: SEGCS, SEGDS, SEGES y SEGSS. Por ejemplo:</p>
<pre class="literal-block">
|           segss
|           lodsb
</pre>
<p class="calibre5">Esta variante puede usarse también con instrucciones que
tengan operandos.</p>
<p class="calibre5">Hay casos en los que estos prefijos de contrarrestación de
segmento no tienen efecto. Ellos son:</p>
<p class="calibre5">A) Direcciones de bifurcación y de llamada</p>
<p class="calibre5">Aunque se le antepongan estos prefijos a las instrucciones
JMP, CALL, JE, JA, etc., la dirección de bifurcación o de
llamada será siempre relativa al registro de segmento CS.</p>
<p class="calibre5">Nótese que esto no significa que los prefijos carezcan
absolutamente de acción en estos casos. En efecto, con los
formatos indirectos de bifurcación y llamada, JMP y CALL
toman datos desde áreas direccionadas por DS. Es posible
reemplazar DS por CS, ES o SS prefijando estas instrucciones.
Veremos un ejemplo de tal uso en un ejercicio un poco más
adelante.</p>
<p class="calibre5">B) Segmento extra (ES) en instrucciones de cadena</p>
<p class="calibre5">Este segmento no puede ser alterado por un prefijo, pero
sí el segmento DS que usan por defecto en otros casos las
instrucciones de cadena. Mientras que:</p>
<pre class="literal-block">
|           segss
|           lodsb
</pre>
<p class="calibre5">cargará el registro AL desde SS:SI sin ningún problema, en
cambio:</p>
<pre class="literal-block">
|           segss
|           stosb
</pre>
<p class="calibre5">no afectará a STOSB, que seguirá guardando el registro AL en
ES:DI.</p>
<p class="calibre5">C) Accesos a la Pila por medio de PUSH y POP</p>
<p class="calibre5">El uso de SS por PUSH, PUSHF, POP y POPF, así como por
CALL, RET e IRET, no es alterado por un prefijo de contrarrestación de segmento:</p>
<pre class="literal-block">
|           segcs
|           push   ax
</pre>
<p class="calibre5">no afectará la operación de PUSH, que seguirá guardando AX en
SS:SP - 2.</p>
<p class="calibre5">Nótese sin embargo que el prefijo puede afectar a PUSH de
otra manera, por ejemplo:</p>
<pre class="literal-block">
|           segcs
|           push   [si]
</pre>
<p class="calibre5">En este caso, PUSH pondrá en SS:SP - 2 el contenido de la
palabra en CS:SI en vez de DS:SI.</p>
<p class="calibre5">En muchos casos, el Ensamblador inserta automáticamente
prefijos de contrarrestación de segmento. Por ejemplo:</p>
<pre class="literal-block">
| Lugar:
|           mov   al, BYTE PTR Lugar
</pre>
<p class="calibre5">equivale a:</p>
<pre class="literal-block">
| Lugar:
|           mov   al, CS:BYTE PTR Lugar
</pre>
<p class="calibre5"><strong class="calibre4">19.8. Datos dentro del código</strong></p>
<p class="calibre5">Como ejemplo de uso de la contrarrestación de segmentos,
veremos el empleo de datos dentro del código.</p>
<p class="calibre5">Muchas veces es necesario tener áreas de datos dentro de
una subrutina, para facilitar su traspaso de un programa a
otro. Como el segmento de datos suele pertenecer al programa
principal y la subrutina está dentro del segmento de código,
esto presentaría problemas. Una solución consiste en definir
un segmento de datos dentro de la propia subrutina, pero esto
requiere inicializarlo (preservar el registro DS, cargarlo
con un nuevo valor, restaurarlo), y además desperdicia algún
espacio. Una solución mejor se logra utilizando la contrarrestación de segmentos.</p>
<p class="calibre5">Veamos entonces una subrutina que acepta un código en el
registro AL y da como resultado una palabra en AX, tomada de
una tabla de 256 elementos, ya que los posibles valores en AL
son todos los 256.</p>
<pre class="literal-block">
| ; Subrutina que toma un argumento en AL y da un resultado
| ;  en AX
| Busca    PROC  near
|           push  bx                  ; Salvar registro
|           sub   ah, ah              ; Borrar parte superior
|           shl   ax, 1               ; Multiplicar por 2
|           mov   bx, ax              ; Pasarlo al índice
|           mov   ax, CS:Tabla [bx]   ; Tomar resultado
|           pop   bx                  ; Restaurar registro
|           ret                       ; Retornar
| Tabla    DW   2345, 6754, 19567, 341, ...   ; 256 valores
| Busca    ENDP
</pre>
<p class="calibre5">En los textos veremos a menudo que un área de datos como la
presente se halla al comienzo de la subrutina, y se la saltea
por medio de JMP. Esto se debe a que muchos ensambladores
antiguos tenían dificultades para referirse a rótulos que se
definieran después de la referencia. Pero con los ensambladores modernos este problema no existe, y ello permite ahorrar
el JMP.</p>
<p class="calibre5">En casos como el presente, el prefijo CS: no es necesario,
pues el Ensamblador lo genera automáticamente.</p>
<p class="calibre5">Es necesario tener cuidado si se pretende que el programa
modifique una de sus propias instrucciones. En efecto, muchos
procesadores modernos (80386, 80486, Pentium) presentan lo
que se llama “cola de pre-fetch”, que puede tener diversas
longitudes según el procesador y las instrucciones. Esto significa que varias instrucciones son interpretadas y decodificadas antes de que el IP llegue a ellas. Si en tales circunstancias se modifica una instrucción próxima a ejecutarse, es
posible que se ejecute su versión anterior a la modificación
si la instrucción ya ha sido preprocesada, con lo que los
resultados no serán los esperados. Para evitar este problema,
se debe insertar un salto (JMP) a la ubicación siguiente
luego de modificar la instrucción; esto no será necesario si
entre la instrucción que modifica y la modificada ya se
ejecuta un JMP, CALL, INT o RET. Los JMP, CALL, INT y RET
vacían la cola de pre-fetch. Debido a este problema, ciertos
programas que funcionan perfectamente en una 8086, 80286 o
80386 dejan de funcionar cuando se los ejecuta en una 80486 o
una Pentium, por ejemplo.</p>
<p class="calibre5"><strong class="calibre4">19.9. Ejercicio nº 28</strong></p>
<p class="calibre5">Se trata de escribir una subrutina que reciba un código desde
10 hasta 99 en el registro AL, y ejecute partes de código
dentro de la subrutina que comienzan en lugares rotulados
R10, R11, etc. Si el código en AL estuviera fuera del rango
10 - 99, se deberá ir a un rótulo Otro. Se usará una tabla
que sólo contenga desplazamientos (2 bytes), sin los códigos.
Véase una posible solución en el Apéndice A.</p>
<p class="pcalibre1 pri1"><strong class="calibre4">20. Directivas de segmento</strong></p>
<p class="calibre5"><strong class="calibre4">20.1. Directivas de segmento simplificadas</strong></p>
<p class="calibre5">Hasta ahora, nuestros programas comenzaban con algo similar a:</p>
<pre class="literal-block">
|           .MODEL   small
|           .STACK   100h
|           .DATA
| ................................
|           .CODE
</pre>
<p class="calibre5">Éstas son las llamadas directivas de segmento simplificadas.
Los ensambladores modernos las aceptan, pero originalmente
estas directivas no existían, sino que se usaban las que
llamaremos directivas de segmento tradicionales o estándar.
Las directivas simplificadas sirven para la mayoría de los
programas, pero hay ocasiones en las que es necesario recurrir a las directivas estándar.</p>
<p class="calibre5">Antes de explicar las directivas estándar, veremos algo
más sobre la directiva simplificada .MODEL.</p>
<p class="calibre5">Esta directiva indica al Ensamblador cuál será el empleo
que harán de la memoria los distintos segmentos (de código,
de datos y la Pila). Además de small, es posible seleccionar
otros “modelos” de uso de memoria. Veámoslos:</p>
<p class="calibre5">Tiny (pequeñísimo): En este modelo, el código, los datos y
la Pila deben entrar en un único segmento (64K).</p>
<p class="calibre5">Small (pequeño): El código ocupa un segmento, y los datos
y la Pila otro.</p>
<p class="calibre5">Compact (compacto): El código ocupa un segmento, pero los
datos pueden ocupar tantos segmentos como sea necesario. La
Pila ocupa un segmento por sí misma.</p>
<p class="calibre5">Medium (mediano): El código puede ocupar varios segmentos,
pero los datos y la Pila ocupan un solo segmento.</p>
<p class="calibre5">Large (grande): El código puede ocupar varios segmentos, y
los datos y la Pila por su parte también.</p>
<p class="calibre5">Huge (enorme): Este modelo es similar al anterior, con la
diferencia de que es posible que una matriz ocupe más de un
segmento por sí sola.</p>
<p class="calibre5">Cuando el código ocupa un único segmento, todas las llamadas (CALL) y retornos (RET) pueden ser de tipo near (cercano); por supuesto, se admite también el tipo far (lejano),
pero no es necesario. Cuando el código ocupa más de un
segmento, algunas de las llamadas y retornos serán por fuerza
lejanos, lo que no es tan eficiente en tiempo y en espacio.</p>
<p class="calibre5">Cuando los datos ocupan un solo segmento, pueden ser
direccionados por medio de apuntadores cercanos, es decir,
usando sólo los desplazamientos; por supuesto, también es
posible direccionarlos con segmento y desplazamiento, pero
ello no es necesario. Cuando los datos ocupan más de un
segmento, algunos de ellos deberán ser direccionados por
medio de un segmento y un desplazamiento, lo que no es tan
eficiente en tiempo y en espacio.</p>
<p class="calibre5"><strong class="calibre4">20.2. Directivas de segmento estándar</strong></p>
<p class="calibre5">La principal directiva de segmento estándar es SEGMENT. Esta
directiva indica el comienzo de un segmento, donde se definirán áreas de trabajo y constantes (datos), código, o zonas
para la Pila. Tras estas definiciones se cerrará el segmento
con la directiva ENDS. Veamos un ejemplo:</p>
<pre class="literal-block">
| Datos    SEGMENT WORD PUBLIC 'Dato1'
| Palabra  DW   ?
| Caract   DB   ?
| Datos    ENDS
</pre>
<p class="calibre5">La sintaxis de la directiva SEGMENT es la siguiente:</p>
<pre class="literal-block">
| Nombre   SEGMENT [alineación] [combinación] ['clase']
</pre>
<p class="calibre5">Los elementos entre corchetes son optativos. La
descripción de las partes es la siguiente:</p>
<p class="calibre5">Nombre: Identifica el segmento. Si ya se ha definido un
segmento con el mismo nombre, el presente es continuación del
mismo. Este Nombre debe aplicarse también a la directiva ENDS
que cierra el segmento, y puede usarse en operandos de instrucciones y de otras directivas, permitiendo dar valor
inicial a un registro de segmento.</p>
<p class="calibre5">Alineación: Especifica que la dirección de memoria donde
comienza el segmento debe ser divisible por determinada
potencia de 2, es decir, debe estar alineada con determinada
agrupación de bytes. Las opciones son: BYTE, que significa
que se use la próxima dirección disponible, o sea que no se
precisa alineación específica; WORD, que indica que se use la
próxima dirección divisible por 2, o sea que se alinee a
palabra; DWORD, ídem divisible por 4, o sea alineado a doble
palabra; PARA, ídem divisible por 16, o sea alineado a
párrafo (es la opción que se toma por defecto); y PAGE, ídem
divisible por 256, o sea alineado a página.</p>
<p class="calibre5">Combinación: Especifica cómo se combinarán y ubicarán los
segmentos del mismo nombre presentes en diferentes módulos
objetos por medio del programa LINK. Las opciones son: AT
expresión, que ubica el segmento en la dirección absoluta de
párrafo indicada por la expresión; no se genera código ni
datos para estos segmentos; se usa esta opción para direccionar ubicaciones fijas de la memoria tales como el área de
datos de BIOS o el área de la pantalla; por ejemplo, para
direccionar un segmento a 0400h, se usará AT 40h. COMMON, que
hace que los segmentos que tengan el mismo nombre compartan
una misma ubicación de memoria; la longitud del segmento
resultante es la del segmento más largo con el mismo nombre.
MEMORY o PUBLIC, que son equivalentes y concatenan los segmentos con el mismo nombre formando un único segmento contiguo. PRIVATE, que asigna al segmento una dirección propia sin
combinarlo con otros segmentos (opción por defecto). STACK,
que concatena los segmentos con el mismo nombre formando un
único segmento contiguo, y en el momento de la carga inicializa SS al comienzo de este segmento y SP a la longitud del
segmento.</p>
<p class="calibre5">Clase: Es una designación que controla el ordenamiento de
los segmentos cuando se ejecuta LINK. Los segmentos de la
misma clase se cargan contiguos en la memoria, independientemente del orden en que aparezcan en el archivo fuente.</p>
<p class="calibre5">La directiva GROUP (grupo) se usa para combinar dos o más
segmentos en una entidad lógica que ocupa como máximo 64K. De
tal manera, el direccionamiento de los segmentos puede efectuarse en forma relativa a un solo registro de segmento.
Veamos un ejemplo:</p>
<pre class="literal-block">
| ................................
| Grupo    GROUP   Dato1, Dato2
| ................................
| Dato1    SEGMENT PARA PUBLIC 'Datos'
| Palabra1 DW   ?
| ................................
| Dato1    ENDS
| Dato2    SEGMENT PARA PUBLIC 'Datos'
| Palabra2 DW   ?
| ................................
| Dato2    ENDS
| Codigo   SEGMENT PARA PUBLIC 'Cod'
| Comienzo:
|           ASSUME CS:Codigo
|           mov    ax, Grupo           ; Inicializar segmento
|           mov    ds, ax
|           ASSUME DS:Grupo
|           mov    ax, Palabra1
|           mov    Palabra2, ax
| ................................
| Codigo   ENDS
|           END    Comienzo
</pre>
<p class="calibre5">La directiva GROUP se usa sobre todo cuando los programas en
Ensamblador se combinan con programas en algún lenguaje de
alto nivel. Permite direccionar varios segmentos en forma
relativa a un único registro de segmento.</p>
<p class="calibre5">La directiva ASSUME (suponer) indica las direcciones a las
que debe suponerse que apuntan los registros de segmento.
Esto no es lo mismo que cargarlos, sino que se trata de una
indicación al Ensamblador para que calcule correctamente los
desplazamientos de los operandos.</p>
<p class="calibre5">En el ejemplo anterior vimos que sólo después de cargar el
registro DS con el valor del segmento podemos indicarle al
Ensamblador que suponga que DS contiene ese valor, a efectos
de calcular el desplazamiento de los operandos. En el caso
presente podíamos haber insertado el ASSUME DS dos instrucciones antes, pues las mismas no usan operandos de memoria.
En cuanto al ASSUME CS, no hace falta cargar el CS, pues lo
hace el Sistema Operativo al ceder control a nuestro programa
en el rótulo Comienzo. Asimismo, los registros SS y SP son
cargados por el Sistema Operativo antes de pasar control a
nuestro programa.</p>
<p class="calibre5">Obsérvese que, si usamos la directiva ASSUME DS:Operando y
cargamos DS con un valor que no es el de Operando, el Ensamblador no notará la discrepancia y generará desplazamientos,
pero los mismos tendrán valores incorrectos y el programa
fallará en la ejecución. Por ejemplo:</p>
<pre class="literal-block">
| Datos    SEGMENT WORD 'Dato'
| Palabra  DW   50
| ................................
| Datos    ENDS
| Datos1   SEGMENT WORD 'Dato'
| Otra     DW   40
| ................................
| Datos1   ENDS
| Codigo   SEGMENT BYTE 'Code'
|           ASSUME CS:Codigo
| Comienzo:
|           mov    ax, Datos
|           mov    ds, ax
|           ASSUME DS:Datos1           ; Incorrecto
|           mov    ax, Otra
| ................................
| Codigo   ENDS
|           END    Comienzo
</pre>
<p class="calibre5">En este ejemplo, el desplazamiento que el Ensamblador calculará para la instrucción mov ax, Otra será 0, pero con
respecto a Datos1; como DS se cargó con el valor de Datos, la
instrucción moverá el contenido de Palabra al registro AX,
pues Palabra tiene desplazamiento 0 con respecto a Datos.</p>
</div>
<div class="line" id="soluciones">
<h2 class="indiceautor">SOLUCIONES</h2>
<p class="calibre5"><strong class="calibre4">Ejercicio nº 28</strong></p>
<pre class="literal-block">
| ; Subrutina que toma 4 dígitos BCD sin empaquetar en DX:AX
| ;  y los convierte a binario en AX
| ; Entrada:     DX: 2 dígitos BCD de orden alto
| ;              AX: 2 dígitos BCD de orden bajo
| ; Resultado:   AX: Equivalente binario
| ;              DX: Queda en 0
| ; Error:       CF = 1 si alguno de los dígitos no es válido
| Conv4bin PROC  near
|           cmp   dh, 9               ; Ver si dígitos válidos
|           ja    Mal
|           cmp   dl, 9
|           ja    Mal
|           cmp   ah, 9
|           ja    Mal
|           cmp   al, 9
|           ja    Mal
|           push  cx                   ; Salvar registro
|           aad                        ; Parte baja a binario
|           mov   cx, ax               ; Salvarla
|           mov   ax, dx               ; Tomar parte alta
|           aad                        ; Parte alta a binario
|           mov   ah, 100              ; Parte alta por 100
|           mul   ah
|           add   ax, cx               ; Sumarle parte baja
|           xor   dx, dx               ; Pone DX = 0 y CF = 0
|           pop   cx                   ; Restaurar registro
|           ret                        ; Retornar
| Mal:
|           stc                        ; Marcar error con CF = 1
|           ret                        ; Retornar
| Conv4bin ENDP
</pre>
<p class="calibre5">Como se ve, es posible que una subrutina tenga más de una
instrucción de retorno. Algunos consideran que esto es poco
“elegante”. Es fácil modificar esta subrutina para que tenga
una sola instrucción de retorno.</p>
<p class="pcalibre1 pri1">En la próxima entrega de este manual:</p>
<ul class="calibre2">
<li class="calibre3">Sección 21: INTERFAZ CON OTROS LENGUAJES</li>
<li class="calibre3">Sección 22: MACROINSTRUCCIONES Y OTRAS FACILIDADES</li>
</ul>
</div>
</div>

</div>

</body>
</html>
