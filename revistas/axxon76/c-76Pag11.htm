<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 76 - SECCIÓN: - INFO Córtex</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">INFO Córtex</h1>
<p class="calibre5"><b class="calibre4">Eduardo J. Carletti</b></p><p class="calibre5"></p>
<div class="document">
<!-- # :maxLineLen=120:folding=explicit:mode=rest:wrap=soft:collapseFolds=1:encoding=windows-1252: -->
<p class="calibre5">Las fuentes de información de este revista son las propias y además:</p>
<pre class="literal-block">
AMB : Ambito Financiero
ANA : Analog
ASI : Asimov's
AXX : Fuentes propias
BEM : BEM
CCO : Cronista Comercial
CGA : Computer Graphics and Applications
CGW : Computer Graphics World
CLA : Clarín
CUA : Cuasar
FAN : Fandom
FSF : Fantasy &amp; Science Fiction
INT : Internet
INZ : Interzone
LAN : La Nación
LAP : La Prensa
LOC : Locus
MEX : Corresponsal en México
P12 : Página 12
POR : Pórtico
SF  : Revista SF
SFA : Science Fiction Age
SFC : Science Fiction Chronicle
STA : Starlog
USA : Corresponsal en EE.UU.
WIR : Wired
</pre>
<p class="calibre5">Se agradecerá cualquier corrección, información nueva o el envío de publicaciociones para reseña. Envíe a: Axxón, Anchorena 1517 (1714) Ituzaingó (ARGENTINA)
TE/FAX  (01) 624-9267 - Internet: <a href="mailto:eduardo.carletti%40newage.net">eduardo<span>.</span>carletti<span>@</span>newage<span>.</span>net</a></p>
<p class="pri2"><em class="calibre9">Ed Wood</em>, USA, 1994. Dirección: Tim Burton. Guión: Scott
Alexander y Larry Karaszewski. Fotografía: Stephan Czapsky.
Música: Howard Shore. Elenco: Jonnhy Deep, Martin Landau,
Sarah Jessica Parquer, Patricia Arquette, Jeffrey Jones, Bill
Murray. Duración: 124 minutos. Comedia.</p>
<p class="calibre5">Esta película es un feliz encuentro entre un director, un
personaje único y un relato hecho a la medida de los dos. Es
la historia del que muchos consideran el realizador más malo
de la historia de Hollywood, un hombre que filmó casi cualquier cosa —y bajo casi cualquier regla— empujado por su
entusiasmo y el deseo de hacer.</p>
<p class="pri5">La Revista Virtual de Informática que se esconde dentro de la panza de Axxón es el último reducto de resistencia de los informáticos inteligentes</p>
<div class="line" id="revista-virtual-de-informatica">
<h2 class="indiceautor">REVISTA VIRTUAL DE INFORMATICA</h2>
<p class="calibre5">Alejandro Alonso y Ricardo M. Forno - 1996</p>
<div class="line" id="ya-no-sos-mi-p6-ahora-te-dicen-pentium-pro">
<h3 class="calibre21">YA NO SOS MI P6, AHORA TE DICEN PENTIUM PRO</h3>
<p class="calibre5">(por A. Alonso)</p>
<p class="calibre5">A principios de noviembre, Intel presentó en Argentina, casi
en simultáneo con los Estados Unidos, al microprocesador
<em class="calibre9">Pentium Pro</em>, sucesor del controvertido Pentium. Con este micro, <em class="calibre9">la compañía pretende romper algunos espacios del mercado</em> que antes estaban ocupados por grandes equipos propietarios RISC de Sun, Digital, Silicon Graphics y Hewlett
Packard. Estos campos son la computación técnica y científica, las estaciones gráficas de trabajo, las aplicaciones
de misión crítica, los servidores de alta performance y
capacidad, y la multimedia.</p>
<p class="calibre5">Debutando con velocidades que van desde los <em class="calibre9">150 a los 200</em>
<em class="calibre9">MHz</em>, el Pentium Pro incorpora importantes ventajas en cuanto
al procesamiento de programas de 32 bits (como los que corren sobre Unix, Windows NT y OS/2) e integra en el mismo
encapsulado entre 256 y 512 KB de memoria caché adicional,
lo que favorece su performance.</p>
<p class="calibre5">De acuerdo a la revista PC Magazine Argentina (artículo
de Sebastian Rupley y John Clyman del vol. 6 nº 11), para
aprovechar el máximo rendimiento de los equipos Pentium Pro
se necesitará un auténtico sistema operativo de 32 bits,
como el Windows NT o el OS/2. <em class="calibre9">“Con aplicaciones de 32 bits</em>
<em class="calibre9">bajo Microsoft Windows 95, se espera que el P6 supere a un</em>
<em class="calibre9">Pentium veloz en tan sólo un 20 o 30 por ciento”</em>, aclaran
los autores de la nota. El hecho es que, con el Pentium Pro,
Intel ha hecho un auténtico corte en lo que a evolución se
refiere, y ese corte va en detrimento del pasado. Para Intel, ese pasado son las aplicaciones de 16 bits. Estos últimos programas correrán, pero no se espera que lo hagan con
mejor performance.</p>
<p class="calibre5">Una de las particularidades más notables del P6 es la de
permitir <em class="calibre9">superprocesamiento simultáneo</em>. Este procesamiento
implica, en primer lugar, la división de una instrucción en
micro-operaciones (similar al RISC), que pueden ser manipuladas desde circuitos separados en el hardware. Cuando una
instrucción completa una etapa pasa a la siguiente y la etapa anterior comienza a trabajar con la próxima. Esta cadena
puede extenderse a cinco, seis etapas o más. Otra de las
ventajas que incorpora el Pentium Pro es la <em class="calibre9">ejecución fuera</em>
<em class="calibre9">de orden</em>, a través de la cual el micro puede trabajar con
instrucciones no consecutivas. El objetivo de esta alternativa es aprovechar mejor los tiempos de proceso del micro
(que ahora puede buscar adelante en la secuencia de ejecución y permanecer menos tiempo ocioso), y evitar que el
sistema se empantane con algunas de las operaciones. Estas
características de eficiencia en programas de 32 bits pagan
su costo con la disminución de la performance en programas
de 16 bits, como lo son algunas de las aplicaciones más populares.</p>
<p class="calibre5">Intel da un interesante ejemplo sobre la ejecución fuera
de orden, considérese este fragmento de programa:</p>
<pre class="literal-block">
r1 &lt;= mem [r0]      /* Instruction 1 */
r2 &lt;= r1 + r2       /* Instruction 2 */
r5 &lt;= r5 + 1        /* Instruction 3 */
r6 &lt;= r6 - r3       /* Instruction 4 */
</pre>
<p class="calibre5">En este caso Pentium Pro sobrevuela su pool de instrucciones
en busca de la instrucción siguiente y se encuentra con que
la instrucción 2 no es inmediatamente ejecutable pues depende de la 1, entonces el procesador ejecutará <em class="calibre9">“especulativamente”</em> las instrucciones 3 y 4.</p>
<p class="calibre5">Otra cosa que hace único al P6 es su caché de 256 o 512K
de memoria L2 conectado directamente al chip del CPU. El caché primario (L1, con 8K para instrucciones y 8K para datos)
no es muy distinto del que tiene el Pentium, sin embargo su
caché secundario (L2), que forma parte del micro, mejora
dramáticamente su velocidad. Para comprender el porqué de
algunas de estas implementaciones, hay que entender que tanto el bus del P6 como el de su antecesor funcionan a una
fracción de la velocidad del reloj del CPU, lo que puede
llevar a penosos cuellos de botella.</p>
<p class="calibre5">Como detalle técnico el chip integra 5,5 millones de
transistores de tecnología GTL+. Intel abandonó el tradicional esquema TTL (Lógica Transistor-Transistor) por una extensión de Gunning Transceiver Logic que ofrece, entre otros
beneficios, inmunidad al ruido, independencia del voltaje de
alimentación, y menos problemas eléctricos a nivel de bus.
Además, ha cambiado la tecnología de construcción que, si
bien en el primer modelo (150 MHz) será de 0,6 micrones, en
modelos posteriores avanzará a 0,35 micrones.</p>
<p class="calibre5">Ciertamente, el lanzamiento del Pentium Pro no fue un hecho aislado. Al mismo tiempo, se presentó el nuevo conjunto
de chips que acompaña al procesador, y modelos especiales de
placa madre, que pueden aprovechar al máximo las cualidades
del P6.</p>
<p class="calibre5">En los últimos meses del ‘95, al menos dos compañías hicieron sus respectivos lanzamientos de equipos Pentium Pro
en Argentina. La primera, coincidiendo en fecha con la presentación local del chip, fue Vierci Computers-VTC con la
familia Katana Pro. Por su parte, Hewlett Packard lo hizo a
mediados de noviembre, con el modelo HP Vectra VT6.</p>
<p class="calibre5">No se prevé una inserción rápida en el mercado del P6,
pues el Pentium todavía está en su curva ascendente y el público está bastante atado a las aplicaciones de 16 bit. Sin
embargo, con el tiempo, la posibilidades del micro brillarán
con luz propia. (A.A. Fuentes: Intel, PC Magazine y otras)</p>
</div>
<div class="line" id="sun-patea-el-tablero">
<h3 class="calibre21">SUN PATEA EL TABLERO</h3>
<p class="calibre5">(por A. Alonso)</p>
<p class="calibre5">Resulta difícil predecir hasta dónde puede llegar el gigante
de la Internet en su intento por empujar la tecnología hasta
sus últimos límites, pero con <em class="calibre9">Ultracomputing</em>, Sun planea desplazar a Digital, HP y a Silicon Graphics, y ponerse a la
cabeza de los grandes equipos basados en RISC por venir.</p>
<p class="calibre5">Las nuevas estaciones Ultra (1 y 2) y los UltraServer 1
presentan importantes avances en materia de redes, computación visual y rendimiento. Tendrán desde el vamos tarjetas
Fast Ethernet de 10/100 megabits por segundo y Fast/Wide
SCSI-2 on board, o bien integrados en un único SunSwift. Además, los adaptadores SunATM 2.0 brindarán velocidades de
transmisión en modo asincrónico de 155 Mbps.</p>
<p class="calibre5">Desde el punto de vista técnico, la innovación viene básicamente desde dos puntas. La primera es la arquitectura Ultra
Port (UPA), eje del diseño de los sistemas Ultra. Se trata de
una interconexión conmutada, que permite grandes transferencias simultáneas de datos, llegando a 1,3 gigabytes por segundo (cientos de veces más veloz que sus competidores RISC y
otros sistemas basados en tecnología Intel). La otra punta,
la constituye el Set de Instrucciones Visuales (VIS), implementado directamente sobre el motherboard, que logra un notable aumento de la performance en todo lo que sea gráficos y
multimedia. A esto debe sumársele un “motor” de gráficos
avanzado, el Creator, que incorpora una novedosa tecnología
de manejo de memoria para las imágenes: la 3D-RAM desarrollada por Sun y Mitsubishi. Según la compañía, estas implementaciones hacen que una estación Ultra 1 supere a las más
caras estaciones gráficas de trabajo que presenta la competencia.</p>
<p class="calibre5">Los sistemas siguen siendo compatibles con Solaris (el
Unix propietario de Sun) y pueden correr una importantísima
gama de aplicativos de todo tipo, lenguajes de programación,
programas de red (incluyendo los de comunicación con Internet) y de creación de gráficos. (Fuente: Sun Microsystems)</p>
</div>
<div class="line" id="la-sociedad-en-la-red">
<h3 class="calibre21">LA SOCIEDAD EN LA RED</h3>
<p class="calibre5">(por A. Alonso)</p>
<p class="pri2">El fines del año pasado, en el Museo de Telecomunicaciones,
fue presentado el capítulo argentino de la Internet Society,
una organización mundial sin fines de lucro que tiene por
objetivo promover las actividades de la red en todos los
países. La sociedad agrupa a los usuarios -individuos y corporaciones- que integran la megared informática, para enriquecer cultural, política y socialmente su uso.</p>
<div class="pri">
<div class="line"><em class="calibre9">Internet Society</em></div>
<div class="line"><em class="calibre9">info@isoc.org.ar</em></div>
<div class="line"><em class="calibre9">http://www.isoc.org.ar</em></div>
<div class="line"><em class="calibre9">Tel./Fax: +54-1-703-8928.</em></div>
</div>
</div>
<div class="line" id="ibm-cambia-de-camiseta">
<h3 class="calibre21">IBM CAMBIA DE CAMISETA</h3>
<p class="calibre5">(por A. Alonso)</p>
<p class="calibre5">Sin hacer mucho ruido, IBM y Apple Computer decidieron romper
uno de sus joint ventures. La empresa Kaleida Labs fue disuelta a mediados de enero ‘96, después de haber creado un
lenguaje para desarrollo de software multimedia, el ScriptX,
del que ambas compañías sacarán provecho.</p>
<p class="calibre5">A partir de esta instancia, los analistas comienzan a preguntarse cuál será el futuro del Power PC. Si bien Apple los
está utilizando, IBM desarmó las unidades operativas que se
dedicaban a buscar una alternativa a las PC’s basadas en Intel.</p>
<p class="calibre5">Interrogantes similares se ciernen sobre Taligent, otro
joint venture orientado al desarrollo de tecnologías que permiten a los programas correr en conjunto, acelerando las velocidades de procesamiento. En esta última empresa participa
también Hewlett Packard.</p>
<p class="calibre5">Después de haber perdido varias batallas, entre las que se
destaca la caída de su OS/2 a manos del Windows de Microsoft,
los planes de IBM se han sido reenfocados hacia cinco aspectos:</p>
<ul class="calibre2">
<li class="calibre3">Aplicaciones de red. Estos negocios abarcan comercio electrónico, computación colaborativa, televisión interactiva y otros servicios temáticos. En este área compite con Oracle, Microsoft, AT&amp;T y Hewlett Packard.</li>
<li class="calibre3">Global Networking. Con conexiones de red en más de 100 países y 850 ciudades, IBM es una de las compañías más grandes en networking. Su red corporativa sirve a más de  25.000 usuarios. A estas consideraciones hay que sumar Prodigy (la red de IBM), las aplicaciones de Lotus Notes y el acceso a Internet. Aquí IBM rivaliza con AT&amp;T, MCI, EDS y British Telecom.</li>
<li class="calibre3">Internet. Ayuda a clientes y diseño de sites, es todavía un negocio pequeño, pero que crece continuamente. Sus rivales más fuertes en este entorno son Sun Microsystems y Digital Equipment, pero también pelean por un pedazo de la torta AT&amp;T y MCI.</li>
<li class="calibre3">Ventas a Industrias. El 80% de los negocios de IBM se realiza a través de sus 13 unidades específicas de ventas a industrias: servicios financieros, agencias de viajes, salud, servicios públicos y seguros, entre otras. Aquí compite con EDS y Andersen Consulting.</li>
<li class="calibre3">Servicios de Información. Una división que integra los servicios de tercerización (outsourcing) para grandes compañías.</li>
</ul>
<p class="calibre5">En la actualidad, IBM está concentrada en tomar por asalto el
mundo de las redes corporativas y de las grandes redes de
servicios on line. La cabeza visible de esa estrategia es su
máximo ejecutivo, Lou Gerstner, y el nombre que le ha dado
puede traducirse como <em class="calibre9">“Computación centrada en la red”</em>. Dentro de esa cosmovisión, el Lotus Notes y la red Prodigy, con
algo más de un millón de usuarios, juegan un papel muy importante.</p>
<p class="calibre5">Gerstner sostiene que cada diez años, ciertas empresas
tienen la oportunidad de redefinir el campo de juego en materia de computación, y que IBM está transitando esa fase. Para
él, en el futuro los usuarios compararán poder y aplicaciones
de la misma manera que hoy se compra la electricidad: “Ellos
podrán rentar servicios en base a un sistema de cobro por
uso, porque residirán en la red” (A.A. Fuente: Financial Times/El Cronista y Business Week).</p>
</div>
<div class="line" id="eleccion-por-computadora">
<h3 class="calibre21">ELECCION POR COMPUTADORA</h3>
<p class="calibre5">(por A. Alonso)</p>
<p class="calibre5">La idea de poder ver departamentos desde todos los puntos de
vista posibles a través de la computadora sedujo a varias inmoviliarias que necesitan vender sus pisos aun antes de ser
construido el edificio. Alto Palermo (subsidiaria de Pérez
Companc) enfrentó ese desafío, y para ello contrató a Proyectos Digitales del Río León, una pequeña empresa especializada
en servicios gráficos. La compañía dio forma a una animación
computada que pasea al cliente por el edificio y le muestra
su departamento virtual, copia del que todavía no se construyó, como si estuviera viajando en helicóptero (A.A.
Fuente: El Cronista).</p>
</div>
<div class="line" id="lenguaje-ensamblador-8086-8088-parte-3">
<h3 class="calibre21">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 3)</h3>
<p class="calibre5"><strong class="calibre4">Cómo adentrarse en el alma de la PC</strong></p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<p class="calibre5"><strong class="calibre4">8. Aritmética de precisión múltiple</strong></p>
<p class="calibre5"><strong class="calibre4">8.1. Instrucciones</strong></p>
<p class="calibre5">El procesador 8086 permite sumar o restar bytes o palabras.
En el caso de los bytes, los límites de valor para números
con signo son -128 y 127, y para números sin signo el límite
es 255. Para las palabras, estos límites son -32.768 y
32.767, y 65.535 respectivamente. ¿Qué puede hacerse para
sumar o restar valores mayores?</p>
<p class="calibre5">A este efecto se han provisto instrucciones de suma y de
resta con acarreo: ADC (Add with Carry) y SBB (Subtract with
Borrow). Estas instrucciones respectivamente suman o restan
dos operandos añadiendo el acarreo o pedido proveniente de
una operación anterior y almacenado en la bandera de acarreo
(CF) como un 0 o un 1. Los formatos son idénticos a los de
ADD o SUB.</p>
<p class="calibre5">Veamos cómo haríamos para sumar un valor almacenado en
Dato1 (alto orden) y Dato2 (bajo orden) a otro en Acum1 y
Acum2 respectivamente:</p>
<pre class="literal-block">
|            .DATA
|     Acum2   DW   ?
|     Acum1   DW   ?
|     Dato2   DW   ?
|     Dato1   DW   ?
|            .CODE
|     ................................
|            mov   ax, Dato2
|            add   Acum2, ax
|            mov   ax, Dato1
|            adc   Acum1, ax            ; Con acarreo
|     ................................
</pre>
<p class="calibre5">Recordemos que en la memoria están invertidos los bytes de
una palabra, y que por convención también deben invertirse
las palabras que forman una doble palabra. Es por eso que
hemos ordenado los acumuladores del ejemplo de esa manera, o
sea con su parte de orden bajo adelante.</p>
<p class="calibre5">El Ensamblador también usa ese orden cuando se define una
doble palabra con la directiva DD. El último ejemplo quedaría
así usando DD y dando valores a los datos:</p>
<pre class="literal-block">
|           .DATA
|     Acum   DD   12354096               ; Decimal
|     Dato   DD   2A3CDF1Bh              ; Hexadecimal
|           .CODE
|     ................................
|            mov   ax, WORD PTR Dato
|            add   WORD PTR Acum, ax
|            mov   ax, WORD PTR Dato + 2
|            adc   WORD PTR Acum + 2, ax   ; Con acarreo
|     ................................
</pre>
<p class="calibre5">Hemos definido un acumulador en decimal y otro en hexadecimal
para mostrar las diversas posibilidades.</p>
<p class="calibre5">La indicación WORD PTR es necesaria para que el Ensamblador no acuse un error, ya que el atributo de Acum y de Dato
es “doble palabra” y no “palabra”.</p>
<p class="calibre5">En cuanto a la resta, no hay diferencias importantes. El
último ejemplo quedaría así con la resta:</p>
<pre class="literal-block">
|           .DATA
|     Acum   DD   12354096                 ; Decimal
|     Dato   DD   2A3CDF1Bh                ; Hexadecimal
|           .CODE
|     ................................
|           mov   ax, WORD PTR Dato
|           sub   WORD PTR Acum, ax
|           mov   ax, WORD PTR Dato + 2
|           sbb   WORD PTR Acum + 2, ax   ; Con acarreo
|     ................................
</pre>
<p class="calibre5">En el caso de la suma y de la resta con operandos de múltiple
precisión, puede operarse con números con signo o sin signo.
Para determinar si hubo exceso con números con signo, se consultará el indicador de desborde OF al fin de toda la operación. Para números sin signo, en cambio, debe consultarse el
indicador de acarreo CF. Esto es lo mismo que se hace con las
operaciones de precisión simple.</p>
<p class="calibre5"><strong class="calibre4">8.2. Algunas técnicas</strong></p>
<p class="calibre5">Veremos a continuación una técnica útil para las sumas y
restas con acarreo.</p>
<p class="calibre5">Para sumar una constante de un byte o una palabra a una
doble palabra:</p>
<pre class="literal-block">
|           .DATA
|     Acum   DD   ?
|           .CODE
|     ................................
|           add   WORD PTR Acum, 5          ; Constante = 5
|           adc   WORD PTR Acum + 2, 0      ; Suma el CF
|     ................................
</pre>
<p class="calibre5">La suma de 0 tiene por objeto trasladar el acarreo. Con la
resta se procede de igual manera.</p>
<p class="calibre5">Es posible realizar esto mismo con una instrucción de
incremento, con mayor gasto de espacio y tiempo, por lo que
el fragmento que sigue sólo tiene interés didáctico:</p>
<pre class="literal-block">
|     ................................
|            add   WORD PTR Acum, 5         ; Constante = 5
|            jnc   Sigue                    ; Probar CF
|            inc   WORD PTR Acum + 2
|     Sigue:
|     ................................
</pre>
<p class="calibre5"><strong class="calibre4">9. Operaciones lógicas</strong></p>
<p class="calibre5">El procesador 8086 tiene un juego de operaciones llamadas
lógicas. De ellas hay una que toma un operando: NOT; y tres
que toman dos operandos: AND, OR y XOR. Primeramente veremos
las de dos operandos.</p>
<p class="calibre5">La operación se realiza sobre pares de bits correspondientes, dejando como de costumbre el resultado en el primer
operando. Los operandos pueden ser bytes o palabras, y los
formatos de estas instrucciones son similares a los de ADD.</p>
<p class="calibre5">Cada una de estas operaciones lógicas funciona de acuerdo
con las tablas que a continuación veremos.</p>
<p class="calibre5"><strong class="calibre4">9.1. Instrucción AND</strong></p>
<p class="calibre5">El nombre de esta operación lógica equivale en castellano a
la conjunción “y”. Si tomamos 1 = Verdadero y 0 = Falso, el
resultado señala la verdad o falsedad de unir dos aseveraciones con la conjunción “y”. La tabla correspondiente es:</p>
<pre class="literal-block">
|     AND | 0   1
|     -----------.
|      0  | 0   0
|         |
|      1  | 0   1
</pre>
<p class="calibre5">Es decir que el bit de resultado será 1 sólo cuando los bits
correspondientes de ambos operandos sean 1. Veamos un ejemplo:</p>
<pre class="literal-block">
|     mov   al, 00110111b
|     and   al, 01011011b
</pre>
<p class="calibre5">El resultado queda en AL y es 00010011.</p>
<p class="calibre5">Además de modificar el primer operando, la instrucción AND
afecta las banderas. Las banderas de desborde (OF) y de acarreo (CF) se ponen siempre en 0. Las banderas de signo (SF) y
de Cero (ZF) reflejan los posibles valores del resultado: si
el bit de orden alto es 1, SF = 1; y si el resultado tiene
todos sus bits en 0, será 0 y por lo tanto ZF = 1.</p>
<p class="calibre5">Esta instrucción tiene varios usos importantes, además de
los que pueda encontrar el programador:</p>
<ol class="upperalpha">
<li class="calibre3">Probar el contenido de un registro</li>
</ol>
<pre class="literal-block">
|     and   ax, ax
|     jz   Lugar
</pre>
<p class="calibre5">Como puede verse por la tabla, esto no modifica el contenido
del registro, pero pone SF y ZF de acuerdo con el valor contenido en el mismo. Una instrucción de bifurcación condicional prueba luego el bit adecuado.</p>
<ol class="upperalpha" start="2">
<li class="calibre3">Borrar bits a 0</li>
</ol>
<pre class="literal-block">
|     and   ah, 00100111b
</pre>
<p class="calibre5">Los bits del primer operando correspondientes a los del
segundo que estén en 0 serán a su vez puestos en 0. Los restantes no serán alterados.</p>
<p class="calibre5">Esto es útil para manejar ciertas operaciones de entrada y
de salida, donde diversas opciones y datos están codificados
como bits dentro de un byte o de una palabra.</p>
<ol class="upperalpha" start="3">
<li class="calibre3">Probar bits seleccionados</li>
</ol>
<pre class="literal-block">
|     and   cl, 00110001b
|     jnz   Lugar
</pre>
<p class="calibre5">Como antes, esta instrucción dejará en 0 los bits del primer
operando correspondientes a bits 0 del segundo. Los únicos
que quedarán con su valor anterior serán aquéllos que correspondan a bits 1 del segundo operando. Por lo tanto, una prueba de cero (JZ) o de no cero (JNZ) probará si son o no 0
todos los bits del primer operando seleccionados por bits 1
del segundo. Esta operación tiene el inconveniente de que
destruye el primer operando al probarlo; más adelante veremos
que existe una instrucción TEST que hace lo mismo sin modificar el operando. Esto también es útil para operaciones de
entrada y de salida.</p>
<p class="calibre5"><strong class="calibre4">9.2. Instrucción OR</strong></p>
<p class="calibre5">El nombre de esta operación lógica equivale en castellano a
la conjunción “o”. Si tomamos 1 = Verdadero y 0 = Falso, el
resultado señala la verdad o falsedad de unir dos aseveraciones con la conjunción “o”. La tabla correspondiente es:</p>
<pre class="literal-block">
|     OR | 0   1
|     ----------.
|      0 | 0   1
|        |
|      1 | 1   1
</pre>
<p class="calibre5">Es decir que el bit de resultado será 0 sólo cuando los bits
correspondientes de ambos operandos sean 0. Veamos un ejemplo:</p>
<pre class="literal-block">
|     mov   al, 00110111b
|     or   al, 01011011b
</pre>
<p class="calibre5">El resultado que queda en AL es 01111111.</p>
<p class="calibre5">Las banderas son afectadas por OR de la misma manera que
por AND.</p>
<p class="calibre5">Como AND, OR tiene varios usos:</p>
<p class="calibre5">A) Probar el contenido de un registro:</p>
<pre class="literal-block">
|     or   ax, ax
|     jz   Lugar
</pre>
<p class="calibre5">Aquí OR funciona de la misma manera que AND. Véase el
comentario correspondiente.</p>
<p class="calibre5">B) Forzar bits a 1:</p>
<pre class="literal-block">
|     or   al, 01000010b
</pre>
<p class="calibre5">Los bits del primer operando correspondientes a los del segundo que estén en 1 serán a su vez puestos en 1. Los restantes no serán alterados. Esto es útil para manejar ciertas
operaciones de entrada y salida, donde diversas opciones y
datos están codificados como bits dentro de un byte.</p>
<p class="calibre5"><strong class="calibre4">9.3. Instrucción XOR</strong></p>
<p class="calibre5">Este nombre significa Exclusive Or (o exclusivo). La tabla
correspondiente es:</p>
<pre class="literal-block">
|     XOR | 0   1
|     -----------.
|       0 | 0   1
|         |
|       1 | 1   0
</pre>
<p class="calibre5">El bit del resultado será 1 cuando los bits correspondientes
de ambos operandos sean distintos. Veamos un ejemplo:</p>
<pre class="literal-block">
|     mov   al, 00110111b
|     xor   al, 01011011b
</pre>
<p class="calibre5">El resultado que queda en AL es 01101100.</p>
<p class="calibre5">Las banderas son afectadas de la misma manera que por AND
y OR.</p>
<p class="calibre5">También XOR tiene varios usos:</p>
<p class="calibre5">A) Borrar un registro a 0:</p>
<pre class="literal-block">
|     xor   ax, ax
</pre>
<p class="calibre5">De acuerdo con la tabla, cada vez que encuentre bits correspondientes iguales XOR dejará un bit 0; y como al ser ambos
operandos iguales todos sus bits correspondientes lo son, el
registro queda en 0. La instrucción sub ax, ax hace lo mismo
y al mismo costo.</p>
<p class="calibre5">B) Invertir bits:</p>
<pre class="literal-block">
|     xor   al, 01011000b
</pre>
<p class="calibre5">Los bits del primer operando correspondientes a bits 1 del
segundo serán invertidos, es decir, serán puestos en 0 si
eran 1 y en 1 si eran 0. Los bits restantes no serán afectados. También esto es útil para manejar ciertas operaciones de
entrada y de salida.</p>
<p class="calibre5">C) Intercambiar dos operandos:</p>
<pre class="literal-block">
|     xor   ax, bx
|     xor   bx, ax
|     xor   ax, bx
</pre>
<p class="calibre5">Esta secuencia de instrucciones intercambia el contenido de
los registros AX y BX, cosa que puede verificarse planteando
todas las combinaciones posibles de bits (son sólo 4) y aplicando la tabla. Más adelante veremos que existe una instrucción que hace lo mismo más económicamente.</p>
<p class="calibre5">D) Para criptografía</p>
<p class="calibre5">Como la aplicación de XOR no tiende a disminuir ni a aumentar
el número de bits en 1 y, además, es reversible (un segundo
XOR con el mismo segundo operando restaura el primer operando
a su valor original), puede utilizarse fácilmente en un
esquema de criptografía.</p>
<p class="calibre5"><strong class="calibre4">9.4. Ejercicio nº 4</strong></p>
<p class="calibre5">Se trata de tomar un texto que tiene mayúsculas y minúsculas
y dejarlo todo en mayúsculas. El texto no contiene otros caracteres que no sean letras (ésta es una restricción un tanto
artificial, pero es necesaria para el ejercicio).</p>
<p class="calibre5">Una manera de realizar esto con operaciones lógicas consiste en apoyarse en el valor ASCII de los caracteres. En
binario, las minúsculas desde a hasta z van desde 01100001
hasta 01111010, y las mayúsculas desde A hasta Z van desde
01000001 hasta 01011010. En hexadecimal, estos valores son
respectivamente 61 a 7A y 41 a 5A. Por lo tanto, para transformar minúsculas a mayúsculas bastaría con restarles 20h.
Pero si hiciéramos esto con todo el texto, las letras que ya
fueran mayúsculas se transformarían en otros caracteres. Un
AND resuelve fácilmente el problema; en cada carácter debe
ponerse en 0 el tercer bit contando desde la izquierda. Véase
en SOLUCIONES una solución basada en este esquema.</p>
<p class="calibre5"><strong class="calibre4">9.5. Ejercicio nº 5</strong></p>
<p class="calibre5">Intentaremos criptografiar un texto aplicándole repetidamente
con XOR un vector de números hasta que se agote el texto. El
desciframiento se logra efectuando la misma operación sobre
el resultado. La longitud del texto se halla en CX; la longitud de la clave criptográfica se desprende de su definición.
Véase una posible solución en SOLUCIONES.</p>
<p class="calibre5"><strong class="calibre4">9.6. Instrucción TEST</strong></p>
<p class="calibre5">Para probar los valores de bits individuales hemos usado la
instrucción AND. Un inconveniente que se presenta con AND es
que el primer operando queda modificado, lo que muchas veces
no es deseable, pues obliga a salvarlo y cargarlo de nuevo
para otros usos. La instrucción TEST resuelve el problema.
TEST es un AND que no modifica el operando de destino sino
sólo las banderas. TEST vendría a ser a AND lo que CMP es a
SUB.</p>
<p class="calibre5">Los formatos de TEST son similares a los de AND. Veamos
algunos ejemplos:</p>
<pre class="literal-block">
|     test   al, 0fh
|     test   Rotulo, 0ach
|     test   al, Rotulo [bx]
|     test   cx, ax
</pre>
<p class="calibre5">Un caso práctico sería probar si AL contiene un número par o
impar:</p>
<pre class="literal-block">
|     test   al, 1
|     jnz   Impar
</pre>
<p class="calibre5"><strong class="calibre4">9.7. Instrucción NOT</strong></p>
<p class="calibre5">Ésta es una operación lógica que sólo lleva un operando, al
cual le invierte todos los bits. De acuerdo con lo expresado
oportunamente, a esto se le llama “obtener el complemento a
1”. Podría lograrse el mismo resultado con mayor costo usando
XOR con un segundo operando con todos los bits 1. NOT admite
como su único operando registros de propósito general de 8 y
16 bits, y bytes y palabras en memoria direccionadas directamente o a través de registros base e índice; obviamente no
admite datos inmediatos. Por ejemplo:</p>
<pre class="literal-block">
|     not   bl
|     not   BYTE PTR Rotulo
|     not   WORD PTR Rotulo + 3 [bx] [si]
</pre>
<p class="calibre5">Si por ejemplo el operando valía 11010011b, luego de NOT
valdrá 00101100b.</p>
<p class="calibre5">Esta instrucción no modifica las banderas.</p>
<p class="calibre5"><strong class="calibre4">9.8. Instrucción NEG</strong></p>
<p class="calibre5">Si bien NEG no es una instrucción lógica sino aritmética, la
incluimos aquí por su similaridad con NOT. Así como NOT obtiene el complemento a 1, NEG obtiene el complemento a 2, lo
que como vimos equivale a obtener el complemento a 1 y sumarle 1. Esto a su vez es lo mismo que invertir el signo del
operando o restarlo de 0.</p>
<p class="calibre5">Los formatos de NEG son iguales que los de NOT. Por ejemplo:</p>
<pre class="literal-block">
|     neg   bl
|     neg   Rotulo                 ; Rotulo = byte o palabra
|     neg   Rotulo - 1 [di]
</pre>
<p class="calibre5">A diferencia de NOT, NEG afecta las banderas, en particular
las siguientes: desborde (OF), signo (SF), cero (ZF), acarreo
(CF), acarreo auxiliar (AF) y paridad (PF). OF se pone en 1
sólo cuando se trata de obtener el complemento a 2 del máximo
número negativo, que como sabemos es el mismo número. CF
siempre queda en 1, excepto cuando el operando es 0.</p>
<p class="calibre5"><strong class="calibre4">9.9. Instrucción NOP</strong></p>
<p class="calibre5">NOP no es una instrucción estrictamente lógica, pero puesto
que no hace nada, ni siquiera alterar las banderas, la veremos acá. Usa algún espacio y tiempo e incrementa el IP como
cualquier otra instrucción. Ocupa un solo byte, y sirve para
anular instrucciones, insertando en cada byte de las mismas
el código de NOP. En realidad, NOP es un alias de una forma
de una instrucción que todavía no hemos visto (XCHG AX, AX).</p>
<p class="calibre5">El Ensamblador emplea esta instrucción para completar espacio cuando no puede determinar si una instrucción tendrá
definitivamente un formato corto o uno más largo. Esto ocurre
principalmente con las instrucciones de bifurcación condicional e incondicional.</p>
<p class="calibre5">El formato de NOP es único y no lleva operandos:</p>
<pre class="literal-block">
|     nop
</pre>
<p class="calibre5"><strong class="calibre4">9.10. Ejercicio nº 6</strong></p>
<p class="calibre5">Éste es un ejercicio simple e instructivo que nos mostrará
cómo aprovechar la división en dos partes de cuatro de los
registros de 16 bits, y nos preparará para comprender mejor
la necesidad de una instrucción que veremos luego.</p>
<p class="calibre5">Intentaremos sumar en una palabra el contenido de todos
los bytes de un vector (de hasta 257 bytes, para que el resultado no exceda de 65.535, pues 257 x 255 = 65.535), considerando que cada byte contiene un número sin signo, o sea
con valor desde 0 hasta 255. La longitud del vector está en
CX.</p>
<p class="calibre5">Dado que no son válidas instrucciones como las siguientes:</p>
<pre class="literal-block">
|     add   ax, dl                  ; Distinta longitud
|     add   ax, Caracteres [si]     ; Idem
</pre>
<p class="calibre5">(donde Caracteres es un rótulo que identifica un vector de
bytes), deberemos recurrir a algún ardid. No sirve:</p>
<pre class="literal-block">
|     add   ax, WORD PTR Caracteres [si]
</pre>
<p class="calibre5">porque, si bien el Ensamblador aceptaría la instrucción,
estaríamos sumando el contenido de palabras y no de bytes.
Véase en SOLUCIONES una solución a este problema.</p>
<p class="calibre5">Si deseáramos realizar este ejercicio usando el valor
algebraico (con signo) del contenido de los bytes, es decir,
desde -128 hasta 127, no podríamos hacerlo tan fácilmente;
sería necesario probar el signo del byte y, de acuerdo con
que fuera positivo o negativo, poner la parte superior del
acumulador de 16 bits en 0 o en -1 respectivamente.</p>
<p class="calibre5">La instrucción que veremos a continuación permite resolver
este pequeño problema.</p>
<p class="calibre5"><strong class="calibre4">9.11. Convertir byte a palabra</strong></p>
<p class="calibre5">Esta instrucción (Convert Byte to Word) convierte el contenido del registro AL a una palabra en AX, extendiendo el bit de
orden alto (signo). El código de la instrucción es CBW y no
tiene operandos explícitos.</p>
<p class="calibre5"><strong class="calibre4">9.12. Ejercicio nº 7</strong></p>
<p class="calibre5">Intentaremos pues repetir el ejercicio anterior esta vez considerando bytes con signo. En esta oportunidad la longitud
máxima del vector será 256, previendo el caso de 256 sumas de
valores todos ellos -128, que produce el máximo valor absoluto que puede contener una palabra con signo: -32.768.</p>
<p class="calibre5">Véase una solución en SOLUCIONES.</p>
<div class="line" id="soluciones">
<h4 class="calibre22">SOLUCIONES</h4>
<p class="calibre5">Ejercicio nº 4: Suponemos que la longitud real del texto está
en CX. El rótulo Longitud define sólo la longitud máxima.:</p>
<pre class="literal-block">
|     ; Transformar minúsculas a mayúsculas
|               .DATA
|     Longitud   EQU   100
|     Texto      DB    Longitud DUP (?)
|               .CODE
|     ................................
|               and   cx, cx            ; Ver si la longitud es 0
|               je    Fin
|               mov   bx, cx            ; Apuntar al fin del texto
|     Otro:
|               and   Texto - 1 [bx], 11011111b   ; Borrar bit
|               dec   bx                ; Ir al byte anterior
|               jnz   Otro              ; Mientras índice no sea 0
|     Fin:
|     ................................
</pre>
<p class="calibre5">Si se requiriese transformar mayúsculas a minúsculas, la
operación adecuada sería:</p>
<pre class="literal-block">
|           or   Texto - 1 [bx], 00100000b   ; Poner bit
</pre>
<p class="pri2">Ejercicio nº 5</p>
<pre class="literal-block">
| ; Criptografiar y descifrar un texto
|
|               .DATA
|     Longitud   EQU   1000               ; Longitud máxima
|     Clave      DB    25, 13, 124, 17, 254, 1, 28, 35, 67, 43
|     Texto      DB    Longitud DUP (?)
|     Largo      EQU   Texto - Clave      ; Longitud de Clave
|     ; Véase cómo puede obtenerse la longitud de un dato mediante
|     ;  un EQU. Esto se debe a que Texto sigue a Clave en la
|     ;  memoria.
|               .CODE
|     ................................
|
|               and   cx, cx           ; Ver si CX = 0
|               jz    Fin
|               mov   di, OFFSET Texto ; Apuntar al comienzo
|               mov   dx, di           ; Calcular fin de Texto + 1
|               add   dx, cx           ; Dejarlo en DX
|     Volver:
|               mov   si, OFFSET Clave ; Apuntar al comienzo
|     Otro:
|               mov   al, [si]         ; Preparar byte de clave
|               xor   [di], al         ; Modificar byte de Texto
|               inc   di               ; Ir al siguiente de Texto
|               inc   si               ; Ir al siguiente de Clave
|               cmp   di, dx           ; Ver si fin de Texto
|               jae   Fin
|               cmp   si, OFFSET Clave+Largo ; Ver si fin de Clave
|               jb    Otro
|               jmp   Volver           ; Seguir próximo ciclo
|     Fin:
|     ................................
</pre>
<p class="pri2">En este programa estamos frente a un ciclo dentro de otro,
donde el ciclo interno puede ser interrumpido en cualquier
momento, debido a que no necesariamente la longitud de Texto
es exactamente divisible por la de Clave. Como sabemos que la
longitud de Clave no puede ser 0, podemos realizar la comparación después de modificar un byte, evitando al mismo tiempo
complicar la lógica del programa.</p>
<p class="calibre5">Los números que forman Clave son arbitrarios.</p>
<p class="pri2">Ejercicio nº 6</p>
<pre class="literal-block">
|      ; Sumar un vector de bytes sin signo en una palabra
|
|                .DATA
|      Longitud   EQU   257      ; Longitud máxima
|      Vector     DB    Longitud DUP (?)
|      Palabra    DW    ?
|                .CODE
|      ................................
|                xor   dx, dx   ; Poner a 0 acumulador
|                and   cx, cx   ; Ver si longitud = 0
|                jz    Fin
|      ; Acá podría verificarse que la longitud en CX no exceda de
|      ;  257.
|                mov   si, cx   ; Apuntar al fin
|                xor   ax, ax   ; Poner a 0 área intermedia
|
|      Volver:
|                mov   al, Vector - 1 [si] ; Tomar byte
|                add   dx, ax   ; Sumarlo ampliado
|                dec   si       ; Ir al byte anterior
|                jnz   Volver   ; Probar si fin
|      Fin:
|                mov   Palabra, dx   ; Guardar resultado
|      ; Si la longitud es nula, el resultado debe ser 0
|      ................................
</pre>
<p class="calibre5">La técnica consiste en usar un registro de 16 bits
desdoblable en dos de 8 como almacenamiento intermedio.
Primero se lo pone en 0, y luego se carga la mitad inferior
con cada byte del vector, con lo cual puede usarse el
registro de 16 bits como origen para la suma.</p>
<p class="calibre5">Ejercicio nº 7</p>
<pre class="literal-block">
|      ; Sumar un vector de bytes con signo en una palabra
|
|               .DATA
|      Longitud  EQU   256      ; Longitud máxima
|      Vector    DB    Longitud DUP (?)
|      Palabra   DW    ?
|               .CODE
|      ................................
|               xor   dx, dx   ; Poner a 0 acumulador
|               and   cx, cx   ; Ver si longitud = 0
|               jz    Fin
|      ; Acá podría verificarse que la longitud en CX no exceda de
|      ;  256.
|               mov   si, cx   ; Apuntar al fin
|
|
|      Volver:
|               mov   al, Vector - 1 [si] ; Tomar byte
|               cbw      ; Convertirlo a palabra
|               add   dx, ax   ; Sumarlo ampliado
|               dec   si       ; Ir al byte anterior
|               jnz   Volver   ; Probar si fin
|      Fin:
|               mov   Palabra, dx   ; Guardar resultado
|      ; Si la longitud es nula, el resultado debe ser 0
|      ................................
</pre>
<p class="calibre5">No ha sido necesario borrar previamente AX, pues CBW extiende
el signo de AL en AH sin importar el contenido previo de AH.
Sería un error aplicar esta misma solución al Ejercicio nº 6,
pues en ese caso los valores se tomaban sin signo. Un valor
que en el Ejercicio nº 6 se sumara como 255, se sumaría como
-1 usando la técnica del nº 7.</p>
<p class="calibre5">En la próxima entrega de este manual:</p>
<p class="pri2">Sección 10:</p>
<ul class="calibre2">
<li class="calibre3">PRACTICA DEL LENGUAJE Y TECNICAS AVANZADAS</li>
</ul>
<p class="calibre5">Sección 11:</p>
<ul class="calibre2">
<li class="calibre3">SUBRUTINAS</li>
</ul>
</div>
</div>
</div>
</div>

</div>

</body>
</html>
