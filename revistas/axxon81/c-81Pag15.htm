<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 81 - SECCIÓN: - Revista virtual de informática</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">Revista virtual de informática</h1>
<p class="calibre5"><b class="calibre4">Ricardo M. Forno / Alejandro Alonso</b></p><p class="calibre5"></p>
<div class="document">
<!-- # :maxLineLen=120:folding=explicit:mode=rest:wrap=soft:collapseFolds=1:encoding=windows-1252: -->
<div class="contents" id="en-este-ejemplar">
<p class="topic-title">En este ejemplar…</p>
<ul class="calibre2">
<li class="calibre3"><a href="#el-humor-en-la-computacion" id="id1">El humor en la computación</a><ul class="calibre19">
<li class="calibre3"><a href="#es-windows-un-virus" id="id2">¿Es Windows un virus?</a></li>
<li class="calibre3"><a href="#transcripcion-de-los-episodios-perdidos-de-viaje-a-las-estrellas" id="id3">Transcripción de “Los Episodios Perdidos de Viaje a las Estrellas”</a></li>
<li class="calibre3"><a href="#codigos-de-error-windows" id="id4">Códigos de Error Windows</a></li>
</ul>
</li>
<li class="calibre3"><a href="#lenguaje-ensamblador-8086-8088-parte-9" id="id5">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 9)</a></li>
</ul>
</div>
<div class="pri2" id="el-humor-en-la-computacion">
<h2 class="indiceautor"><a class="toc-backref" href="#id1">El humor en la computación</a></h2>
<p class="calibre5">Alejandro Alonso  - 1996</p>
<p class="resumen1">Los lectores de Axxón conocen el buen humor de Alejandro,
reflejado mensualmente en la Garrafa Virtual. Muchos han
notado, también, que por aquí no le tenemos mucho cariño
a ese gigante bobo que es el Sistema Operativo Windows.
Alejandro encontró el material que sigue en Internet,
y no dudamos ni un segundo en traducirlo y ofrecerlo
a nuestros lectores. Aprovechemos, que algún día míster
Bill se enterará de nuestra traicionera actitud, lanzará
su MS SF Magazine y nos eliminará de este mundo.</p>
<div class="pri2" id="es-windows-un-virus">
<h3 class="calibre20"><a class="toc-backref" href="#id2">¿Es Windows un virus?</a></h3>
<p class="calibre5">No, Windows no es un virus. Esto es lo que hacen los virus:</p>
<ul class="calibre2">
<li class="calibre3"><p class="first">Se reproducen rápidamente</p>
<p class="calibre5">Okey, Windows hace eso</p>
</li>
<li class="calibre3"><p class="first">Los virus acaparan valiosos recursos del sistema, haciéndolo más lento en el proceso</p>
<p class="calibre5">Okey, Windows lo hace</p>
</li>
<li class="calibre3"><p class="first">Los virus cada tanto llenan de basura su disco rígido</p>
<p class="calibre5">Okey, Windows también lo hace</p>
</li>
<li class="calibre3"><p class="first">Los virus usualmente son transportados sin que el usuario lo sepa, junto con valiosos programas y sistemas</p>
<p class="calibre5">Uf… Windows también hace eso</p>
</li>
</ul>
<ul class="calibre2">
<li class="calibre3"><p class="first">Los virus ocasionalmente harán que el usuario sospeche que su sistema es muy lento (ver punto 2) y que compre nuevo hardware</p>
<p class="calibre5">Ajá, así es Windows también</p>
</li>
</ul>
<p class="pri">Hasta ahora parecería que Windows fuera un virus, pero hay
diferencias fundamentales: Los virus están bien soportados
por sus autores, corren en la mayoría de los sistemas, su
código de programación es veloz, compacto y eficiente y
tienden a volverse más sofisticados a medida que maduran.</p>
<p class="calibre5">De modo que Windows NO es un virus.</p>
</div>
<div class="pri2" id="transcripcion-de-los-episodios-perdidos-de-viaje-a-las-estrellas">
<h3 class="calibre20"><a class="toc-backref" href="#id3">Transcripción de “Los Episodios Perdidos de Viaje a las Estrellas”</a></h3>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Señor LaForge, ¿ha tenido algún éxito en sus intentos de
encontrar alguna debilidad en los Borg? Y señor Data, ¿ha
podido acceder a sus rutas de comando?</p>
<p class="calibre5">[Geordi]</p>
<p class="calibre5">Sí, Capitán. De hecho, encontramos la respuesta buscando en
los archivos de tecnología computacional de fines del siglo
veinte.</p>
<p class="calibre5">[Geordi presiona una tecla y aparece un logo en la pantalla
de la computadora]</p>
<p class="calibre5">[Riker se ve totalmente confundido]</p>
<p class="calibre5">¿Qué demonios es ‘Microsoft’?</p>
<p class="calibre5">[Data se vuelve para responder]</p>
<p class="calibre5">Permítame explicarlo. Enviaremos este programa, por algún
motivo llamado ‘Windows’, a través de las rutas de comando
Borg. Una vez dentro de su unidad principal de comando,
comenzará a consumir recursos del sistema a un ritmo
imparable.”</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Pero los Borg tienen la habilidad de adaptarse. ¿No alterarán
sus sistemas de procesamiento para aumentar su capacidad de
almacenamiento?</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Sí, Capitán. Pero cuando ‘Windows’ detecta eso, crea una nueva versión de sí mismo conocida como un ‘upgrade’. El uso de
recursos se incrementa exponencialmente con cada iteración.
Los Borg no serán capaces de adaptarse suficientemente
rápido. Eventualmente toda su habilidad de procesamiento
estará copada y no quedará nada disponible para sus funciones
operacionales normales.</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Excelente trabajo. Esto es aún mejor que la idea de la ‘forma
geométrica irresoluble’.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Capitán, hemos instalado exitosamente ‘Windows’ en la unidad
de comando y, como esperábamos, consumió inmediatamente el
85 % de todos los recursos. Sin embargo, no hemos recibido
ninguna confirmación del ‘upgrade’ esperado.</p>
<p class="calibre5">[Geordi]</p>
<p class="calibre5">Nuestras sondas han detectado un aumento en las capacidades
de CPU y almacenamiento Borg intentando compensar, pero
todavía seguimos sin tener indicación alguna de un ‘upgrade’
que compense el incremento.</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Data, revisa los bancos históricos nuevamente y determina si
se nos ha escapado algo.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Señor, creo que hay una razón para la falta del ‘upgrade’.
Aparentemente los Borg burlaron esa parte del plan al no
enviar sus tarjetas de registro.</p>
<p class="calibre5">[Riker]</p>
<p class="calibre5">Capitán, no tenemos opción. Solicito permiso para comenzar
secuencia de escape de emergencia 3F…</p>
<p class="calibre5">[Geordi, excitado]</p>
<p class="calibre5">¡Esperen, acabo de detectar que su capacidad de CPU cayó
de repente al 0 por ciento!</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Data, ¿qué muestran sus sondas?</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Al parecer los Borg han descubierto el módulo interno de
‘Windows’ llamado ‘Solitario’ y ese módulo está usando toda
su capacidad de CPU.</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Esperemos y veamos por cuánto tiempo puede reducir su funcionalidad este ‘solitario’.</p>
<p class="calibre5">[Riker]</p>
<p class="calibre5">Geordi, ¿cuál es el estado de los Borg?</p>
<p class="calibre5">[Geordi]</p>
<p class="calibre5">Tal como esperábamos, los Borg están intentando compensar el
aumento de demanda de almacenamiento y CPU. Pero arreglé el
faro monitor de Espacio Profundo más cercano para que cada
vez que se repongan exitosamente transmita más módulos ‘Windows’ de algo llamado el ‘Microsoft fun-pack’.”</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">¿Cuánto tiempo ganaremos con eso?</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">El ritmo actual de la capacidad de los Borg de obtener soluciones me permite predecir un lapso de 6 horas más.</p>
<p class="pri">[Geordi]</p>
<p class="calibre5">Capitán, entró otra nave en nuestro sector.</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Identifíquela.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Parece tener aspecto muy similar al logo ‘Microsoft’.</p>
<p class="calibre5">[Por los altavoces]</p>
<p class="calibre5">ESTE ES EL ALMIRANTE BILL GATES DE LA NAVE INSIGNA MONOPOLIO
DE MICROSOFT. TENEMOS CONFIRMACION POSITIVA DE SOFTWARE NO
REGISTRADO EN ESTE SECTOR. RINDAN TODOS SUS HABERES Y PODREMOS EVITAR CUALQUIER PROBLEMA. TIENEN 10 SEGUNDOS.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">La nave alienígena acaba de abrir sus compuertas delanteras y
liberó miles de objetos de forma humanoide.</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Magnifique visión delantera de la nave alienígena.</p>
<p class="calibre5">[Riker]</p>
<p class="calibre5">¡Por Dios, Capitán! ¡Esos son humanos flotando directo hacia
la nave Borg sin trajes de soporte vital! ¡¿Cómo pueden
sobrevivir a las torturas del espacio profundo?!</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">No creo que esos sean humanos, señor, si los mira más de cerca
creo que verá que llevan algo conocido por los hombres del
siglo veintiuno como maletines de piel de gamo y usan trajes
Armani.</p>
<p class="calibre5">[Riker y Picard juntos, horrorizados]</p>
<p class="calibre5">¡¡Abogados!!</p>
<p class="calibre5">[Geordi]</p>
<p class="calibre5">No puede ser. Todos los abogados fueron acorralados y enviados al sol en el 2017 durante el Gran Despertar.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Cierto, pero aparentemente algunos deben haber sobrevivido.</p>
<p class="calibre5">[Riker]</p>
<p class="calibre5">Han rodeado la nave Borg y están cubriéndola con todo tipo de
papeles.</p>
<p class="calibre5">[Data]</p>
<p class="calibre5">Creo que en el lenguaje vernáculo antiguo era conocido como
‘faja de remate’, a menudo resulta fatal.</p>
<p class="calibre5">[Riker]</p>
<p class="calibre5">¡Están despedazando a los Borg!</p>
<p class="calibre5">[Picard]</p>
<p class="calibre5">Apague los monitores. No puedo soportar verlo, ni siquiera
los Borg merecen eso.</p>
</div>
<div class="pri2" id="codigos-de-error-windows">
<h3 class="calibre20"><a class="toc-backref" href="#id4">Códigos de Error Windows</a></h3>
<p class="calibre5">Recientemente se encontraron los siguientes códigos de error
indocumentados. Microsoft olvidó explicarlos en los manuales,
así que los difundimos vía Internet:</p>
<p class="calibre5">WinErr: 001 Windows no está cargado - Sistema en peligro</p>
<p class="calibre5">WinErr: 002 No hay errores - Todavía</p>
<p class="calibre5">WinErr: 003 Error de enlace dinámico - Su error está ahora en
cada archivo</p>
<p class="calibre5">WinErr: 004 Error erróneo - Nada está mal</p>
<p class="calibre5">WinErr: 005 Intento de multitarea - Sistema confundido</p>
<p class="calibre5">WinErr: 006 Error malicioso - Desqview encontrado en la
unidad</p>
<p class="calibre5">WinErr: 007 Error de precio del sistema - Dinero inadecuado
gastado en hardware</p>
<p class="calibre5">WinErr: 008 Ventana rota - Cuidado con los fragmentos de
vidrio</p>
<p class="calibre5">WinErr: 009 Se encontró una falla horrible - Sabe Dios que pasó</p>
<p class="calibre5">WinErr: 00A Desbordamiento de literatura promocional - Buzón
lleno</p>
<p class="calibre5">WinErr: 00B Espacio de disco inadecuado - Libere al menos 50
MB</p>
<p class="calibre5">WinErr: 00D Ventana cerrada - No mire afuera</p>
<p class="calibre5">WinErr: 00E Ventana abierta - No mire adentro</p>
<p class="calibre5">WinErr: 00F Error inexplicable - Por favor díganos cómo pasó
esto</p>
<p class="pri">WinErr: 010 Reservado para futuros errores por los
desarrolladores</p>
<p class="calibre5">WinErr: 011 Ventana abierta - No mire afuera</p>
<p class="calibre5">WinErr: 012 Ventana cerrada - No mire adentro</p>
<p class="calibre5">WinErr: 013 Error inesperado - ¿Eh?</p>
<p class="calibre5">WinErr: 014 Teclado bloqueado - Intente cualquier cosa que se
le ocurra.</p>
<p class="calibre5">WinErr: 018 Error irrecuperable - El sistema fue destruido.
Compre uno nuevo. La licencia del viejo Windows ya no es
válida.</p>
<p class="calibre5">WinErr: 019 Error del usuario - No es culpa nuestra. ¡No lo
es! ¡No lo es!</p>
<p class="calibre5">WinErr: 01A Sistema operativo sobreescrito - Por favor
reinstale todo su software. Lo lamentamos terriblemente.</p>
<p class="calibre5">WinErr: 01B Error ilegal - No se le permite tener este error.
La proxima vez será castigado.</p>
<p class="calibre5">WinErr: 01C Error de incertidumbre - La incertidumbre puede
ser inadecuada.</p>
<p class="calibre5">WinErr: 01D Caída del sistema - Somos incapaces de resolver
nuestro propio código.</p>
<p class="calibre5">WinErr: 01E Error de tiempo - Por favor espere. Y espere. Y
espere. Y espere.</p>
<p class="calibre5">WinErr: 01F Reservado para futuros errores de nuestros
desarrolladores.</p>
<p class="calibre5">WinErr: 020 Error registrando códigos de error - Los errores
que quedan se perderán.</p>
<p class="calibre5">WinErr: 042 Error de virus - Se ha activado un virus en una
ventana de DOS. El virus, sin embargo, requiere Windows.
Todas las tareas se cerrarán automáticamente y el virus se
activará nuevamente.</p>
<p class="calibre5">WinErr: 079 No se encuentra Mouse - No se ha instalado un
controlador de mouse. Por favor cliquee el botón izquierdo
del mouse para continuar.</p>
<p class="calibre5">WinErr: 103 Desbordamiento del buffer de error - Se
encontraron demasiados errores. Los próximos errores no serán
mostrados o registrados.</p>
<p class="calibre5">WinErr: 678 Esto terminará su sesión Windows. ¿Quiere jugar
otro juego?</p>
<p class="calibre5">WinErr: 815 Memoria insuficiente - Sólo 50.312.583 Bytes
disponibles.</p>
</div>
</div>
<div class="pri2" id="lenguaje-ensamblador-8086-8088-parte-9">
<h2 class="indiceautor"><a class="toc-backref" href="#id5">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 9)</a></h2>
<p class="calibre5"><strong class="calibre4">Manejando el alma de la PC</strong></p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<ol class="pri4" start="21">
<li class="calibre3">INTERFAZ CON OTROS LENGUAJES</li>
</ol>
<p class="calibre5">Es posible combinar programas en lenguaje Ensamblador con
otros en lenguajes de alto nivel. Si bien se puede llamar
subrutinas de alto nivel desde programas en Ensamblador,
es más común lo contrario, o sea llamar subrutinas en
Ensamblador desde un lenguaje de alto nivel. Esto se hace
para dotar al lenguaje de alto nivel de facilidades tales
como acceso a dispositivos no soportados, o para aumentar
la velocidad de ciertas operaciones.</p>
<p class="calibre5">Nos concentraremos pues en este tema de las subrutinas en
Ensamblador para lenguajes de alto nivel. En particular,
trataremos la interfaz con el lenguaje C, que es uno de los
de mayor empleo actualmente. Las interfaces con otros
lenguajes son muy similares.</p>
<p class="calibre5">21.1. Interfaz con C</p>
<p class="calibre5">Esta interfaz tiene algunas peculiaridades que pasamos a
destacar:</p>
<ol class="pri4">
<li class="calibre3">Los parámetros se pasan a la subrutina a través de la
Pila, ya sea como valores o como direcciones de los
parámetros reales. En el caso de que se pasen direcciones,
éstas pueden ser cercanas o lejanas, dependiendo del modelo
de memoria del programa en C.</li>
<li class="calibre3">Las llamadas también pueden ser cercanas o lejanas,
dependiendo del modelo de memoria del programa en C.</li>
<li class="calibre3">El programa en C se encarga de eliminar los parámetros de
la Pila luego de ejecutada la subrutina.</li>
<li class="calibre3">La subrutina devuelve el resultado en el registro AX si
los parámetros se pasaron como valores y el resultado es
entero, o directamente modifica los parámetros si se
pasaron como direcciones. Esta regla depende del tipo de
datos que se procesen.</li>
<li class="calibre3">El programa en C no espera que la subrutina preserve el
valor de todos los registros. Los únicos registros que debe
preservar la subrutina son CS, SS, SP, DS, BP, SI y DI.</li>
<li class="calibre3">La subrutina, en caso de constar de un procedimiento
cercano, deberá estar incluida en un segmento rotulado
_TEXT, PUBLIC y de clase ‘CODE’.</li>
<li class="calibre3">El nombre de la subrutina será el que use el programa C
para llamarla, prefijado por un carácter “_”.</li>
<li class="calibre3">Las mayúsculas y minúsculas en el nombre de la subrutina
deben coincidir con las de la llamada en el programa en C.</li>
<li class="calibre3">Los parámetros ingresan a la Pila en orden inverso, es
decir, el último parámetro de la llamada en C ingresa
primero. Por lo tanto, en la Pila quedan en orden directo,
es decir, el primer parámetro queda en primer lugar.</li>
</ol>
<p class="calibre5">Veamos ahora varias formas de llamar una subrutina en
Ensamblador desde C de acuerdo con que se pasen valores o
direcciones y en función de los varios modelos de memoria. En
todos los casos mostraremos una subrutina para obtener el
valor absoluto de un entero de 16 bits (int en C). El método
usado es el más natural pero no el más eficiente; dejaremos
este último para un ejercicio.</p>
<p class="calibre5">A) Paso del parámetro por valor. Código y datos cercanos.
La llamada en C tiene este aspecto:</p>
<pre class="literal-block">
k = Abs(i);
</pre>
<p class="calibre5">La secuencia de llamada que esto genera es aproximadamente:</p>
<pre class="literal-block">
|       push  i                     ; Poner parámetro
|       call  _Abs                  ; Llamar a la subrutina
|       add   sp, 2                 ; Descartar el parámetro
|       mov   k, ax                 ; Guardar el resultado
</pre>
<p class="calibre5">La rutina en Ensamblador sería:</p>
<pre class="literal-block">
| _TEXT    SEGMENT BYTE PUBLIC 'CODE'
|           ASSUME   CS:_TEXT
|           PUBLIC   _Abs
| _Abs     PROC   near
|           push   bp                ; Salvar BP
|           mov    bp, sp            ; Direccionar la Pila
|           mov    ax, 4 [bp]        ; Tomar valor
|           and    ax, ax            ; Probar signo
|           jns    Positivo          ; Si positivo, nada
|           neg    ax                ; Invertir el signo
|
| Positivo:
|           pop    bp                ; Restaurar BP
|           ret                      ; Retorno near
| _Abs     ENDP
| _TEXT    ENDS
</pre>
<p class="calibre5">Como vimos, el segmento debe llamarse _TEXT y ser PUBLIC y de
clase ‘CODE’ para que se combine con el segmento de código
del programa en C.</p>
<p class="calibre5">No se precisa una alineación especial del segmento de código,
por lo que se indica BYTE.</p>
<p class="calibre5">La directiva ASSUME CS:_TEXT indica que el registro de
segmento CS contendrá el valor correspondiente a _TEXT, que
no es el del comienzo de esta parte del segmento sino el del
segmento de código del programa en C, que se combina con el
presente. Este valor es correcto, pues es el que se carga al
principio del programa en C. De cualquier manera, muchas
veces carece de importancia el valor que se supone que
contiene CS, pues las bifurcaciones son relativas al lugar
que las origina, y por lo tanto CS no interviene en las
mismas.</p>
<p class="calibre5">La directiva PUBLIC hace que su operando sea conocido fuera
de la subrutina, lo cual es necesario para poder llamarla.
Correspondientemente, el programa en C debe declarar como
externo (EXTRN) el rótulo usado, en este caso _Abs.</p>
<p class="calibre5">Salvamos sólo el registro BP pues, como se dijo, C no precisa
que se preserve el otro registro que usamos (AX). Por otra
parte, el resultado debe quedar en AX, y por lo tanto no
podríamos restaurarlo.</p>
<p class="calibre5">Como la llamada es de tipo cercano, la dirección de retorno
ocupa 2 bytes en la Pila. Luego, otros 2 bytes son ocupados
al salvar el registro BP. Por lo tanto, el parámetro pasado
queda 4 bytes abajo de la cima de la Pila, y se lo debe tomar
con mov ax, 4 [bp]. Esta instrucción usa implícitamente el
registro de segmento SS.</p>
<p class="calibre5">B) Paso del parámetro por dirección. Código y datos cercanos.
En este caso, la llamada en C sería similar a:</p>
<pre class="literal-block">
Abs1(&amp;i);
</pre>
<p class="calibre5">donde lo que se pasa no es el valor de i sino su dirección, y
se espera que el parámetro i sea reemplazado por su valor
absoluto.</p>
<p class="pri">La secuencia de llamada que esto genera es aproximadamente:</p>
<pre class="literal-block">
|           mov    ax, OFFSET i       ; Dirección del parámetro
|           push   ax                 ; Poner parámetro
|           call   _Abs1              ; Llamar a la subrutina
|           add    sp, 2              ; Descartar el parámetro
</pre>
<p class="calibre5">La rutina en Ensamblador sería:</p>
<pre class="literal-block">
| _TEXT    SEGMENT BYTE PUBLIC 'CODE'
|           ASSUME  CS:_TEXT
|           PUBLIC  _Abs1
| _Abs1    PROC    near
|           push    bp               ; Salvar BP
|           mov     bp, sp           ; Direccionar la Pila
|           mov     bx, 4 [bp]       ; Tomar dirección
|           mov     ax, [bx]         ; Tomar valor
|           and     ax, ax           ; Probar signo
|           jns     Positivo         ; Si positivo, nada
|           neg     ax               ; Invertir el signo
| Positivo:
|           mov     [bx], ax         ; Guardar el resultado
|           pop     bp               ; Restaurar BP
|           ret                      ; Retorno near
| _Abs1    ENDP
| _TEXT    ENDS
</pre>
<p class="calibre5">Es posible argüir que sería más eficiente realizar la operación de esta manera:</p>
<pre class="literal-block">
|           cmp     WORD PTR [bx], 0  ; Probar signo
|           jge     Positivo          ; Si positivo, nada
|           neg     WORD PTR [bx]     ; Invertir el signo
| Positivo:
|           pop     bp                ; Restaurar BP
</pre>
<p class="calibre5">pero por ahora sólo nos interesa mostrar las diferencias en
las formas de llamada y no en el proceso. Lo importante es
que, en este caso, lo que se pasa en la Pila es la dirección
del parámetro y no su valor, y que el resultado se inserta
reemplazando el parámetro, lo que puede hacerse precisamente
porque se tiene su dirección.</p>
<ol class="upperalpha" start="3">
<li class="calibre3">Paso del parámetro por valor. Código lejano, datos cercanos.</li>
</ol>
<p class="calibre5">La llamada en C sería como la primera:</p>
<pre class="literal-block">
k = Abs2(i);
</pre>
<p class="calibre5">y su desarrollo similar:</p>
<pre class="literal-block">
|           push   i                   ; Poner parámetro
|           call   _Abs2               ; Llamar a la subrutina
|           add    sp, 2               ; Descartar el parámetro
|           mov    k, ax               ; Guardar el resultado
</pre>
<p class="calibre5">excepto que la llamada será de tipo lejano, por haber llamado
un procedimiento lejano como el que sigue:</p>
<pre class="literal-block">
| A2_TEXT   SEGMENT BYTE PUBLIC 'CODE'
|            ASSUME  CS:A2_TEXT
|            PUBLIC  _Abs2
| _Abs2     PROC    far
|            push    bp                ; Salvar BP
|            mov     bp, sp            ; Direccionar la Pila
|            mov     ax, 6 [bp]        ; Tomar valor
|            and     ax, ax            ; Probar signo
|            jns     Positivo          ; Si positivo, nada
|            neg     ax                ; Invertir el signo
|
| Positivo:
|            pop     bp                ; Restaurar BP
|            ret                       ; Retorno far
| _Abs2     ENDP
| A2_TEXT   ENDS
</pre>
<p class="calibre5">Nótese que el segmento ya no se llama _TEXT, sino que tiene
un nombre arbitrario. Esto es debido a que es lejano, con lo
cual no se combina con el segmento _TEXT.</p>
<p class="calibre5">La llamada a esta subrutina también es lejana, por lo que
efectúa PUSH no sólo del IP sino también del CS, y al
ejecutarse cambia el valor del CS junto con el del IP. La
instrucción RET también es lejana, por lo que restaurará
ambos registros desde la Pila.</p>
<p class="calibre5">La presencia del CS en la Pila hace que para tomar el parámetro se deba ir a 6 [bp]  en lugar de 4 [bp].</p>
<p class="calibre5">D) Paso del parámetro por dirección. Código cercano, datos
lejanos.</p>
<p class="calibre5">La llamada en C sería:</p>
<pre class="literal-block">
Abs3(&amp;i);
</pre>
<p class="calibre5">y su desarrollo:</p>
<pre class="literal-block">
|           push   ds                ; Poner el segmento
|           mov    ax, OFFSET i      ; Desplazamiento
|           push   ax                ; Poner el desplazamiento
|           call   _Abs3             ; Llamar a la subrutina
|           add    sp, 4             ; Descartar el parámetro
</pre>
<p class="calibre5">La rutina quedaría así:</p>
<pre class="literal-block">
| _TEXT    SEGMENT BYTE PUBLIC 'CODE'
|           ASSUME  CS:_TEXT
|           PUBLIC  _Abs3
| _Abs3    PROC    near
|           push    bp                ; Salvar BP
|           mov     bp, sp            ; Direccionar la Pila
|           les     bx, 4 [bp]        ; Tomar dirección
|           mov     ax, ES:[bx]       ; Tomar valor
|           and     ax, ax            ; Probar signo
|           jns     Positivo          ; Si positivo, nada
|           neg     ax                ; Invertir el signo
| Positivo:
|           mov     ES:[bx], ax       ; Guardar el resultado
|           pop     bp                ; Restaurar BP
|           ret                       ; Retorno near
| _Abs3    ENDP
| _TEXT    ENDS
</pre>
<p class="calibre5">La instrucción les bx, 4 [bp] carga ES y BX con la dirección
que está en la Pila en dos palabras. No es necesario preservar ES pues C no espera que se lo haga.</p>
<p class="calibre5">Además de los casos vistos, pueden plantearse otras combinaciones de llamada por valor o por dirección, código cercano o
lejano, y datos cercanos o lejanos.</p>
<ol class="pri4" start="22">
<li class="calibre3">MACROINSTRUCCIONES Y OTRAS FACILIDADES</li>
</ol>
<p class="calibre5">El Ensamblador cuenta con una serie de directivas para
generar código y datos en base a especificaciones. Veremos
algunas de estas directivas.</p>
<p class="pri">22.1. Repetición de bloques</p>
<p class="calibre5">Un bloque que se repite comienza con la directiva REPT y
termina con la directiva ENDM. El código y los datos entre
estas dos directivas son incluidos el número de veces indicado en el operando de REPT. Dentro del bloque puede haber
instrucciones y directivas, incluidas las propias directivas
REPT y ENDM. Veamos un ejemplo:</p>
<pre class="literal-block">
|           REPT   3
|           DW     0
|           ENDM
</pre>
<p class="calibre5">genera:</p>
<pre class="literal-block">
|           DW     0
|           DW     0
|           DW     0
</pre>
<p class="calibre5">Esto en realidad no es demasiado interesante, pues lo mismo
podríamos haberlo obtenido con la especificación DUP, pero
REPT es más flexible, como veremos combinándola con otras
directivas.</p>
<p class="calibre5">La directiva = asigna un valor a un rótulo. En esto es
similar a la directiva EQU pero, a diferencia de ésta, con =
el mismo rótulo puede ser usado repetidas veces, cambiado de
valor. Combinando esta directiva con REPT y ENDM podemos
realizar lo siguiente:</p>
<pre class="literal-block">
| Indice   =       0
|           REPT    3
|           DW      Indice
| Indice   =       Indice + 1
|           ENDM
</pre>
<p class="calibre5">que genera:</p>
<pre class="literal-block">
|           DW      0
|           DW      1
|           DW      2
</pre>
<p class="calibre5">Los procesadores para PC, y especialmente los 8088 y 8086, no
se caracterizan por la velocidad de sus instrucciones de multiplicación y división, que pueden ser unas 20 o 40 veces más
lentas que una suma. Para acelerarlas, en casos particulares
podemos recurrir a tablas y otros artificios. Por ejemplo,
para multiplicar por 10 un número desde 0 hasta 255 guardado
en un byte, podemos codificar:</p>
<pre class="literal-block">
|           .DATA
| Tabla    LABEL   WORD
| Elemento =       0
|           REPT    256
|           DW      Elemento
| Elemento =       Elemento + 10
|           ENDM
| Dato     DB      ?
|           .CODE
| ................................
|           xor     bh, bh            ; Borrar
|           mov     bl, Dato          ; Tomar multiplicando
|           shl     bx, 1             ; Multiplicarlo por 2
|           mov     ax, Tabla [bx]    ; Resultado en AX
| ................................
</pre>
<p class="calibre5">La directiva LABEL asigna a su rótulo el valor del contador
de direcciones en ese punto, que en el presente ejemplo
coincide con el primer elemento de la tabla. El operando de
LABEL indica el tipo que tendrá el rótulo, que puede ser
BYTE, WORD, etc.</p>
<p class="calibre5">También es posible incluir instrucciones dentro del bloque
REPT / ENDM. Por ejemplo, podríamos acelerar la división por
8 de un número de 32 bits en el par de registros DX:AX así:</p>
<pre class="literal-block">
|           REPT   3
|           shr    dx, 1
|           rcr    ax, 1
|           ENDM
</pre>
<p class="calibre5">La directiva IRP permite suministrar valores a un parámetro
de modo de alterarlo en cada pasada. Un ejemplo aclarará
esto:</p>
<pre class="literal-block">
|           IRP    Dato &lt;1000, -50, 200, 30&gt;
|           DW     Dato
|           ENDM
</pre>
<p class="calibre5">genera:</p>
<pre class="literal-block">
|           DW    1000
|           DW    -50
|           DW    200
|           DW    30
</pre>
<p class="calibre5">La directiva IRPC es similar a la anterior, pero funciona con
una cadena de caracteres que no va entre delimitadores (apóstrofos o comillas). Por ejemplo:</p>
<pre class="literal-block">
|           IRPC  Dato, AH1F
|           cmp   al, '&amp;Dato&amp;'
|           je    Encontro
|           ENDM
</pre>
<p class="calibre5">genera:</p>
<pre class="literal-block">
|           cmp   al, 'A'
|           je    Encontro
|           cmp   al, 'H'
|           je    Encontro
|           cmp   al, '1'
|           je    Encontro
|           cmp   al, 'F'
|           je    Encontro
</pre>
<p class="calibre5">El carácter &amp; se usa para forzar la evaluación del parámetro
aun cuando, como en este caso, se encuentre entre apóstrofos.</p>
<p class="pri">22.2. Macroinstrucciones</p>
<p class="calibre5">Las macroinstrucciones o, por brevedad, macros consisten en
secuencias de instrucciones o directivas identificadas por
nombres arbitrarios definidos por el programador. La definición de la macro termina con la directiva ENDM. Cuando el
nombre de la macro aparece más adelante, se lo reemplaza por
el bloque de texto. Veamos un ejemplo:</p>
<pre class="literal-block">
| Salvar   MACRO
|           push   ax
|           push   bx
|           push   cx
|           push   dx
|           push   si
|           push   di
|           push   bp
|           ENDM
</pre>
<p class="calibre5">Esta definición irá normalmente al principio del programa, y
en todo caso antes de que se la use. Cada vez que se incluya
el nombre Salvar en el programa, se expandirá a las instrucciones del cuerpo de la macro.</p>
<p class="calibre5">Puede resultar curioso que la directiva ENDM indique la
terminación tanto de una directiva REPT como de una macro.
Sucede que REPT es en realidad un tipo de macro.</p>
<p class="calibre5">Las macros pueden llevar parámetros, que aparecen como
operandos de las mismas. Por ejemplo, veamos una macro que
divide un número en el registro Ax por una potencia de 2:</p>
<pre class="literal-block">
| Divpot2   MACRO   Potencia
|            REPT    Potencia
|            sar     ax, 1
|            ENDM
|            ENDM
</pre>
<p class="calibre5">Cuando más adelante en el programa insertemos por ejemplo:</p>
<pre class="literal-block">
|            Divpot2  3
</pre>
<p class="calibre5">se generará:</p>
<div class="line-block1">
<div class="pri2">sar     ax, 1</div>
<div class="pri2">sar     ax, 1</div>
<div class="pri2">sar     ax, 1</div>
</div>
<p class="calibre5">En cierta manera, una macro es similar a una subrutina. Si en
determinado caso podemos elegir entre las dos, el criterio
para decidir sería el siguiente: en general la subrutina
ocupa menos espacio, pues su código se incluye una sola vez,
a diferencia de la macro, que incluye el código en cada
llamada (esto es cierto a menos que la subrutina sea muy
corta, pues entonces la instrucción de llamada y el pasaje de
parámetros pesarán mucho en el consumo de espacio). En
cambio, la macro usa menos tiempo, pues no incurre en el
gasto de la instrucciones de llamada, de retorno y de pasaje
y toma de parámetros.</p>
<p class="calibre5">Veamos otro ejemplo de uso de una macro (en este caso REPT) y
del carácter &amp;. Supongamos que deseamos definir 100
acumuladores de una palabra con valores 1, 2, … 100 y
nombres A1, A2, … A100. Podemos hacerlo así:</p>
<pre class="literal-block">
| Numero   =      1
|           REPT   100
| A&amp;Numero&amp; DW    Numero
|           ENDM
</pre>
<p class="calibre5">lo que generará:</p>
<pre class="literal-block">
| A1       DW     1
| A2       DW     2
| ................................
</pre>
<p class="calibre5">Lo que se encierra entre caracteres &amp;, si es el nombre de un
parámetro o rótulo definido, se sustituye por su valor.</p>
<p class="calibre5">La directiva LOCAL, incluida inmediatamente después del encabezamiento de una macro, hace que sus operandos sean rótulos
locales de la macro, con lo que se evita el problema que
surgiría cuando se llame la macro más de una vez: aparecerían
rótulos duplicados. Usando LOCAL, en reemplazo del rótulo la
macro genera otro compuesto de dos signos ‘?’ seguidos de un
número hexadecimal único, razón por la cual el programador
debe evitar crear rótulos que empiecen por ??, aunque sean
legales. Veamos un ejemplo:</p>
<pre class="literal-block">
| Abs      MACRO   Registro
|           LOCAL   Positivo
|           and     Registro, Registro
|           jns     Positivo
|           neg     Registro
| Positivo:
|           ENDM
</pre>
<p class="calibre5">Cada vez que se llame esta macro, se generará un rótulo
formado por ?? seguidos por un número hexadecimal único.
La directiva IF permite incluir texto en forma condicional en
la expansión de una macro. La expresión que se prueba sigue a
IF en la misma línea, y el texto que se incluye o no va en
líneas siguientes hasta que se encuentre una directiva ENDIF.
Si el valor de la expresión (que debe poder evaluarse cuando
se compagine el programa) es distinto de 0, se incluye el
texto hasta ENDIF, y si es 0, no se incluye.</p>
<p class="calibre5">La directiva EXITM permite una salida de la macro antes de
llegar a su fin.</p>
<p class="calibre5">Veamos el uso de estas directivas en una macro que calcula el
factorial de su parámetro y lo deja en el registro AX,
llamándose recursivamente:</p>
<pre class="literal-block">
| Factorial MACRO   Numero
|            IF      Numero LE 1
|            mov     ax, 1
|            EXITM
|            ENDIF
|            Factorial Numero - 1
|            mov     dx, Numero
|            mul     dx
|            ENDM
</pre>
<p class="calibre5">El parámetro que se le pasa a la macro es un dato inmediato
(constante); no puede hallarse en una ubicación de memoria o
en un registro, pues la directiva IF es evaluada por el
Ensamblador, no mientras se ejecuta el programa. En otras
palabras, las instrucciones se generan antes de correrse el
programa y no durante su ejecución.</p>
<p class="calibre5">Si el parámetro que se le pasa a la macro es 1 o menor (ésta
es la prueba que realiza el operador LE), se genera una
instrucción que pone 1 en el registro AX. De lo contrario, se
llama recursivamente a la macro con un valor menor en una
unidad, y se generan instrucciones que lo multiplican por el
parámetro. Supongamos por ejemplo que Numero sea 2. Entonces,
el texto del IF no se genera, se llama a Factorial con el
valor 1 = 2 - 1, lo que ahora sí genera mov ax, 1, y luego,
en la primera llamada a Factorial, se generan mov dx, Numero
y mul dx. Las instrucciones generadas por Factorial 4 serían:</p>
<pre class="literal-block">
|           mov    ax, 1
|           mov    dx, 4 - 1 - 1
|           mul    dx
|           mov    dx, 4 - 1
|           mul    dx
|           mov    dx, 4
|           mul    dx
</pre>
<hr class="docutils"/>
<p class="calibre5">En la próxima entrega de este manual:</p>
<p class="calibre5">APENDICES</p>
</div>
</div>

</div>

</body>
</html>
