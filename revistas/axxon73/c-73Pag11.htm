<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 73 - SECCIÓN: - Actualidad en informática</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">Actualidad en informática</h1>
<p class="calibre5"><b class="calibre4">Alejandro Alonso y Ricardo M. Forno</b></p><p class="calibre5"></p>
<div class="document">
<!-- # :maxLineLen=120:folding=explicit:mode=rest:wrap=soft:collapseFolds=1:encoding=windows-1252: -->
<blockquote class="epigraph">
Como de costumbre, esta Revista
Virtual de Informática ofrece
la ACTUALIDAD EN INFORMATICA y una
sección TECNICA, con información
tecnológica súper actual.</blockquote>
<div class="line" id="lockheed-y-la-multimedia-espacial">
<h2 class="indiceautor">LOCKHEED Y LA MULTIMEDIA ESPACIAL</h2>
<p class="calibre5">Competencia para las Redes, pero por satélite</p>
<p class="calibre5">El grupo americano planea construir un sistema satelital por
el cual se transmitan voz, datos, video y otros enlaces
digitales, con una inversión de 4.000 millones de dólares.
Lockheed presentó un pedido ante el comité que se encarga de
las comunicaciones en los Estados Unidos (Federal Communications Commission, ó FCC) para construir, poner en órbita y
operar un sistema llamado Astrolink, que ofrecerá servicios
de comunicaciones digitales a empresas y compañías telefónicas. Si bien el proyecto está sujeto a aprobación, ya están
buscando socios. (A.A. Fuente: Financial Times / El Cronista)</p>
</div>
<div class="line" id="la-otra-vereda-del-pentium">
<h2 class="indiceautor">LA OTRA VEREDA DEL PENTIUM</h2>
<p class="calibre5">Otras opciones para los chips más famosos</p>
<p class="calibre5">Cyrix, una de las compañías que compite con Intel (espera a
que salgan los microprocesadores y después los clonan), puso
como fecha de aparición de su chip Pentium el 25 de Septiembre. Para antes de fin de año pretenden lanzar un nuevo Pentium mucho más veloz (1,2 a 1,3 veces la velocidad de su
equivalente de Intel), hecho que le garantiza, según analistas, una participación del 10% del mercado de los Pentiums
para el próximo año. Esta compañía tiene en la actualidad un
7% del mercado de 486.</p>
<p class="calibre5">En tanto, Advanced Micro Devices (AMD), otra fabricante de
reemplazos de Intel, estima que su versión del Pentium no
estará lista hasta mediados de 1996.</p>
<p class="calibre5">Entretanto, Intel presentó en septiembre su Pentium Overdrive de 83 MHz, destinado a la actualización de los sistemas
486 y DX2  (A.A. Fuente: Business Week e Intel)</p>
</div>
<div class="line" id="sun-y-el-net-day">
<h2 class="indiceautor">SUN Y EL NET DAY</h2>
<p class="calibre5">Trabajos comunitarios de la era informática</p>
<p class="calibre5">La empresa SUN Microsystem liderará las obras que se llevarán
a cabo para interconectar los colegios de California, permitiéndoles el acceso a Internet. En el operativo, que fue
anunciado por el mismo Bill Clinton y por su vicepresidente
Al Gore desde San Francisco, participarán además los padres
de los alumnos, ingenieros, voluntarios y representantes de
otras firmas de primer nivel: AT&amp;T, 3Com, Smart Valley, Oracle y Apple, entre muchas otras. “Netday 96” será el 6 de
marzo de 1996, y ese día los colaboradores y voluntarios irán
a los colegios y trabajarán codo a codo con los ingenieros y
especialistas de las empresas.</p>
<p class="calibre5">SUN coordinará este esfuerzo comunitario que permitirá
tener a todos los colegios californianos interconectados a la
red de redes. Comercialmente, la participación actual de
servidores Sun dentro de la Internet es del 57%, según IDC.</p>
<p class="calibre5">Para más información ver URL.http WWW.W3.com/netday96.</p>
<p class="calibre5">En el ámbito local SUN (cuyo verdadero significado es
Stanford University Network) colabora con la Universidad de
Buenos Aires en la elaboración de páginas de Web y mediante
la donación de equipos. (A.A. Fuente: Sun)</p>
</div>
<div class="line" id="the-pc-is-dead">
<h2 class="indiceautor">THE PC IS DEAD</h2>
<p class="calibre5">Nuevas tendencias en la arquitectura de los equipos personales</p>
<p class="calibre5">Ese es el título con el que Byte (EE.UU.) del mes de Octubre
presenta a las cuatro tecnologías que redefinirán la vieja
arquitectura IBM compatible. Los avances de los que habla la
nota son:</p>
<ul class="calibre2">
<li class="calibre3">Plug and Play:  Una característica que se hizo popular a partir del Windows ‘95 y que apunta a hacer más sencilla la instalación de hardware. No está de más recordar que este sistema ya existía en las Macintosh. Los fabricantes de hardware (Compaq, Dell, Texas Instrument, NEC, Digital, Acer, Hewlett Packard y 3Com, sólo por citar unos pocos) se han apresurado a incluir la norma en sus equipos y dispositivos. De hecho, muchos la tenían disponible antes del lanzamiento del Windows, tal es el caso de Compaq y Dell. Para que la norma funcione, tienen que confluir 3 factores: hardware P&amp;P, BIOS P&amp;P y sistema operativo P&amp;P.</li>
<li class="calibre3">Port Power: USB (del inglés, Port Serial Universal) es una característica que comenzará a verse a partir del año próximo y que podría reemplazar a todos los demás ports de las PC’s de hoy en día.  Con un ancho de banda máximo de 12 Mbps, incluyendo un subcanal de 1 Mbps para dispositivos lentos, es capaz de transmitir video, mouse, señales al monitor, scanners, ISDN y el nuevo formato de video MPEG-2. Además, USB es asincrónico y sincrónico a la vez (el puerto es capaz de detectar los datos que requieren sincronización y de mandarlos sin interrupciones). Según Byte, se pueden conectar en estrella hasta 127 dispositivos.</li>
<li class="calibre3">Unificación de la RAM: UMA es una arquitectura que permitirá unir la memoria de video con la RAM operativa. Los equipos necesitan cada vez más memoria que pueda soportar los modos de video en máxima resolución y con colores reales, UMA hará un buffer sobre la RAM (reservará memoria) para el modo de pantalla que corresponda, y la liberará cuando no la necesite.</li>
<li class="calibre3">Señales mezcladas: Un procesador de señales aumentará la performance de los equipos en los distintos periféricos. Los procesadores de señal nativos, como el NSP de Intel, constituyen una tecnología efectiva (y relativamente barata) para el mercado de multimedia.</li>
</ul>
<p class="calibre5">Byte pone en la punta de esta revolución tecnológica a Microsoft y a Intel que, si bien a veces parecen tener intereses distintos, están dándole forma a los estándares, tal como lo hiciera IBM en los ochenta. Además se presentan novedades y direcciones dentro de la nota. (Fuente: Byte, con comentarios de A.A.)</p>
</div>
<div class="line" id="ms-se-repite">
<h2 class="indiceautor">¡MS+ SE REPITE!</h2>
<p class="calibre5">Los grandes tropiezos de Papá Software</p>
<p class="calibre5">Este mail apareció en el foro Windows 95 de Los Pinos II, y
es acerca de cierto problemita con los diskettes del MS PLUS!:</p>
<p class="calibre5"><em class="calibre9">Hola, Inventor! En realidad, la secuencia de las etiquetas</em>
<em class="calibre9">esta bien, la joda viene con el contenido de los disquetes.</em>
<em class="calibre9">En MS me dieron otra copia de los 6 discos… con el mismo</em>
<em class="calibre9">problema! Finalmente la tercera fue la vencida, tras comentarme que alguna partida vino con el error que comente, con 2</em>
<em class="calibre9">discos “4” y otra con 2 discos “5”. Ahí entendí porque MS</em>
<em class="calibre9">promociona el Win95 diciendo que es el “mas divertido”: habra</em>
<em class="calibre9">que encontrar aquella persona que tenga el duplicado cruzado:</em>
<em class="calibre9">vos tenes 2 discos “4” y te falta el “5”? Joya! Yo tengo 2</em>
<em class="calibre9">discos “5”!!</em></p>
<p class="calibre5"><em class="calibre9">Alcoyana-Alcoyana! Y como siempre, este juego ha sido auspiciado pooor… A no preocuparse, mis amigos. Esto recien
comienza! Saluditos, GUS</em></p>
<p class="calibre5">Huelgan las palabras… (A.A.)</p>
</div>
<div class="line" id="el-p6">
<h2 class="indiceautor">EL P6</h2>
<p class="calibre5">Algunos datos sobre el sucesor del Pentium</p>
<p class="calibre5">Si bien muchos consideran al P6 como el próximo paso en materia de microprocesadores para PC’s, lo cierto es que algunos
otros están proyectando su utilización para equipos de mayor
envergadura. El Departamento de Energía de los Estados Unidos
utilizará un sistema basado en 9.000 microprocesadores P6 que
estará situado en los Laboratorios de Sandia, en Alburquerque, para realizar estudios por simulación relacionados con
pruebas nucleares. El engendro realizará cerca de un billón
de operaciones por segundo (1 teraop), lo que significa que
será 10 veces más rápido que la supercomputadora más veloz.
El equipo se instalará hacia fines de 1996. (A.A. Fuente:
Intel)</p>
</div>
<div class="line" id="lenguaje-ensamblador-8086-8088-parte-1">
<h2 class="indiceautor">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 1)</h2>
<p class="calibre5"><strong class="calibre4">Cómo adentrarse en el alma de la PC</strong></p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<p class="calibre5">ADVERTENCIA: Si bien el texto y los programas de este
libro han sido cuidadosamente revisados, el autor no
garantiza que sean correctos en su totalidad, y no
aceptará responsabilidad por daños, lucro cesante o
cualquier otro evento que se produzca como consecuencia
de usar este libro. El autor agradecerá que se le
comunique cualquier error o inexactitud a la dirección
de la Editorial.</p>
<div class="line" id="introduccion">
<h3 class="calibre14">1. INTRODUCCION</h3>
<p class="calibre5">El lenguaje de máquina es el lenguaje propio de la
computadora. El Assembler (o más propiamente Assembly;
en castellano Ensamblador o Compaginador) es una
codificación simbólica que hace más accesible el
lenguaje de máquina.</p>
<p class="calibre5">La programación en Ensamblador o en lenguaje de
máquina tiene ventajas y desventajas con respecto a la
programación en un lenguaje de alto nivel, tal como
BASIC o COBOL. Las principales ventajas son el menor
espacio ocupado, la mayor velocidad obtenida, y el poder
hacer todo lo que permite la máquina. Las principales
desventajas son el mayor trabajo necesario y la dificultad para trasladar los programas a otro tipo de
máquina.</p>
<p class="calibre5">Muchas veces se dice que, para aprender Ensamblador,
es casi imprescindible conocer previamente otro lenguaje
de computación de alto nivel. La prueba de que esto no
es así consiste en que, en los albores de la computación, no existía otro lenguaje que no fuese el de máquina o su equivalente, el Ensamblador, y sin embargo los
programadores no tenían dificultades en aprenderlo.</p>
<p class="calibre5">Aunque el Ensamblador de 8086 es algo más complejo que
el de las primeras computadoras, la situación se mantiene, o sea que el conocimiento de un lenguaje de alto
nivel no es requisito indispensable para comprender el
Ensamblador.</p>
<p class="calibre5">Es no obstante necesario aclarar que, si bien en este
texto damos nociones generales de computación, el lector
se beneficiaría estudiando previamente los rudimentos de
la computación y la programación.</p>
<p class="calibre5">El Ensamblador de cada tipo de computadora es distinto a cualquier otro. El conocimiento de un Ensamblador
determinado no implica el de otro, aunque es cierto que
facilita su estudio.</p>
<p class="calibre5">Los procesadores 8086 y 8088 se diferencian entre sí
sólo en sus velocidades de operación y son completamente
idénticos desde el punto de vista del programador, por
lo que en lo sucesivo nos referiremos a cualquiera de
ellos como 8086.</p>
<p class="calibre5">La computación tiene una jerga que le es propia, en
su mayoría de origen anglosajón. En lo posible, cada vez
que introduzcamos un término específico de computación,
daremos tanto la versión española como la inglesa, pues
el lector debe familiarizarse con las distintas terminologías que encontrará en textos de diverso origen.</p>
<p class="calibre5">Los ejercicios incluidos en este texto no deben ser
considerados como optativos. Por lo contrario, muchas de
las técnicas de programación se explican en la solución
de los ejercicios.</p>
<div class="line" id="bases-de-la-computacion">
<h4 class="calibre29">1.1. Bases de la computación</h4>
<p class="calibre5">El concepto más general de computadora consiste en que
se trata de un aparato que manipula configuraciones de
bits.</p>
<p class="calibre5">Un bit o dígito binario es un elemento que tiene dos
estados posibles: apagado y encendido (en inglés on y
off), representados típicamente por los símbolos 0 y 1.
En este contexto, no debe pensarse en 0 y 1 como si se
tratase de números; sólo son rótulos que indican el
estado de un bit.</p>
<p class="calibre5">La memoria de una computadora consiste en un enorme
conjunto de bits, cada uno de los cuales puede estar en
uno de sus dos estados: 0 o 1.</p>
<p class="calibre5">El corazón de la computadora es un procesador (8086,
8088 u otro similar). Lo que hace este procesador es
manipular los bits que forman la memoria de la computadora, poniendo cada uno en su estado 0 o 1.</p>
<p class="calibre5">El procesador maneja los bits en grupos. Los dos
grupos de bits que el procesador maneja directamente
reciben nombres que los distinguen. Diremos que un
octeto o byte (pronúnciese bait) es un conjunto de 8
bits, y una palabra o word es un conjunto de 2 bytes, o
sea 16 bits. También existe el tipo doble palabra
(double word), que como su nombre lo indica se compone
de dos palabras. Al byte se lo conoce también como
carácter, aunque más propiamente “carácter” es el
contenido de un byte o su representación gráfica.</p>
<p class="calibre5">Un conjunto de bits contiene una configuración,
determinada por el estado de los bits individuales. Por
ejemplo, éstas son configuraciones que podría tener un
byte:</p>
<pre class="literal-block">
00000000   11111111   00001111   10111110   01101100
</pre>
<p class="calibre5">No es difícil calcular que las configuraciones distintas
que puede tener un byte son 28 = 256, y que las de una
palabra son 216 = 65.536.</p>
<p class="calibre5">La idea más importante de la programación en Ensamblador (y también en cualquier otro lenguaje) es la
siguiente: estas configuraciones de bits pueden ser
usadas para representar otros conjuntos de objetos,
haciendo corresponder a cada configuración un miembro
del otro conjunto.</p>
<p class="calibre5">Por ejemplo, haciendo que las configuraciones que
puede contener una palabra correspondan a miembros del
conjunto de los números enteros, pueden representarse ya
sea los números desde 0 hasta 65.535 o desde -32.768
hasta 32.767, dependiendo de la correspondencia particular que uno use. Podrían idearse muchas otras correspondencias, pero las dos que hemos señalado son las que se
usan más frecuentemente en computación y con las que
trabaja directamente el procesador.</p>
<p class="calibre5">Otro ejemplo importante: las configuraciones que
puede tomar un byte pueden ponerse en correspondencia
con una serie de pequeños dibujos elegidos arbitrariamente, que podrían ser impresos o mostrados en una
pantalla, y que solemos llamar caracteres. Mirando la
tabla que aparece como Apéndice B en este libro, y que
se llama Tabla ASCII, se podrá observar que contiene
exactamente 256 caracteres distintos. Eso sucede porque
la computadora usa un byte de memoria para indicarle a
la pantalla o a la impresora el carácter que debe
mostrarse.</p>
<p class="calibre5">Otra representación que podemos elegir para el
contenido de un byte son las aproximadamente 256 maneras
diferentes de manipular las configuraciones de bits que
tiene el procesador 8086 y que forman el grueso del
contenido de este libro.</p>
<p class="calibre5">Los dibujos que pueden obtenerse en una pantalla o en
una impresora son también representados por configuraciones de distintas cantidades de bits.</p>
<p class="calibre5">El punto principal que debe derivarse de esto es que
podemos usar configuraciones de bits para representar
cualquier cosa que deseemos, y que manipulando las
configuraciones de distintas maneras podemos obtener
resultados que tienen sentido en función de lo que hemos
elegido representar.</p>
</div>
<div class="line" id="una-representacion-mas-manuable">
<h4 class="calibre29">1.2. Una representación más manuable</h4>
<p class="calibre5">Dada su importancia, sería conveniente tener una manera
de representar las diferentes configuraciones de bits de
las que hemos estado hablando. Ya tenemos una manera:
listar los estados de los bits individuales como series
de ceros y unos. Sin embargo, este sistema es algo
incómodo y proclive a errores. Es más fácil dividirlas
en partes más manejables.</p>
<p class="calibre5">En algún momento se acuñó la palabra nibble (mordisco) para designar un conjunto de 4 bits (o sea 1/2
byte); percibir visualmente un nibble es fácil. Hay
solamente 24 = 16 configuraciones posibles para un
nibble.</p>
<p class="calibre5">Cada una de las 16 posibles configuraciones de un
nibble se representa convencionalmente por un símbolo.
Como en una pantalla o una impresora no pueden mostrarse
fácilmente otras configuraciones que no sean las 256 de
los caracteres ASCII (y aun menos), fue necesario elegir
los símbolos entre dichos caracteres; vemos así cómo un
mismo símbolo tendrá significados distintos según el
contexto en que se lo use.</p>
<p class="calibre5">A las primeras 10 configuraciones de un nibble se le
asignan los símbolos desde 0 hasta 9, y a las 6 restantes las letras desde A hasta F (incidentalmente, debemos
advertir que para este fin se usan indistintamente las
mayúsculas como las minúsculas desde a hasta f).</p>
<p class="calibre5">El código de nibbles es pues el siguiente:</p>
<pre class="literal-block">
0000 = 0
0001 = 1
0010 = 2
0011 = 3
0100 = 4
0101 = 5
0110 = 6
0111 = 7
1000 = 8
1001 = 9
1010 = A
1011 = B
1100 = C
1101 = D
1110 = E
1111 = F
</pre>
<p class="calibre5">En conjunto, los símbolos desde 0 hasta F reciben el
nombre de notación hexadecimal, y forman el sistema
numérico hexadecimal (en base 16).</p>
<p class="calibre5">Un byte se compone de dos nibbles, o sea dos dígitos
hexadecimales; por ejemplo, un byte podría contener los
dígitos hexadecimales D5.</p>
<p class="calibre5">Como muchas veces una configuración de bits escrita
en hexadecimal puede tener el mismo aspecto que un
número decimal, es a menudo necesario indicar la diferencia. La convención que usaremos en Ensamblador
consiste en añadir la letra H (mayúscula o minúscula
indistintamente) al final de la configuración, por
ejemplo 4210H.</p>
</div>
<div class="line" id="direccionamiento-de-la-memoria">
<h4 class="calibre29">1.3. Direccionamiento de la memoria</h4>
<p class="calibre5">Como se dijo antes, el procesador manipula las configuraciones de bits que forman la memoria de la computadora. Algunas de las manipulaciones posibles son: copiar
configuraciones de uno a otro lugar de la memoria;
encender o apagar bits determinados; efectuar operaciones aritméticas con las configuraciones. Para realizar
cualquiera de dichas acciones, el procesador debe “saber” sobre qué parte de la memoria trabajar.</p>
<p class="calibre5">La memoria está compuesta de bytes, cada uno de los
cuales está, por así decirlo, en una “casilla”. Las
casillas están numeradas desde 0 en adelante. A este
número asociado a cada byte se lo conoce como la
dirección del mismo.</p>
<p class="calibre5">Una dirección es un puntero a la memoria. Cada
dirección, pues, apunta al comienzo de una parte de la
memoria. El procesador 8086 tiene la capacidad de
distinguir 1.048.576 bytes distintos en la memoria, o
sea que puede manejar direcciones desde 0 hasta
1.048.575.</p>
<p class="calibre5">Estos números son de uso tan frecuente que, para
simplificar, se los expresa en K o Kb, que significa
Kilobyte. Un K equivale a 1.024. Se toma el valor 1.024
porque es una potencia entera de 2, exactamente 210.
Entonces, 65.536 es igual a 64K. Para números mayores,
se utilizan las siglas M o Mb, que significan Megabyte.
Un Megabyte equivale a 1.024 x 1.024 bytes = 1.048.576
bytes, y es igual a 220.</p>
<p class="calibre5">No debe sorprender que, como todo en el procesador,
las direcciones estén también representadas por configuraciones de bits. Se necesitan 20 bits para obtener
220 = 1.048.576 configuraciones distintas, y por
consiguiente una dirección puede ser escrita como una
serie de 20 bits (o sea 5 nibbles o dígitos hexadecimales).</p>
<p class="calibre5">Por ejemplo, A47B1 es una dirección compuesta de 5
dígitos hexadecimales. Esta dirección, A47B1, apunta a
una ubicación de memoria donde hay un byte con un
contenido determinado, por ejemplo los dos dígitos
hexadecimales 3C.</p>
<p class="calibre5">Ahora bien, el procesador 8086 maneja 8 o 16 bits a
la vez, no 20 como se requiere para una dirección. Por
lo tanto, es necesario cierto proceso para obtener
direcciones de 20 bits. Este proceso se basa en la
combinación de dos palabras (words): una palabra de
segmento y otra de desplazamiento (offset). El proceso
consiste en interpretar ambas configuraciones como
números hexadecimales y sumarlas, previamente desalineadas en un nibble, lo cual equivale a multiplicar la
palabra de segmento por 16. Por ejemplo:</p>
<pre class="literal-block">
4D20       Segmento, formado por 4 nibbles
 00A0      Desplazamiento, formado por 4 nibbles
----- 4D2A0      Dirección, formada por 5 nibbles
</pre>
<p class="calibre5">(La suma hexadecimal no siempre es tan fácil como la
anterior; por ejemplo:</p>
<pre class="literal-block">
00FA
 0112
---- 010B2
</pre>
<p class="calibre5">Más adelante la explicaremos en detalle).</p>
<p class="calibre5">En virtud de este mecanismo de calcular direcciones,
las veremos frecuentemente escritas en la forma
Segmento:Desplazamiento. La dirección vista antes se
escribiría:</p>
<pre class="literal-block">
4D20:00A0
</pre>
<p class="calibre5">Debemos advertir que una misma dirección absoluta puede
ser expresada de muchas maneras por la combinación de
segmento y desplazamiento. Por ejemplo, la dirección
anterior podría expresarse como 4C20:10A0, o 4D10:01A0,
o de muchas maneras más.</p>
</div>
<div class="line" id="contenido-de-la-memoria-datos-y-programas">
<h4 class="calibre29">1.4. Contenido de la memoria: datos y programas</h4>
<p class="calibre5">El contenido de la memoria puede ser clasificado en dos
tipos. Denominaremos datos al primero de ellos, consistente en configuraciones de bits que son manipuladas por
el procesador. El significado de las configuraciones
depende del fin para el que esté siendo usada la computadora en ese momento.</p>
<p class="calibre5">El segundo tipo de contenido de la memoria es conocido como instrucciones. El procesador puede tomar una
configuración de la memoria e interpretarla como especificación de una de las aproximadamente 200 operaciones
fundamentales que puede ejecutar. La correspondencia
entre configuraciones y operaciones es la base del
lenguaje de máquina. Un programa en lenguaje de máquina
consiste en una serie de instrucciones, o sea configuraciones ubicadas en direcciones consecutivas de la
memoria cuyas operaciones correspondientes ejecutan un
proceso útil.</p>
<p class="calibre5">Nótese que no hay manera de que el procesador determine que una configuración determinada significa una
instrucción o un fragmento de datos sobre el cual se
deba operar, pues la misma configuración puede representar una u otra cosa. Es perfectamente posible que,
por un error del programador, el procesador accidentalmente comience a leer e intentar ejecutar lo que se
había destinado a datos; en tal caso, suceden cosas
extrañas, y muy probablemente la máquina se “cuelgue”
cuando encuentre una configuración que no es una operación válida o que produce un error tal como intentar
dividir por 0.</p>
<p class="calibre5">En realidad, lo único que distingue una instrucción
de un dato es que la instrucción está siendo ejecutada
por el procesador.</p>
<p class="calibre5">Por otra parte, nótese que en algún momento las
instrucciones también fueron datos, pues de otra manera
no habrían podido ingresar en la memoria. Esta dualidad
programa - datos debe ser bien comprendida. Aunque hoy
día no es una práctica común, un programa puede actuar
sobre partes de sí mismo como si se tratara de datos.</p>
</div>
<div class="line" id="memoria-normal-ram-y-de-solo-lectura-rom">
<h4 class="calibre29">1.5. Memoria normal (RAM) y de sólo lectura (ROM)</h4>
<p class="calibre5">La mayor parte de la memoria de la computadora es de
tipo RAM (Random Access Memory, memoria de acceso
aleatorio). Esto significa que puede llegarse a cualquier punto de esta memoria independientemente del punto
anterior al que se haya tenido acceso; también indica
que el tiempo que se tarda en alcanzar cualquier punto
es independiente de su ubicación. Normalmente (enseguida
veremos la excepción), esta memoria RAM puede ser leída
y grabada con idéntica facilidad.</p>
<p class="calibre5">Una parte de esta memoria RAM es de tipo ROM (Read
Only Memory, memoria de lectura solamente), lo cual
indica que actualmente sólo puede ser leída; fue grabada
originalmente, cuando se fabricó la computadora. Como se
ve, no hay oposición entre RAM y ROM; ROM es sólo un
tipo de RAM que no se puede grabar. En la memoria ROM
hay grabados programas que se ejecutan cuando se enciende el equipo, y subrutinas (véase más adelante) de uso
general que son llamadas por programas residentes en
memoria RAM.</p>
</div>
<div class="line" id="el-nacimiento-del-ensamblador">
<h4 class="calibre29">1.6. El nacimiento del Ensamblador</h4>
<p class="calibre5">Para funcionar, el procesador necesita las configuraciones de bits que forman un programa en lenguaje de máquina. Sin embargo, para un ser humano estas configuraciones resultan abstrusas. Por ejemplo, la configuración
que indica al procesador que ponga en valor 0 todos los
bits del byte ubicado en la dirección 1234H (relativa a
cierto segmento) es:</p>
<pre class="literal-block">
C606341200
</pre>
<p class="calibre5">lo cual no es precisamente claro, aunque allí aparezca
algo parecido a la dirección 1234H y al valor 0.</p>
<p class="calibre5">En los primeros tiempos de la programación, las computadoras eran programadas laboriosamente, determinando
las configuraciones de bits que representaban las
instrucciones deseadas. Por supuesto, esta técnica era
tediosa y muy proclive a errores, por no hablar de las
dificultades para modificar un programa ya escrito. Pero
en algún momento surgió la idea de que la propia computadora podía encargarse de calcular las configuraciones
de bits, y así nació el Ensamblador.</p>
<p class="calibre5">En Ensamblador, cada uno de los diferentes códigos de
instrucción de la computadora es representado por un
código mnemotécnico, que consiste en una secuencia de
letras corta y fácil de recordar, relacionada con la
función que cumple.</p>
<p class="calibre5">Por otra parte, en Ensamblador es raro usar direcciones numéricas. Se las reemplaza por rótulos o símbolos
que inventa a su gusto el programador, y el Ensamblador
les asigna una dirección numérica.</p>
<p class="calibre5">Por ejemplo, en Ensamblador, el equivalente de la
instrucción vista antes es:</p>
<pre class="literal-block">
MOV   Dato, 0
</pre>
<p class="calibre5">estando el rótulo Dato definido así:</p>
<pre class="literal-block">
Dato   DB   ?
</pre>
<p class="calibre5">Eso es mucho más claro para el ser humano; pero lamentablemente, el procesador no puede interpretar la secuencia de caracteres MOV como instrucción, ni el rótulo
Dato como dirección. Es necesario un programa (que
podría correr en la misma computadora o en otra) para
convertir la secuencia MOV a C606 y el rótulo Dato a
3412 o a la dirección numérica adecuada. Es exactamente
este programa el que se llama Assembler, y el lenguaje
respectivo se conoce más propiamente como Assembly. El
Ensamblador toma en su entrada un programa escrito en
lenguaje Assembly y da como resultado un programa en
lenguaje de máquina.</p>
</div>
</div>
<div class="line" id="aritmetica-binaria-y-hexadecimal">
<h3 class="calibre14">2. ARITMETICA BINARIA Y HEXADECIMAL</h3>
<p class="calibre5">Para comprender adecuadamente el funcionamiento de la
aritmética en lenguaje de máquina, es necesario poseer
los conceptos de la aritmética binaria. Éstos no sólo no
son más difíciles que los de la aritmética decimal (la
usual), sino en realidad más fáciles.</p>
<div class="line" id="valor-posicional-de-los-bits">
<h4 class="calibre29">2.1. Valor posicional de los bits</h4>
<p class="calibre5">Los dígitos de un número en notación binaria tienen un
valor posicional, al igual que en la aritmética decimal.
Cada bit vale 0 o 1 multiplicado por 2n, donde n es su
posición a contar desde la derecha, con origen 0. Por
ejemplo, el número binario 01011101 vale:</p>
<div class="line-block1">
<div class="line">0x27  + 1x2<sup class="calibre30">6</sup> + 0x2<sup class="calibre30">5</sup> + 1x2<sup class="calibre30">4</sup> + 1x2<sup class="calibre30">3</sup> + 1x2<sup class="calibre30">2</sup> + 0x2<sup class="calibre30">1</sup> + 1x2<sup class="calibre30">0</sup> =</div>
<div class="line">0x128 + 1x64 + 0x32 + 1x16 + 1x8  + 1x4  + 0x2  + 1x1  = 93</div>
</div>
<p class="calibre5">Este método sirve para convertir un número binario en
decimal. En cuanto al proceso inverso, lo veremos a
continuación.</p>
</div>
<div class="line" id="conversion-de-decimal-a-binario">
<h4 class="calibre29">2.2. Conversión de decimal a binario</h4>
<p class="calibre5">La técnica para convertir un número decimal en binario
es la siguiente:</p>
<p class="calibre5">Divídase el número decimal por 2 y guárdese el resto
(0 o 1) como último dígito binario de la derecha. Divídase el cociente otra vez por 2, y guárdese su resto
como próximo dígito binario hacia la izquierda. Sígase
así hasta que el cociente sea 0.</p>
<p class="calibre5">Veamos un ejemplo en notación abreviada:</p>
<table border="1" class="docutils">
<colgroup class="calibre22">
<col width="50%" class="calibre23"/>
<col width="50%" class="calibre23"/>
</colgroup>
<thead valign="bottom" class="calibre27">
<tr class="calibre25"><th class="head">COCIENTES</th>
<th class="head">RESTOS</th>
</tr>
</thead>
<tbody valign="top" class="calibre24">
<tr class="calibre25"><td class="calibre26">93</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">46</td>
<td class="calibre26">0</td>
</tr>
<tr class="calibre25"><td class="calibre26">23</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">11</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">5</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">2</td>
<td class="calibre26">0</td>
</tr>
<tr class="calibre25"><td class="calibre26">1</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">0</td>
<td class="calibre26">0   -&gt; 01011101</td>
</tr>
</tbody>
</table>
<p class="calibre5">Dicho de otra manera, divídase el número por 2 (división
entera) y luego hágase lo propio con los cocientes sucesivos. A cada dividendo impar le corresponde un dígito
binario 1 y a cada dividendo par un dígito binario 0.
Los dígitos binarios (bits) se generan de derecha a
izquierda.</p>
</div>
<div class="line" id="suma-con-numeros-sin-signo">
<h4 class="calibre29">2.3. Suma con números sin signo</h4>
<p class="calibre5">Todos conocemos la tabla de sumar decimal. La tabla de
sumar binaria es la siguiente:</p>
<table border="1" class="docutils">
<colgroup class="calibre22">
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
</colgroup>
<thead valign="bottom" class="calibre27">
<tr class="calibre25"><th class="head"><ul class="first">
<li class="calibre3"></li>
</ul>
</th>
<th class="head">0</th>
<th class="head">1</th>
</tr>
</thead>
<tbody valign="top" class="calibre24">
<tr class="calibre25"><td class="calibre26">0</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">1</td>
<td class="calibre26">1</td>
<td class="calibre26">10</td>
</tr>
</tbody>
</table>
<p class="calibre5">En binario, uno más uno no es diez sino dos como en
decimal; lo que ocurre es que dos en binario se escribe
10. Si usáramos binario en la vida diaria, probablemente
serían otras las palabras para designar los números.</p>
<p class="calibre5">Cuando se trabaja simultáneamente con dos o más bases
numéricas, para evitar confusiones se indica con un
subíndice la base en la que está escrito el número.
Lógicamente, el subíndice debe estar escrito en una base
que no sea ambigua, y por lo tanto se lo escribe en
decimal. Por ejemplo, el número dos se escribe así en
decimal y en binario respectivamente: 210 y 102. Acá en
general no usaremos esta distinción, pues del texto
resultará claro en qué sistema de numeración estamos
trabajando.</p>
<p class="calibre5">Basándonos en la tabla anterior, probemos sumar dos
números en notación binaria, marcando los acarreos:</p>
<pre class="literal-block">
ACARREOS 0 1 1 1 0 1 0 0
_          0 1 0 1 0 1 1 0       (86)
_          0 1 1 1 0 1 0 1      (117)
_          ________________
_          1 1 0 0 1 0 1 1      (203)
</pre>
<p class="calibre5">Se invita al lector a realizar varias operaciones similares, verificando los resultados.</p>
<p class="calibre5">Las computadoras tienen acumuladores con una capacidad limitada. Cuando esta capacidad se excede, se dice
que ha habido un acarreo fuera del acumulador (carry
out). Por ejemplo, si la capacidad del acumulador es de
un byte (8 bits), tendremos en lo que sigue un ejemplo
de acarreo fuera:</p>
<pre class="literal-block">
ACARREOS 1 1 1 1 0 0 1 0
_          1 0 1 1 0 0 1 1      (179)
_          1 1 1 1 0 0 1 0      (242)
_          _______________
_       (1)1 0 1 0 0 1 0 1      (421) (165)
</pre>
<p class="calibre5">Si consideramos el bit que excedió la capacidad del
acumulador, el resultado es 421, pero si omitimos ese
bit, el resultado es 165, cuya relación con el resultado
correcto no es clara a primera vista, pero de cualquier
manera es lo que queda en el acumulador. Por lo tanto,
en la suma de números sin signo, el acarreo fuera puede
ser una señal de error o de que se debe continuar la
suma en otro acumulador.</p>
</div>
<div class="line" id="numeros-con-signo">
<h4 class="calibre29">2.4. Números con signo</h4>
<p class="calibre5">La tecnología de la computación y la facilidad de uso
han llevado a que, en la aritmética de números con
signo, no haya un bit especial para indicar el signo de
un número. Sencillamente se usa a tal fin el bit de más
alto orden (más a la izquierda) del número binario. Si
este bit es 0, el número es positivo (o cero, que se
considera positivo). Si el bit en cuestión es 1, entonces el número es negativo.</p>
<p class="calibre5">Esto no obsta para que, según los casos, un número se
considere positivo (sin signo) sin importar el valor de
su bit de orden más alto. Ello sucede, por ejemplo,
cuando el número es la parte inferior de otro más extenso, o cuando se lo usa como dirección.</p>
<p class="calibre5">La computadora tiene instrucciones para sumar y
restar que sirven tanto para números sin signo como para
números con signo, y efectivamente dan el mismo resultado. La diferencia surge en la interpretación de los
resultados, como veremos. En cambio, las instrucciones
de multiplicación y de división son distintas según se
trabaje con números con signo o sin signo.</p>
<p class="calibre5">Si tenemos un número positivo cualquiera en binario y
deseamos escribir el número negativo de igual valor
absoluto, podemos hacerlo con la siguiente secuencia de
operaciones:</p>
<ol class="upperalpha">
<li class="calibre3">Compleméntese el número binario; es decir, escríbase un 0 donde había un 1 y un 1 donde había un 0. El resultado de esta parte de la operación se conoce como complemento a 1.</li>
<li class="calibre3">Súmese 1 al resultado de la operación anterior, y deséchese el acarreo fuera del acumulador, si lo hay. El resultado final se conoce como complemento a 2.</li>
</ol>
<p class="calibre5">Veamos un ejemplo del procedimiento:</p>
<pre class="literal-block">
0 1 1 0 1 0 0 0      (+104)
1 0 0 1 0 1 1 1             Complemento a 1
0 0 0 0 0 0 0 1         (1) Se le suma 1
_______________
1 0 0 1 1 0 0 0      (-104) Complemento a 2
</pre>
<p class="calibre5">Este método también sirve para obtener el valor absoluto
de un número negativo. En resumen, lo que hace es invertir el signo. Hay dos excepciones: aplicado a 0, lo deja
como está, o sea que no invierte el signo, lo cual es
lógico pues no existe el cero negativo. La otra excepción se produce cuando se aplica al máximo número negativo posible; en este caso también lo deja invariable,
pero ello debe ser considerado como un error, pues no es
posible representar el número positivo igual al valor
absoluto del máximo negativo. Veamos esta última situación:</p>
<blockquote class="calibre31">
1 0 0 0 0 0 0 0      (-128) Máximo número negativo
0 1 1 1 1 1 1 1             Complemento a 1
0 0 0 0 0 0 0 1         (1) Se le suma
_______________
1 0 0 0 0 0 0 0      (-128)</blockquote>
<p class="calibre5">Este último número sería 128 si se lo considerara sin
signo, pero debemos tomar en cuenta que su bit de más
alto orden es 1, pues estamos interpretando los números
como con signo.</p>
<p class="calibre5">El procesador 8086 tiene dos instrucciones que obtienen respectivamente el complemento a 1 y el complemento
a 2 de un número.</p>
<p class="calibre5">Para quien desconfíe del procedimiento, sumaremos los
números binarios que representan +104 y -104 (el que
obtuvimos antes) de la misma manera que si se tratara de
números positivos:</p>
<pre class="literal-block">
ACARREOS 1 1 1 1 1 0 0 0
_          0 1 1 0 1 0 0 0      (+104)
_          1 0 0 1 1 0 0 0      (-104)
_          _______________
_          0 0 0 0 0 0 0 0         (0)
</pre>
<p class="calibre5">Vemos que, efectivamente, el resultado es 0. Pero hay un
acarreo que hemos debido desechar por no haber espacio
en los 8 bits. Esto es normal y no debe molestar. Sólo
en el caso de ser 0, la suma de un número y su complemento a 2 no produce acarreo.</p>
</div>
<div class="line" id="desborde-overflow">
<h4 class="calibre29">2.5. Desborde (overflow)</h4>
<p class="calibre5">Dada la representación elegida para los números negativos, es posible que la suma de dos números positivos dé
uno negativo o, a la inversa, que la suma de dos números
negativos dé uno positivo. Esta condición se denomina
desborde o exceso (overflow). El número de signo opuesto
obtenido no guarda relación aparente con el resultado
correcto de la operación.</p>
<p class="calibre5">El procesador determina si ha habido desborde comparando los acarreos desde la posición de más a la izquierda y desde la siguiente. Si ambos son iguales, no
hubo desborde. Si son distintos, hubo desborde. Veamos
algunos ejemplos:</p>
<pre class="literal-block">
_        0 0
ACARREOS 0 0 0 1 1 1 1 1
_        0 1 0 0 1 0 1 1      (+75)
_        0 0 0 1 0 1 1 1      (+23)
_        _______________
_        0 1 1 0 0 0 1 0      (+98)
</pre>
<p class="pri2">Ambos acarreos son 0 y por lo tanto iguales. No hubo
desborde.</p>
<pre class="literal-block">
_        1 1
ACARREOS 1 1 1 1 1 0 0 0
_        1 0 1 1 1 0 0 1      (-71)
_        1 1 1 0 1 1 0 0      (-20)
_        ---------------.
_        1 0 1 0 0 1 0 1      (-91)
</pre>
<p class="calibre5">Ambos acarreos son 1 y por lo tanto iguales. No hubo
desborde.</p>
<pre class="literal-block">
_        1 1
ACARREOS 1 1 1 0 1 1 1 0
_        0 0 1 0 1 1 1 1      (+47)
_        1 1 1 0 1 0 1 0      (-22)
_        ---------------.
_        0 0 0 1 1 0 0 1      (+25)
</pre>
<p class="calibre5">Ambos acarreos son 1 y por lo tanto iguales. No hubo
desborde. Nunca se produce desborde sumando dos números
de signo opuesto.</p>
<pre class="literal-block">
_        0 1
ACARREOS 0 1 1 1 0 0 0 0
_        0 1 0 1 1 1 0 0       (+92)
_        0 1 1 1 0 0 1 0      (+114)
_        ---------------.
_        1 1 0 0 1 1 1 0       (-50)
</pre>
<p class="pri2">Los dos acarreos son 0 y 1 respectivamente y por lo tanto distintos. Hubo desborde. El resultado correcto sería
206, que es la configuración 11001110 interpretada como
número sin signo. El valor -50 resulta igual a 206 - 256
(donde 256 = 2<sup class="calibre30">8</sup>).</p>
<pre class="literal-block">
_        1 0
ACARREOS 1 0 1 1 0 0 0 0
_         1 0 1 1 0 0 1 0      (-78)
_         1 0 0 1 1 1 0 1      (-99)
_         ---------------.
_         0 1 0 0 1 1 1 1      (+79)
</pre>
<p class="calibre5">Los dos acarreos son 1 y 0 respectivamente y por lo tanto distintos. Hubo desborde. El resultado correcto sería
-177, que es la configuración binaria 101001111 interpretada como número negativo. El valor 79 resulta igual
a 256 - 177.</p>
<p class="calibre5">En resumen, para determinar si se excedió la capacidad del acumulador en la suma de números con signo, debe
probarse la condición de desborde; en cambio, en la suma
de números sin signo, debe probarse la condición de
acarreo. Lo mismo ocurre con la resta, que veremos a
continuación.</p>
</div>
<div class="line" id="resta">
<h4 class="calibre29">2.6. Resta</h4>
<p class="calibre5">La mayoría de los textos reduce la resta binaria a la
suma binaria, realizando previamente la operación de
complemento a 2 con el sustraendo para cambiarle el
signo. En este texto adoptaremos un enfoque más directo,
que es el realmente usado por el procesador.</p>
<p class="calibre5">Antes dijimos que la tabla de sumar binaria era:</p>
<table border="1" class="docutils">
<colgroup class="calibre22">
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
</colgroup>
<tbody valign="top" class="calibre24">
<tr class="calibre25"><td class="calibre26">+</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">0</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">1</td>
<td class="calibre26">1</td>
<td class="calibre26">10</td>
</tr>
</tbody>
</table>
<p class="pri2">Podemos descomponer esta tabla en dos: una que determina
el bit del resultado (que llamaremos B) y otra el
acarreo correspondiente (que llamaremos C):</p>
<table border="1" class="docutils">
<colgroup class="calibre22">
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
</colgroup>
<tbody valign="top" class="calibre24">
<tr class="calibre25"><td class="calibre26">+ B</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">0</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">1</td>
<td class="calibre26">1</td>
<td class="calibre26">0</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup class="calibre22">
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
<col width="33%" class="calibre23"/>
</colgroup>
<tbody valign="top" class="calibre24">
<tr class="calibre25"><td class="calibre26">+ C</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">0</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
<tr class="calibre25"><td class="calibre26">1</td>
<td class="calibre26">0</td>
<td class="calibre26">1</td>
</tr>
</tbody>
</table>
<p class="calibre5">Si ahora consideramos que en cada par de bits correspondientes que sumamos también interviene el acarreo de la
posición anterior (que llamaremos CA), tendremos cuatro
tablas:</p>
<pre class="literal-block">
| +B | 0   1                  + C | 0   1
| -----------                  -----------.
|  0 | 0   1                    0 | 0   0
|                                            CA = 0
|  1 | 1   0                    1 | 0   1
|
|
| +B | 0   1                  + C | 0   1
| -----------                  -----------.
|  0 | 1   0                    0 | 0   1
|                                            CA = 1
|  1 | 0   1                    1 | 1   1
</pre>
<p class="pri2">Fácilmente podremos preparar tablas similares para la
resta, considerando no ya el <strong class="calibre4">acarreo (carry)</strong> sino el
<strong class="calibre4">pedido (borrow)</strong>, que seguiremos designando con la letra
C pues, como veremos más adelante, para el procesador
8086 son idénticos. (Esto no es así para otros procesadores como el 6502, que toma el pedido como negación del
acarreo). Designaremos el pedido anterior también con
CA.</p>
<p class="calibre5">Para la suma no necesitábamos hacerlo, pero para la
resta debemos distinguir entre los dos operandos. El
sustraendo aparecerá horizontalmente y el minuendo
verticalmente:</p>
<pre class="literal-block">
| \-B | 0   1                  - C | 0  1
| -----------                  -----------.
|  0  | 0   1                    0 | 0  1
|                                            CA = 0
|  1  | 1   0                    1 | 0  0
|
|
| - B | 0   1                  - C | 0  1
| -----------                  -----------.
|  0 | 1   0                    0 | 1   1
|                                            CA = 1
|  1 | 0   1                    1 | 0   1
</pre>
<p class="calibre5">Para restar en binario, entonces, usaremos la vieja
técnica de la escuela primaria, consistente en “pedir”
una unidad de orden superior cuando la resta correspondiente a un dígito sea negativa. Veamos un ejemplo
con los pedidos anotados:</p>
<pre class="literal-block">
|         0 0
| PEDIDOS 0 0 0 1 1 0 1 0
|           0 1 1 1 0 1 0 1      (+117)
|           0 1 0 1 1 0 1 1       (+91)
|           ---------------.
|           0 0 0 1 1 0 1 0       (+26)
</pre>
<p class="calibre5">Para determinar si hubo o no desborde, se comparan como
para la suma los dos “pedidos” de orden superior. En
este caso son iguales, por lo que no hubo desborde.</p>
<p class="calibre5">La operación de complemento a 2 puede también definirse como “restar de 0”. Confirmando lo visto en ocasión de explicar el complemento a 2, podemos verificar
que sólo en un caso se produce desborde: al complementarse el máximo número negativo, que con 8 bits es
10000000. El resultado es el mismo número, con una
indicación de desborde. El complemento a 2 en este caso
no puede dar un número positivo, puesto que tal número
no puede representarse. El máximo número negativo con 8
bits es 10000000<sub class="calibre32">2</sub> = -128<sub class="calibre32">10</sub>, y el máximo número positivo
es 01111111<sub class="calibre32">2</sub> = 127<sub class="calibre32">10</sub>.</p>
</div>
<div class="line" id="comparacion">
<h4 class="calibre29">2.7. Comparación</h4>
<p class="calibre5">El procesador 8086 realiza la comparación como una resta
en la cual el resultado se desecha, pero donde quedan
diversas indicaciones en la forma que oportunamente
veremos: si hubo desborde, si el signo del resultado es
negativo, si hubo acarreo fuera del acumulador, si el
resultado es 0, y otras.</p>
<p class="calibre5">Estas indicaciones permiten usar el resultado de la
comparación con dos interpretaciones distintas: como si
se tratara respectivamente de números con signo o sin
signo.</p>
<p class="calibre5">Si consideramos que los números no tienen signo, un
valor binario tal como 10110010 resulta mayor que otro
tal como 01011001, porque se toma el valor posicional de
cada bit sin que el de orden superior represente el
signo. Esta indicación queda almacenada como una señal
de acarreo fuera del acumulador; si es 0, el primer operando (minuendo) es mayor o igual al segundo (sustraendo), y si es 1, el primer operando es menor.</p>
<p class="calibre5">Si en cambio consideramos que los números tienen
signo, un valor binario tal como 10110010 resulta menor
que otro tal como 01011001, por ser el primero negativo
y el segundo positivo. Esta indicación queda almacenada
en las señales de signo del resultado y de desborde; si
ambas son iguales, el primer operando (minuendo) es mayor o igual al segundo (sustraendo), y si son distintas,
el primer operando es menor.</p>
<p class="calibre5">Se invita al lector a comprobar estas aseveraciones
planteando casos variados.</p>
</div>
<div class="line" id="desplazamiento-shift">
<h4 class="calibre29">2.8. Desplazamiento (shift)</h4>
<p class="calibre5">Nótese que la palabra castellana desplazamiento corresponde a dos conceptos afines pero distintos, que en la
jerga de computación anglosajona se llaman respectivamente offset y shift. El primero ya ha sido tratado.
Veremos ahora el segundo.</p>
<p class="calibre5">El procesador puede desplazar fácilmente hacia la
izquierda o hacia la derecha las configuraciones de bits
que representan números binarios.</p>
<p class="calibre5">Cuando se produce un desplazamiento hacia la izquierda, por la derecha se alimentan bits 0, y por la izquierda se pierden bits. Por ejemplo, 00010110 desplazado 2 bits a la izquierda es 01011000. Mientras que por
la izquierda no se pierdan bits 1, un desplazamiento de
n bits a la izquierda equivale a multiplicar el número
por 2<sup class="calibre30">n</sup>, como puede comprobarse fácilmente.</p>
<p class="calibre5">Similarmente, puede efectuarse un desplazamiento hacia la derecha. Hay dos formas para este desplazamiento:
la forma lógica, en la cual por la izquierda se alimentan bits 0, y la forma aritmética, en la cual se alimentan bits iguales al bit de signo (el de orden superior).
En la forma lógica, un desplazamiento a la derecha de n
bits equivale a dividir el número sin signo por 2<sub class="calibre32">n</sub>
(división entera, lo que significa truncar el cociente
hacia abajo). En la forma aritmética, sucede lo mismo
pero con el número considerado con signo; cuando el
número es negativo, la truncación del cociente también
ocurre hacia abajo, aunque en valor absoluto sea hacia
arriba. Por ejemplo, 00000011 (3) desplazado 1 bit a la
derecha da 00000001 (1), y 11111101 (-3) desplazado un
bit a la derecha da 11111110 (-2).</p>
<p class="calibre5">Volveremos sobre estas operaciones de desplazamiento
cuando tratemos más en profundidad el direccionamiento
con el procesador 8086 y cuando veamos las operaciones
de shift.</p>
<p class="pri2">2.9. Aritmética hexadecimal</p>
<p class="calibre5">Dada la estrecha correspondencia entre números binarios
y hexadecimales, en la cual grupos de 4 dígitos binarios
equivalen a un dígito hexadecimal, la aritmética hexadecimal se reduce fácilmente a la binaria.</p>
<p class="calibre5">Mostraremos la tabla de sumar hexadecimal, que es tan
simple como la decimal.</p>
<pre class="literal-block">
\+ |  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
---------------------------------------------------.
0 |  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
1 |  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 10
2 |  2  3  4  5  6  7  8  9  A  B  C  D  E  F 10 11
3 |  3  4  5  6  7  8  9  A  B  C  D  E  F 10 11 12
4 |  4  5  6  7  8  9  A  B  C  D  E  F 10 11 12 13
5 |  5  6  7  8  9  A  B  C  D  E  F 10 11 12 13 14
6 |  6  7  8  9  A  B  C  D  E  F 10 11 12 13 14 15
7 |  7  8  9  A  B  C  D  E  F 10 11 12 13 14 15 16
8 |  8  9  A  B  C  D  E  F 10 11 12 13 14 15 16 17
9 |  9  A  B  C  D  E  F 10 11 12 13 14 15 16 17 18
A |  A  B  C  D  E  F 10 11 12 13 14 15 16 17 18 19
B |  B  C  D  E  F 10 11 12 13 14 15 16 17 18 19 1A
C |  C  D  E  F 10 11 12 13 14 15 16 17 18 19 1A 1B
D |  D  E  F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C
E |  E  F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D
F |  F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E
</pre>
<p class="calibre5">Veamos su uso en una suma:</p>
<pre class="literal-block">
| ACARREOS 0 1 0 1
|            1 D E 2       (7650)
|            A B 0 F      (43791)
|            -------.
|            C 8 F 1      (51441)
</pre>
<p class="calibre5">Se ha considerado que estos números no tienen signo.</p>
</div>
<div class="line" id="orden-de-los-bytes-dentro-de-una-palabra-en-la-memoria">
<h4 class="calibre29">2.10. Orden de los bytes dentro de una palabra en la memoria</h4>
<p class="calibre5">Es necesario aclarar que el procesador 8086, cuando
interpreta palabras en la memoria, lo hace con sus bytes
en orden inverso. Así, el número hexadecimal 1DE2 no
aparecerá en ese orden en la memoria, sino como E21D.
Nótese que esto sucede sólo con los bytes dentro de una
palabra y no con los nibbles dentro de un byte.</p>
<p class="calibre5">En cuanto a las palabras dentro de las dobles palabras, en particular el procesador 8086 no lo tiene
definido, ya que no efectúa directamente aritmética de
doble palabra; pero por convención y por compatibilidad
con el procesador 80386 y siguientes se acepta que
también en este caso las palabras están en el orden
parte baja - parte alta dentro de una doble palabra. Por
lo tanto, un número hexadecimal tal como:</p>
<pre class="literal-block">
25AF78D0
</pre>
<p class="calibre5">debiera aparecer en la memoria como:</p>
<pre class="literal-block">
D078AF25
</pre>
<p class="calibre5">Los listados de operaciones en lenguaje de máquina que
genera el Ensamblador no muestran el código generado de
esta manera invertida sino que, para comodidad del
lector, lo hacen de la forma normal. No obstante, en la
memoria de la máquina los bytes aparecerán invertidos.</p>
<p class="calibre5">En la próxima entrega:</p>
<blockquote class="calibre31">
<div class="line-block1">
<div class="line">Seccion 3:</div>
<div class="line"><br class="line"/></div>
<div class="line">El procesador 8086/8088,</div>
<div class="line">3.1. Los registros,</div>
<div class="line">3.2. La Pila (stack),</div>
<div class="line">3.3. Interrupciones.</div>
<div class="line"><br class="line"/></div>
<div class="line">Sección 4:</div>
<div class="line"><br class="line"/></div>
<div class="line">Sintaxis del Ensamblador.</div>
</div>
</blockquote>
</div>
</div>
</div>
</div>

</div>

</body>
</html>
