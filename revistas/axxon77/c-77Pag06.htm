<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 77 - SECCIÓN: - Una mirada a la realidad</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="stylesheet.css"/>
<link rel="stylesheet" type="text/css" href="page_styles.css"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">Una mirada a la realidad</h1>
<p class="calibre5"><b class="calibre4">Eduardo Carletti</b></p><p class="calibre5"></p>
<div class="calibre1">
<p class="resumen">Negroponte fundó y dirige desde 1985 el
Laboratorio de Medios (Media Lab) del MIT
(Instituto de Tecnología de Massachussets).
Allí se realizan los estudios más avanzados
sobre las formas de comunicación futuras.
Hace pocos días estuvo en Buenos Aires, y
ya es conocida la triste anécdota del robo
de su billetera. Esperemos no haber quedado
en la memoria de este as de la tecnología
como simples ladrones irrespetuosos.</p>
<div class="line" id="el-futuro-del-libro">
<h2 class="indiceautor">EL FUTURO DEL LIBRO</h2>
<p class="calibre8">Nicholas Negroponte - 1996</p>
<img alt="" class="pri1" src="nnegroponte.png"/>
<p class="pcalibre pri">¿Qué pesa menos de una millonésima de onza, consume menos de
una millonésima de pulgada cúbica, retiene 4 millones de bits
y cuesta menos de 2 dólares? ¿Qué pesa más de medio kilo,
tiene más de 800 cm3, contiene menos de 4 millones de bits y
cuesta más de 20 dólares? La misma cosa: “Ser Digital” almacenado en un circuito integrado y “Ser Digital” publicado
como libro de tapa dura.</p>
<p class="calibre8">La pregunta más común que me hacen es, ¿por qué, Sr. Pantalones Digitales, escribió un libro? Los libros son terreno
de los románticos y humanistas, no de los inhumanos nerds. La
existencia de los libros es reconfortante para aquellos que
piensan que el mundo se está convirtiendo en un basurero digital. Verán, el acto de escribir un libro es evidencia de
que no todo está perdido para aquellos que leen a Shakespeare, van a la iglesia, juegan baseball, disfrutan del ballet,
o gustan de una buena caminata por el bosque. De cualquier
modo, ¿quién quiere leer el próximo libro de Michael Crichton, para no hablar de la Biblia, en pantalla? Nadie. De
hecho, el consumo de papel en los Estados Unidos subió de 70
kilos <em class="calibre11">per cápita</em> en 1980 a 105 kilos en 1993.</p>
<div class="line" id="no-es-un-libro-son-bits">
<h3 class="calibre24">No es un libro, son bits</h3>
<p class="calibre8">La palabra no se va a ninguna parte. De hecho, es y ha sido
una de las fuerzas más poderosas para moldear a la humanidad,
para bien y para mal. Santo Tomás dijo unas pocas palabras al
sur de la India hace casi 2000 años, y hoy la provincia sureña de Kerala es cristiana en un 25% en un país donde los
cristianos son menos del 1% de la población. No cabe duda de
que las palabras son poderosas, que siempre lo han sido y
siempre lo serán.</p>
<p class="calibre8">Pero, así como rara vez tallamos palabras en la roca hoy
en día, probablemente no imprimamos muchas en papel en el
futuro, por obligación. De hecho, el costo del papel (que
subió un 50% durante el año pasado), la cantidad de energía
humana requerida para moverlo, y el volumen de espacio necesario para almacenarlo hace que los libros tal como los conocemos sean el método menos óptimo para entregar bits. De
hecho, el arte de hacer libros no sólo es menos que perfecto
sino que probablemente sea tan relevante en el 2020 como lo
es la herrería hoy.</p>
</div>
<div class="line" id="no-son-bits-es-un-libro">
<h3 class="calibre24">No son bits, es un libro</h3>
<p class="calibre8">Y aún así los libros ganan por lejos como medio de interfase,
un lugar confortable donde los bits y la gente se encuentran.
Se ven y sienten genial, usualmente son livianos (más ligeros
que la mayoría de las computadoras portátiles), relativamente
baratos, fáciles de usar, de un atractivo acceso aleatorio,
y ampliamente disponibles para todos. ¿Por qué escribí un
libro? Porque ese es el medio de presentación que tiene mi
audiencia hoy. Y no es malo.</p>
<p class="calibre8">Podemos hojear, anotar y hacer “orejas” en sus páginas, y
hasta sentarnos o pararnos sobre ellos cuando necesitamos ser
un poquito más altos. Una vez me paré en mi laptop, y el
resultado fue horrible.</p>
<p class="calibre8">El libro fue inventado hace 500 años por Aldo Manuzio en
Venecia, Italia. El llamado formato de octava fue una desviación de los manuscritos previos a causa de que era manuable,
portátil y cabía en el bolsillo. También Manuzio fue pionero
en la numeración de páginas. Es raro cómo Gutenberg tiene
todo el crédito mientras que a Manuzio sólo lo conocen unos
pocos. Los Manuzios de hoy son una tropa de investigadores
buscando materiales capaces de producir displays manuables,
portátiles y de bolsillo para los PDAs (asistentes personales
digitales, un término acuñado por John Sculley hace cinco
años y uno de los más raros acrónimos). En general, estos esfuerzos fallan en el punto de la “libriedad”, porque el acto
de pasar las páginas es una parte indisputable de la experiencia del libro. En 1978, en el MIT, animamos en pantalla
el hojeo de las páginas y hasta generamos los sonidos del
papel. Lindo, pero sólo una imitación.</p>
<p class="calibre8">Un nuevo intento de Joe Jacobson en el Media Lab involucra
papel electrónico, un medio de alto contraste, bajo costo y
capacidad de lectura/escritura/borrado. Uniendo estas hojas
electrónicas símil pulpa una encima de la otra se tiene un
libro electrónico. Son bastante similares a páginas, y en
ellas se pueden descargar palabras, en cualquier tipografía,
en cualquier tamaño. Para los 15 millones de americanos que
quieren libros interminables, este será un regalo del cielo,
si Joe tiene éxito durante el siguiente par de años. Así que,
para aquellos de ustedes que no quieran ir a la cama con un
“Intel inside”, hay esperanzas. Este es el futuro probable de
los libros.</p>
</div>
<div class="line" id="el-modelo-predicho-no-trabajara">
<h3 class="calibre24">El modelo predicho no trabajará</h3>
<p class="calibre8">Cuando mis colegas y yo argumentamos que el medio masivo del
futuro será uno del que uno “extraiga” en lugar de uno que
sea “introducido” en uno, se nos dice: ¡Absurdo!</p>
<p class="calibre8">O peor. Esos negadores arguyen que un modelo de “extracción” no puede soportarse porque eclipsa la publicidad. Aunque ni siquiera estoy seguro de que eso sea cierto, supongamos que lo es y preguntémonos: ¿Qué medio masivo de hoy es
mayor que la TV americana y las industrias filmográficas
combinadas, no tiene propaganda y es verdaderamente, como
dice George Gilder, un medio de elección? La respuesta: los
libros.</p>
<p class="calibre8">En los Estados Unidos se publican más de 50.000 títulos
por año. Adivinen el número típico de copias publicadas por
título. Una casa mayor considera que alrededor de 5.000 es la
tirada más baja que puede soportar económicamente, mientras
que algunas de las empresas pequeñas consideran que 2.000
copias de un libro es una gran tirada. Sí, se imprimieron más
de 12 millones de copias de “The Firm”, la novela de John
Grisham, y la primer tirada del libro de Bill Gates fue de
800.000. Pero la media es mucho menor, y esos libros menos
masivos no carecen de importancia. Es sólo que interesan o
llegan a menos gente.</p>
<p class="calibre8">De modo que la próxima vez que piensen en la Web (que
duplica su tamaño cada 50 días) y se pregunten cómo se
sostienen económicamente tantos “sites” (hoy en día se agrega
una <em class="calibre11">homepage</em> cada 4 segundos), sólo piensen en los libros.
Pensarán que seguramente la mayor parte de esos <em class="calibre11">sites</em> de la
Web desaparecerán; ni hablar. Habrá más y más y, al igual que
las librerías, habrá público para todos ellos. En lugar de
preocuparse por el futuro del libro como estándar de papel,
piensen en él como bits: bits bestseller, bits especializados,
y bits de los nietos para los abuelos. Mientras tanto, algunos
de nosotros los investigadores trabajamos realmente duro para
hacer que se sientan bien y que sean leíbles, para convertirlos en algo con lo que puedan acurrucarse o llevar al trono.</p>
<hr class="docutils"/>
<p class="resumen">Clarke —como todos sabemos un reconocido
científico además de escritor de CF—  afirma
aquí que no se deberían descartar profecías
“científicas” de la CF y de la imaginería
popular sólo por el hecho de que no parecen
plausibles hoy: es una trampa en la que
cayeron muchos desde que existe la Historia,
quedando en el ridículo ante las generaciones
posteriores. También dice, inteligentemente,
que “Puede ser muestra de sabiduría ser
escéptico incluso del escepticismo”.</p>
</div>
</div>
<div class="line" id="los-riesgos-de-la-profecia">
<h2 class="indiceautor">LOS RIESGOS DE LA PROFECÍA</h2>
<p class="calibre8">Arthur C. Clarke</p>
<img alt="" class="pri1" src="aclarke.png"/>
<p class="pcalibre pri">Con monótona regularidad, hombres aparentemente competentes
han sentado las reglas sobre lo que es técnicamente posible o
imposible, y luego se ha probado que estaban completamente
equivocados, algunas veces cuando la tinta de sus lapiceras
todavía no se había secado. Al hacer un cuidadoso análisis,
parece que estas debacles caen en dos clases, a las que
llamaré Fallas de Nervio y Fallas de Imaginación.</p>
<p class="calibre8">Las Fallas de Nervio parecen ser las más comunes; ocurren
cuando, incluso dados todos los hechos relevantes, el que
intenta ser profeta no puede ver que los hechos lo conducen a
una conclusión inevitable. Algunas de estas fallas son tan
ridículas como increíbles.</p>
<p class="calibre8">Cuando fueron construidas las primeras locomotoras, los
críticos afirmaron gravemente que cualquiera que alcanzara la
impresionante velocidad de 30 millas por hora sufriría de
sofocación. Hace sólo 80 años, la idea de la luz eléctrica
doméstica fue la burla de todos los expertos. Cuando las
acciones de gas cayeron en picada en 1878 porque Thomas
Edison anunció que estaba trabajando en la lámpara incandescente, el Parlamento Británico formó un comité para considerar el tema. Los distinguidos testigos reportaron, en socorro
de las compañías de gas, que las ideas de Edison eran “suficientemente buenas para nuestros amigos transatlánticos…
pero indignas de la atención de hombres prácticos o científicos.”</p>
<p class="calibre8">Las más famosas Fallas de Nervio han ocurrido en los
campos de la aeronáutica y astronáutica. A comienzos del
siglo XX, los científicos fueron casi unánimes en declarar
que el vuelo de cosas más pesadas que el aire era imposible,
y que cualquiera que tratara de construir aeroplanos era un
loco.</p>
<p class="calibre8">Más recientemente, cuando fue develada la existencia de
las V-2, bombas-cohete con un alcance de 300 kilómetros, hubo
una considerable especulación acerca de los misiles intercontinentales, que fueron firmemente refutados por el Dr. Vannevar Bush, el general civil de la gestión de guerra científica
de los E.U.A., según un comité del Senado del 03/12/45.
Escuchen:</p>
<p class="calibre8">“La gente que ha escrito estas cosas que me indignan ha
estado hablando de misiles con un alcance de 4.500 kilómetros, lanzados de un continente a otro, cargando una bomba
atómica y dirigidos tan precisamente que podrían aterrizar
exactamente sobre cierto objetivo, como una ciudad.”</p>
<p class="calibre8">“Yo digo, técnicamente, que pienso que nadie en el mundo
puede hacer una cosa así, y presiento que no podrá ser hecho
en un largo período de tiempo… Quisiera que el público
Americano se saque esto de la cabeza.”</p>
<p class="calibre8">El resultado fue la más grande Falla de Nervio en toda la
historia. Frente a los mismos hechos, las tecnologías Rusa y
Americana tomaron caminos diferentes. Los Rusos, enfrentados
a la necesidad de tener un cohete de 200 toneladas, fueron
adelante y lo construyeron. Por el tiempo en que fue perfeccionado ya no fue necesario para cohetería intercontinental;
pero con él ganaron la carrera espacial.</p>
<p class="calibre8">De las muchas enseñanzas que se pueden sacar de este
pedazo de historia reciente, la que quiero enfatizar es la
siguiente: cualquier cosa que es teóricamente posible será
realizada, sin importar las dificultades técnicas, si se la
desea lo suficiente.</p>
<p class="calibre8">El segundo tipo de falla profética es menos censurable.
Las Fallas de Imaginación surgen cuando todos los hechos
asequibles son apreciados y ordenados correctamente, pero los
hechos realmente vitales no se han descubierto aún, y la
posibilidad de su existencia no es admitida.</p>
<p class="calibre8">Una celebrada Falla de Imaginación fue aquella en la que
persistió Lord Rutherford, el hombre que reveló la estructura
interna del átomo. Rutherford se rió de aquellos que predecían que nosotros podríamos dominar la energía contenida en
la materia. La primera reacción en cadena se inició en Chicago sólo cinco años después de su muerte, en 1937. El descubrimiento totalmente inesperado de la fisión del uranio lo
hizo posible.</p>
<p class="calibre8">He hecho una lista de los inventos y descubrimientos que
han sido anticipados y de aquellos que no lo han sido. Todos
los ítems listados como Los Inesperados ya han sido realizados o descubiertos.</p>
<p class="calibre8">Por el contrario, Los Esperados son conceptos que han
estado dando vueltas por cientos de miles de años. Algunos
han sido realizados, otros podrían serlo, otros podrían ser
imposibles. ¿Pero cuáles?</p>
<table border="1" class="docutils1">
<colgroup class="calibre25">
<col width="50%" class="calibre26"/>
<col width="50%" class="calibre26"/>
</colgroup>
<thead valign="bottom" class="calibre27">
<tr class="calibre28"><th class="head">LOS INESPERADOS</th>
<th class="head">LOS ESPERADOS</th>
</tr>
</thead>
<tbody valign="top" class="calibre29">
<tr class="calibre28"><td class="calibre30">Rayos X</td>
<td class="calibre30">Automóviles</td>
</tr>
<tr class="calibre28"><td class="calibre30">Energía nuclear</td>
<td class="calibre30">Máquinas voladoras</td>
</tr>
<tr class="calibre28"><td class="calibre30">Radio, TV</td>
<td class="calibre30">Motores a vapor</td>
</tr>
<tr class="calibre28"><td class="calibre30">Electrónica</td>
<td class="calibre30">Submarinos</td>
</tr>
<tr class="calibre28"><td class="calibre30">Fotografía</td>
<td class="calibre30">Naves espaciales</td>
</tr>
<tr class="calibre28"><td class="calibre30">Grabación del sonido</td>
<td class="calibre30">Teléfonos</td>
</tr>
<tr class="calibre28"><td class="calibre30">Mecánica cuántica</td>
<td class="calibre30">Robots</td>
</tr>
<tr class="calibre28"><td class="calibre30">Relatividad</td>
<td class="calibre30">Rayos de la muerte</td>
</tr>
<tr class="calibre28"><td class="calibre30">Transistores</td>
<td class="calibre30">Transmutación</td>
</tr>
<tr class="calibre28"><td class="calibre30">Masers, lasers</td>
<td class="calibre30">Vida artificial</td>
</tr>
<tr class="calibre28"><td class="calibre30">Superconductores, superfluidos</td>
<td class="calibre30">Inmortalidad</td>
</tr>
<tr class="calibre28"><td class="calibre30">Relojes atómicos, efecto Mösbauer</td>
<td class="calibre30">Invisibilidad</td>
</tr>
<tr class="calibre28"><td class="calibre30">Determinar la composición de los cuerpos estelares</td>
<td class="calibre30">Levitación, Teleportación</td>
</tr>
<tr class="calibre28"><td class="calibre30">Fechar el pasado (carbono 14)</td>
<td class="calibre30">Comunicación con los muertos</td>
</tr>
<tr class="calibre28"><td class="calibre30">Detectar planetas invisibles</td>
<td class="calibre30">Observar el pasado y el futuro</td>
</tr>
<tr class="calibre28"><td class="calibre30">La ionósfera, cinturón de Van Allen</td>
<td class="calibre30">Telepatía</td>
</tr>
</tbody>
</table>
<p class="calibre8">Los Esperados incluyen tanto cabales fantasías como especulación científica seria, porque la única manera de descubrir
los límites de lo posible es aventurarse un poco dentro de lo
imposible. Como una primera penetración en esta área, sugiero
analizar la cuestión de la invisibilidad.</p>
<p class="calibre8">La idea de invisibilidad, con todo el poder que podría
conferir a cualquiera que pudiera manejarla, es eternamente
fascinante; sospecho que es uno de los sueños privados más
comunes. Pero hace mucho tiempo que no aparece en la ciencia
ficción adulta, porque es un poco ingenuo para esta era
sofisticada. Sabe a mágico, lo cual está fuera de moda ahora.</p>
<p class="calibre8">Pero la invisibilidad no es uno de esos conceptos que
implican una violación obvia de las leyes de la naturaleza;
hay muchos objetos que sabemos que existen y no podemos ver.
Muchos gases son invisibles. Nunca he tenido el privilegio de
buscar un gran diamante en un tambor de agua, pero he buscado
unos lentes de contacto en el inodoro.</p>
<p class="calibre8">La transparencia es una propiedad muy inusual de unas
pocas sustancias excepcionales, proveniente de la disposición
interna de sus átomos. Si sus átomos fueran acomodados de
otra manera, podrían dejar de ser transparentes, y podrían no
ser más la misma sustancia. Usted no puede tomar un compuesto
cualquiera al azar y forzarlo a ser transparente. E inclusive, en el caso de que usted pudiera hacer eso con un determinado compuesto, le sería de poca ayuda para volverse un
Hombre Invisible, ya que hay miles de millones de compuestos
químicos increíblemente complejos en el cuerpo humano.</p>
<p class="calibre8">Además, las propiedades esenciales de algunos de ellos
están relacionadas con el hecho de no ser transparentes. Si
los compuestos sensibles a la luz en el fondo del ojo dejaran
de atrapar la luz, seríamos incapaces de ver; y si nuestra
carne fuera transparente, el ojo no funcionaría, ya que se
inundaría de radiación: no se puede hacer una cámara fotográfica de vidrio. Menos obvio es el hecho de que las reacciones
bioquímicas de las cuales depende la vida podrían quedar
desbalanceadas, o podrían cesar por completo. Un hombre que
logre ser invisible podría no sólo quedar ciego; podría
quedar muerto.</p>
<p class="calibre8">Algunos insectos y animales terrestres han desarrollado
remarcables poderes de camuflaje, pero su disfraz, siendo
fijo, sólo sirve en el entorno correcto. Los grandes maestros
de la impostura se encuentran en el mar. El lenguado y el
pulpo tienen un control casi increíble sobre los matices y
diseños de sus cuerpos y son capaces de cambiar de color en
pocos segundos cuando surge la necesidad. Un lenguado echado
sobre un tablero de damas reproducirá el mismo diseño de
cuadrados en su parte superior, e inclusive es reputado de
hacer un elogiable intento sobre la franela escocesa.</p>
<p class="calibre8">La habilidad de coincidir con la escena que hay detrás de
uno podría ser un tipo de seudotransparencia, pero engañaría
sólo a observadores que miran desde una sola dirección. Funciona con el lenguado porque es un pez chato y está tratando
de evitar a predadores que nadan encima de él.</p>
<p class="calibre8">Otro método concebible de adquirir invisibilidad es por
medio de vibraciones. La invisibilidad vibracional está
basada en una analogía familiar: todos hemos visto que las
paletas de un ventilador se desvanecen cuando el motor
adquiere velocidad. Bien, suponga que se pudiera hacer vibrar
u oscilar a una frecuencia suficientemente alta a todos los
átomos de nuestro cuerpo.</p>
<p class="calibre8">La analogía es falaz, por supuesto. Nosotros no vemos a
través de las paletas del ventilador: a cada momento una
parte del fondo queda al descubierto, y a velocidades suficientemente altas la persistencia de la visión nos da la
impresión de que tenemos una vista continua. Si las paletas
se superpusieran permanecerían opacas sin importar cuan
rápido estuvieran girando.</p>
<p class="calibre8">Y hay otra desafortunada complicación. Vibración significa
calor —de hecho <em class="calibre11">es</em> calor— y nuestras moléculas y átomos ya
se están moviendo tan rápido como podemos soportarlo. Por lo
tanto, un hombre podría quedar cocinado antes de llegar a
vibrar lo suficiente para hacerse invisible.</p>
<p class="calibre8">La situación no luce promisoria; pero ahora viene una
sorpresa: quizás nos hemos aproximado desde un ángulo equivocado. La invisibilidad objetiva podría ser imposible, pero la
subjetiva es posible y ha sido demostrado con frecuencia.</p>
<p class="calibre8">Un hipnotizador experto puede inducir por sugestión
poshipnótica lo que es conocido como alucinación óptica
negativa. Esto significa que el sujeto será incapaz de ver a
cierta persona, incluso si esa persona está totalmente a la
vista; el individuo bajo hipnosis podría eventualmente
volverse histérico si, por ejemplo, viera lo que él cree
objetos sueltos —como un vaso de champagne— moviéndose por
el cuarto, llevados, por supuesto por la persona invisible.</p>
<p class="calibre8">Este hecho es por lo menos tan sorprendente como podría
serlo la invisibilidad genuina, y esto sugiere que una
persona u objeto podría ser hecho efectivamente invisible
ante un gran número de personas, que estarían totalmente
seguras de hallarse en plena posesión de sus sentidos. He
dado esta idea con alguna timidez; pero tengo el presentimiento de que si la invisibilidad se alcanza alguna vez, será
en este sentido.</p>
<p class="calibre8">Y he dado, con un poco menos de timidez, la sugerencia de
que tenemos aquí un caso en el que hay una espléndida oportunidad para una Falla de Imaginación. La imaginación puede
haber fallado en el hecho de haber dejado para el final de
nuestro examen la invisibilidad subjetiva; ahí fue donde fue
grande la tentación de declarar categóricamente “esto no
puede hacerse”. A decir verdad, las probabilidades de que
nunca se logre son abrumadoras, pero al menos he mostrado un
modo en que podría ser hecho. Pueden ponerse en contacto
conmigo para el Premio Nobel a través de la revista Playboy.</p>
<p class="calibre8">¿Y qué pasa entonces con la teleportación, levitación y
otros ítems de la lista de cosas esperadas pero aún no realizadas? A través de mi búsqueda en los límites de lo posible,
he tenido presente un riesgo primario: los peligros de la
incredulidad, puesto que, dando un vistazo a la lista de
Inesperados, observo algunos ítems que sólo diez años atrás
hubiera clasificado como imposibles. Incluso mientras escribo
estas palabras mi cuerpo es rociado por billones de partículas que no puedo ver ni sentir. Algunas de ellas —insospechadas hace pocos años— están pasando como un viento
silencioso a través del sólido núcleo de la Tierra. Viendo
maravillas como esta, la incredulidad resulta depurada; y
puede ser muestra de sabiduría ser escéptico incluso del
escepticismo.</p>
<div class="line-block">
<div class="line">(Artículo publicado originalmente en Playboy)</div>
<div class="line">Seleccionado y traducido para Axxón por José M. Acosta</div>
</div>
<hr class="docutils"/>
<p class="resumen">La Revista Virtual de Informática que se esconde dentro de la panza de Axxón es el último reducto de resistencia de los informáticos inteligentes</p>
</div>
<div class="line" id="revista-virtual-de-informatica">
<h2 class="indiceautor">REVISTA VIRTUAL DE INFORMATICA</h2>
<p class="calibre8">Ricardo M. Forno - 1996</p>
<div class="line" id="lenguaje-ensamblador-8086-8088-parte-5">
<h3 class="calibre24">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 5)</h3>
<p class="calibre8">Cómo adentrarse en el alma de la PC</p>
<p class="calibre8">Ing. Ricardo M. Forno</p>
<p class="calibre8"><strong class="calibre4">10. Práctica del lenguaje y técnicas avanzadas</strong></p>
<p class="calibre8">El desarrollo de los ejercicios no se encuentra en el texto
principal sino en SOLUCIONES (pág. 301), para que el lector
pueda intentar primero la solución por sí mismo; es necesario
estudiar los desarrollos antes de proseguir con el resto del
texto.</p>
<p class="calibre8"><strong class="calibre4">10.1. Ejercicio nº 8</strong></p>
<p class="calibre8">Se trata de poner en una cadena de caracteres la representación binaria de una palabra en memoria. Para hacer esto, es
necesario poner un carácter “0” por cada bit 0 y un carácter
“1” por cada bit 1.</p>
<p class="calibre8"><strong class="calibre4">10.2. Ejercicio nº 9</strong></p>
<p class="calibre8">La siguiente es una tarea similar a la anterior. Ahora se
trata de traducir una cadena de caracteres a su representación hexadecimal. La longitud de esta segunda cadena será el
doble de la de origen. Suponemos que la longitud es fija de
80 caracteres.</p>
<p class="calibre8"><strong class="calibre4">10.3. Ejercicio nº 10</strong></p>
<p class="calibre8">Con más experiencia en el uso del Ensamblador, es posible
ahora encarar un ejercicio que tiene algunas dificultades de
lógica. Se sugiere especialmente realizar un diagrama de
flujo y analizarlo cuidadosamente.</p>
<p class="calibre8">La tarea consiste en eliminar blancos múltiples e iniciales de una cadena, en forma similar al Ejercicio nº 3 en el
cual eliminábamos todos los blancos. De más está decir que
tanto en éste como en el nº 3 es posible reemplazar el carácter “blanco” por cualquier otro que se desee.</p>
<p class="calibre8">La longitud de la cadena es fija de 100 caracteres.</p>
<p class="calibre8"><strong class="calibre4">10.4. Otra instrucción de bifurcación condicional</strong></p>
<p class="calibre8">Además de las instrucciones de bifurcación condicional ya
vistas, que prueban una o más banderas, existe una que prueba
el contenido del registro CX. Su código es JCXZ, y bifurca en
caso de que el contenido del registro CX sea 0. No existe
instrucción que bifurque por la condición opuesta, es decir,
que CX no contenga 0.</p>
<p class="calibre8">En varios ejercicios hemos usado esta secuencia (o
similar):</p>
<pre class="literal-block">
|        and     cx, cx              ; O también cmp cx, 0
|        jz      Fin
</pre>
<p class="pcalibre pri">Con esta nueva instrucción, reemplazaríamos dicha
secuencia por:</p>
<pre class="literal-block">
|        jcxz    Fin
</pre>
<p class="calibre8"><strong class="calibre4">10.5. Una técnica para hacer más eficientes los ciclos</strong></p>
<p class="calibre8">Hemos visto en varios ejercicios que los ciclos pueden ejecutarse más eficientemente haciendo que las direcciones se
muevan en forma descendente. En muchos casos es indiferente
el sentido en que se muevan las direcciones, y en tales
ocasiones puede aplicarse dicha técnica sin inconvenientes.
Pero en otros casos es necesario que las direcciones se
muevan en forma ascendente. Cabe entonces preguntarse si no
habrá una forma de lograr más eficiencia en el ciclo con
direcciones ascendentes. Esta técnica existe, aunque es algo
más compleja que para el caso de direcciones descendentes. La
llamaremos incremento hasta 0:</p>
<ol class="upperalpha">
<li class="calibre3">En el caso de longitud de datos fija, en la instrucción
que toma los datos se usa un OFFSET de DATO + LONGITUD
y un registro índice o base. El registro se carga
inicialmente con el valor de - LONGITUD, se lo incrementa
con INC (o ADD, si el incremento fuera de más de una
unidad), y se prueba su valor por 0 para terminar el
ciclo.</li>
<li class="calibre3">En el caso de longitud de datos variable, se usan un
registro base y un registro índice. Uno de ellos se
carga con el valor de DATO + LONGITUD y se lo deja así
durante todo el ciclo. El otro se carga inicialmente
con el valor de - LONGITUD, se incrementa con INC o
ADD, y se prueba su valor por 0 para terminar el ciclo.
La instrucción que toma los datos empleará ambos
registros. También es posible tener en esta instrucción el
OFFSET de DATO y cargar uno de los registros con
LONGITUD en lugar de DATO + LONGITUD.</li>
</ol>
<p class="calibre8">Obsérvese que esta técnica es posible porque, si bien los
desplazamientos son por definición positivos, los valores
grandes de sus componentes (OFFSET, registros base e índice)
actúan como negativos de acuerdo con el procedimiento de
cálculo de direcciones, que funciona módulo 216 para el
desplazamiento.</p>
<p class="calibre8"><strong class="calibre4">10.6. Ejercicio nº 11</strong></p>
<p class="calibre8">Se pide usar la técnica del apartado anterior para el problema planteado en el Ejercicio nº 3, o sea eliminar los blancos
de un texto, en dos versiones, una para longitud fija y otra
para longitud variable.</p>
<p class="calibre8"><strong class="calibre4">10.7. Ejercicio nº 12</strong></p>
<p class="calibre8">Se pide buscar un argumento en una tabla cuyos elementos de
búsqueda no están ordenados, y lo mismo cuando los elementos
están ordenados, aprovechando el orden. Los argumentos ocupan
un byte, los resultados una palabra. En caso de no encontrarse el argumento en la tabla, el resultado será 0. En SOLUCIONES se ve tanto el caso de tabla no ordenada como el de
tabla ordenada.</p>
<p class="calibre8"><strong class="calibre4">10.8. Una técnica para hacer más eficiente la búsqueda en tabla</strong></p>
<p class="calibre8">En una búsqueda en tabla como las que hemos mostrado, son
necesarias dos comparaciones y otras tantas bifurcaciones
dentro del ciclo principal: una para ver si se encontró el
argumento, y otra para verificar que no se haya llegado al
fin de la tabla. Sería deseable eliminar una de ellas, aun a
costa de agregar instrucciones fuera del ciclo.</p>
<p class="calibre8">Logramos esto reordenando los datos, de modo que el argumento de búsqueda quede como si fuera el último elemento de
la tabla. De esta manera no hace falta verificar si se llegó
al fin de la tabla, porque si no se encuentra dentro de ella
un elemento de búsqueda igual al argumento, por fuerza ha de
terminar el ciclo por igualdad al encontrar el propio argumento al final de la tabla. Esto se llama “poner un centinela”.</p>
<p class="calibre8"><strong class="calibre4">10.9. Ejercicio nº 13</strong></p>
<p class="calibre8">Se pide modificar el ejercicio anterior usando la técnica recién explicada. Sólo mostramos la versión para tabla ordenada
en SOLUCIONES.</p>
<p class="calibre8"><strong class="calibre4">10.10. Ejercicio nº 14</strong></p>
<p class="calibre8">Este ejercicio es similar al anterior, con la diferencia de
que tanto el argumento como los elementos de búsqueda de la
tabla ocupan 10 bytes cada uno. Se pide usar en la comparación la técnica de incremento hasta 0 explicada oportunamente. Es necesario que la comparación proceda por direcciones
ascendentes porque no sólo debe comprobar igualdad o desigualdad sino ver si el argumento es menor o mayor que el elemento de tabla, ya que trabajamos con tabla ordenada, y la
comparación debe ser lexicográfica (orden alfabético).</p>
<p class="calibre8"><strong class="calibre4">11. Subrutinas</strong></p>
<p class="calibre8">Cuando se requiere ejecutar repetidas veces la misma tarea,
posiblemente con distintos datos, se recurre a las rutinas o
subrutinas (ambos términos son prácticamente sinónimos), como
se hace en lenguajes tales como BASIC, FORTRAN, etc. Aunque
la tarea no deba ser ejecutada varias veces, las subrutinas
son también útiles para transferir partes de un programa a
otro, y para simplificar la lógica de un programa al separarla en varias partes.</p>
<p class="calibre8">Las instrucciones que se usan a este fin son CALL (llamar)
y RET (return, retornar).</p>
<p class="calibre8">Veamos por medio de un ejemplo cómo actúan las subrutinas
con el Ensamblador:</p>
<pre class="literal-block">
|      1000      mov ch, 8  &gt;&gt;&gt;     1110      Abs:    cbw
|      1002      mov al, -5         1111              xor al, ah
|      1004      call Abs &gt;&gt;        1113              sub al, ah
|      1007      mov ah, 2 &lt;&lt;&lt;&lt;     1115              ret
|      1009      int 21h
</pre>
<p class="calibre8">La instrucción CALL Abs llama a la subrutina que comienza con
el rótulo Abs. La instrucción RET retorna a la instrucción
que sigue a CALL.</p>
<p class="calibre8">CALL efectúa un PUSH implícito del registro IP (Instruction Pointer, apuntador a instrucción) en la Pila. RET efectúa un POP implícito desde la Pila al IP. El SP es alterado
tanto por el PUSH como por el POP (véanse las descripciones
de PUSH y POP).</p>
<pre class="literal-block">
|      |----|
|      |1007| &lt;— SP después del CALL
|      |----|
|      |    | &lt;— SP antes del CALL y después del RET
|      |----|
</pre>
<p class="calibre8">El CALL puede ser near (cercano), que es el que se ha descrito, y far (lejano). En este último caso el RET también debe
ser lejano; se guarda y se recupera de la Pila no sólo el IP
sino también el CS. Los nuevos valores de CS e IP forman
parte de la instrucción CALL en formato lejano.</p>
<p class="calibre8"><strong class="calibre4">11.1. Ejemplo simple de subrutina</strong></p>
<p class="calibre8">Mostraremos una subrutina que despliega una cadena de caracteres terminada por un carácter nulo (valor 0). Veremos también el programa que la llama 2 veces. Esta forma de indicar
el fin de una cadena de caracteres es estándar en el lenguaje
C, y se denomina ASCIIZ.</p>
<pre class="literal-block">
| ; Programa que llama a la subrutina de ejemplo
|            .MODEL   small
|            .STACK   100h
|            .DATA
| Mensaje1  DB   '¡Hola, mundo!', 13, 10, 0   ; Termina en nulo
| Mensaje2  DB   '¡Hola, universo!', 13, 10, 0
|            .CODE
| Programa  PROC   near                ; Procedimiento
|            mov    ax, @data           ; Apuntar DS a datos
|            mov    ds, ax
|            mov    bx, OFFSET Mensaje1 ; Pasar parámetro
|            call   Mostrar             ; Llamar a la subrutina
|            mov    bx, OFFSET Mensaje2 ; Pasar parámetro
|            call   Mostrar             ; Llamar a la subrutina
|            mov    ah, 4ch             ; Función de terminación
|            int    21h                 ; Llamar al DOS
| Programa  ENDP                       ; Fin del procedimiento
|
| ; Subrutina que muestra una cadena de caracteres terminada
| ;  por un carácter NULL (valor ASCII 0).
| ; ENTRADA:   BX apunta a la cadena
| ; La subrutina destruye AH, BX y DL
| Mostrar   PROC   near                ; Procedimiento
| Otra:
|            mov    dl, [bx]            ; Tomar carácter
|            and    dl, dl              ; Ver si es nulo
|            jz     Termina
|            inc    bx                  ; Ir al próximo carácter
|            mov    ah, 2               ; Función de despliegue
|            int    21h                 ; Llamar al DOS
|            jmp    Otra                ; Repetir hasta nulo
|
|
|
| Termina:
|            ret                        ; Retornar
| Mostrar   ENDP                       ; Fin del procedimiento
|            END    Programa            ; Fin del programa
</pre>
<p class="calibre8">La función 2 de la interrupción 21h para el DOS despliega en
la pantalla el carácter que está en el registro DL.</p>
<p class="calibre8">Es posible modificar la subrutina de manera tal que preserve los registros AH, BX y DL en lugar de destruirlos. Para
ello, es necesario agregar las siguientes instrucciones
después del rótulo Otra:</p>
<pre class="literal-block">
|           push   ax
|           push   bx
|           push   dx
</pre>
<p class="calibre8">y estas otras antes de RET:</p>
<pre class="literal-block">
|           pop   dx
|           pop   bx
|           pop   ax
</pre>
<p class="calibre8">Las directivas PROC y ENDP señalan respectivamente el comienzo y el fin de un procedimiento, o sea una subrutina. Además,
PROC indica el tipo de llamadas (CALL) y retorno (RET). Si el
procedimiento es near (cercano), las llamadas al mismo y los
retornos desde el mismo serán cercanos (o sea que sólo efectuarán PUSH y POP del IP). Si el procedimiento es far (lejano), las llamadas y los retornos serán lejanos (o sea que
efectuarán PUSH y POP de CS además de IP). Esto sirve para
llamar subrutinas cuya distancia a la instrucción de llamada
supere los 65.535 bytes, pero también puede usarse para distancias más cortas, desconocidas o indefinidas.</p>
<p class="calibre8">Es perfectamente posible escribir subrutinas sin declararlas como procedimientos, dejando que la directiva .MODEL
indique si las llamadas son lejanas o cercanas (con .MODEL
small, las llamadas serán cercanas), pero es buena práctica
señalar con PROC y ENDP los límites y características de las
subrutinas y programas que las usan.</p>
<p class="pcalibre pri"><strong class="calibre4">11.2. Cómo pasar parámetros</strong></p>
<p class="calibre8">Es necesario establecer convenciones sobre cómo se pasan
parámetros a una subrutina. Existen varias formas típicas de
hacerlo:</p>
<p class="pcalibre pri">A) Parámetros en los registros</p>
<p class="calibre8">Si los parámetros ocupan un byte o una palabra, y no son
muchos, se los puede pasar en los registros. Por ejemplo, una
subrutina puede especificar que recibe el primer parámetro en
el registro AL y el segundo en el BX.</p>
<p class="calibre8">B) Direcciones de los parámetros en los registros</p>
<p class="calibre8">Es el caso de la subrutina del ejemplo anterior, que
recibe en el registro BX la dirección de la cadena sobre la
que operará. Esta vez se pasa el desplazamiento, estando el
segmento implícito, pero se podría pasar ambos. Esta técnica
es útil cuando los parámetros ocupan más de una palabra.</p>
<p class="calibre8">Las rutinas del DOS que procesan las interrupciones usan
las dos convenciones anteriores.</p>
<p class="calibre8">C) Parámetros en la Pila</p>
<p class="calibre8">Es una técnica útil cuando los parámetros ocupan una
palabra o menos pero son muchos. El programa de llamada
inserta los parámetros en la Pila mediante PUSH. La subrutina
los toma mediante POP o usando el registro BP. Si la
subrutina no efectúa los POP correspondientes, esta tarea le
queda al programa llamador, que puede hacerla con POP o
modificando el SP. La rutina también puede modificar el SP o
usar un formato especial de la instrucción RET, con un
operando que especifica el número de bytes que se liberarán
en la Pila.</p>
<p class="calibre8">D) Direcciones de los parámetros en la Pila</p>
<p class="calibre8">Se usa esta técnica cuando los parámetros ocupan más de
una palabra y son muchos. Los detalles de manejo son
similares a los del punto anterior.</p>
<p class="calibre8">E) Variables de memoria de uso común</p>
<p class="calibre8">En general, esta técnica no se usa, pues no permite la
independencia de nombres entre el programa llamador y la
subrutina, y dificulta la compaginación separada de ambos,
obligando a usar rótulos externos. Además, esto impide que la
subrutina se use en forma recursiva o reentrante (una
subrutina usada recursivamente se llama a sí misma directa o
indirectamente; una subrutina usada en forma reentrante puede
ser interrumpida y llamada otra vez durante la interrupción
por el mismo u otro programa, lo que se usa en multiprogramación y multiprocesamiento).</p>
<p class="calibre8">F) Banderas</p>
<p class="calibre8">Algunos datos que sólo ocupan un bit pueden transmitirse a
través de las banderas.</p>
<p class="calibre8">G) Combinación de las anteriores</p>
<p class="calibre8">Es necesario destacar una diferencia entre los distintos
métodos de transmisión: si lo que se transmite son los valores de los parámetros, como en los casos A y C anteriores, la
subrutina podrá usar estos valores pero no modificar los
parámetros originales (de donde se tomaron los valores). En
cambio, transmitiendo direcciones como en los casos B y D, la
rutina podrá modificar los parámetros, pues por medio de las
direcciones puede leer o grabar los mismos.</p>
<p class="calibre8"><strong class="calibre4">11.3. Cómo preservar los registros</strong></p>
<p class="calibre8">Si bien es factible desentenderse del problema, meramente
indicando en las especificaciones de la subrutina qué registros altera tal como hicimos en el ejemplo, es habitual la
exigencia de que la subrutina preserve el contenido de los
registros del programa llamador.</p>
<p class="calibre8">Los registros cuyo contenido sea alterado por la subrutina
deben salvarse al entrar a la misma, y restaurarse a la salida. En general, esta precaución no se toma con el registro ST
(banderas). Sin embargo, como veremos más adelante en algunos
ejercicios, lo correcto sería preservar si no todas por lo
menos algunas de estas banderas. Nos referimos específicamente a las banderas de dirección (DF), de trampa (TF) y de
interrupción (IF). Las restantes banderas (OF, ZF, SF, CF, AF
y PF) se colocan con gran cantidad de instrucciones y no tiene mayor sentido preservarlas, pero si se lo desea es posible
hacerlo.</p>
<p class="calibre8">El contenido de los registros del programa llamador puede
ser preservado por:</p>
<ol class="upperalpha">
<li class="calibre3">La subrutina</li>
<li class="calibre3">El propio programa llamador</li>
</ol>
<p class="calibre8">Lo más común es que lo haga la subrutina, pues eso es más
económico en espacio. En efecto, la subrutina puede ser
llamada varias veces, y si el programa llamador salvara los
registros, debería incluir las instrucciones al efecto en
cada lugar en que efectúe la llamada. Sin embargo, también
hay argumentos en favor de que lo haga el programa llamador:
el programador sabe el contenido de qué registros va a usar
nuevamente, y puede reducirse a salvar sólo éstos y no todos
los que destruya la subrutina. Lo cierto es que en general se
adopta la primera solución, probablemente porque la subrutina
se usará en varios programas y consecuentemente requiere una
programación más cuidadosa.</p>
<p class="calibre8">Hay dos maneras de guardar el contenido de los registros:</p>
<ol class="upperalpha">
<li class="calibre3">En variables de memoria al efecto</li>
<li class="calibre3">En la Pila</li>
</ol>
<p class="calibre8">La solución generalmente adoptada es la última, pues es
más económica en tiempo y en espacio.</p>
<p class="calibre8">Nótese que si la subrutina salva los registros en la Pila,
no podrá recuperar parámetros de la Pila mediante POP (pues
los registros quedarán arriba de los parámetros), y deberá en
cambio usar el registro BP, que es el método usual.</p>
<p class="calibre8">Para que una subrutina pueda usarse como recursiva o reentrante, no debe almacenar datos de ningún tipo en variables
de memoria, sino hacerlo en la Pila. En efecto, dada la forma
en que funciona la Pila, ésta puede contener valores distintos de determinado dato en entradas sucesivas a la subrutina.
En el caso de la subrutina reentrante, el proceso de las
interrupciones debe efectuarse en estricto orden LIFO (Last
In, First Out, o sea último que entra, primero que sale). Si
esto no sucediera, como es el caso de los sistemas de Time
Sharing (tiempo compartido), en los cuales se asignan intervalos de tiempo a procesos independientes, cada proceso deberá tener su Pila.</p>
<p class="calibre8"><strong class="calibre4">11.4. Cómo devolver los resultados</strong></p>
<p class="calibre8">Las diversas formas en que una subrutina puede devolver
resultados son similares a las de recibir parámetros:</p>
<ol class="upperalpha">
<li class="calibre3">Resultados en los registros</li>
<li class="calibre3">Direcciones de los resultados en los registros</li>
<li class="calibre3">Resultados en la Pila</li>
<li class="calibre3">Direcciones de los resultados en la Pila</li>
<li class="calibre3">Resultados en los parámetros</li>
<li class="calibre3">Variables de memoria de uso común</li>
<li class="calibre3">Banderas</li>
<li class="calibre3">Combinación de las anteriores</li>
</ol>
<p class="calibre8">Sin embargo, las técnicas C y D son muy engorrosas, puesto
que la instrucción RET hace automáticamente POP del IP, y por
lo tanto los resultados debieran ser insertados más abajo del
IP en la Pila, lo que combinado casi siempre con la necesidad
de restaurar los registros lo vuelve muy difícil.</p>
<p class="calibre8">Es común retornar resultados que sólo toman un bit en las
banderas, sobre todo CF. Por ejemplo, es práctica común señalar con CF = 1 una condición de error.</p>
<p class="calibre8">Una de las técnicas más usadas es la E, que se emplea
cuando el programa llamador pasa las direcciones de los parámetros, ya sea en la Pila o en los registros.</p>
<p class="calibre8"><strong class="calibre4">11.5. Ejercicio nº 15</strong></p>
<p class="calibre8">Escribiremos una subrutina para traducir una cadena de 16
bytes con representación binaria (caracteres “0” y “1”) a una
palabra, la que será devuelta en el registro AX. Escribiremos
también un ejemplo de programa llamador. La dirección de la
cadena estará en la Pila, a efectos de ilustrar el método de
paso de direcciones en la Pila, aunque en este caso sería más
cómodo pasarla en un registro. Si se detecta un error (que
alguno de los caracteres de la cadena no sea “0” o “1”), se
devolverá un valor 1 en el CF; de lo contrario, se devolverá
un valor 0. En caso de error, el contenido de AX quedará
indefinido. Véase una solución en SOLUCIONES.</p>
<p class="calibre8"><strong class="calibre4">SOLUCIONES</strong></p>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 8</strong></p>
<pre class="literal-block">
| ; Poner en una cadena la representación binaria de una palabra
|            .DATA
| Palabra   DW     ?
| Binaria   DB     16 DUP (?)
|            .CODE
| ................................
|            mov    di, OFFSET Binaria ; Apuntar a comienzo
|            mov    ax, Palabra        ; Cargar el dato
| Repite:
|            add    ax, ax             ; 1 bit a la izquierda
|            jc     Uno                ; Ver si salió 1 de AX
|            mov    BYTE PTR [di], '0' ; Poner un 0
|            jmp    Sigue
| Uno:
|            mov    BYTE PTR [di], '1' ; Poner un 1
| Sigue:
|            inc    di                 ; Ir al próximo carácter
|            cmp    di, OFFSET Binaria + 16   ; Ver si fin
|            jb     Repite                    ; Puede ser jne
| ................................
</pre>
<p class="calibre8">La instrucción add ax, ax duplica el contenido del registro
AX, lo cual equivale a desplazarlo una posición a la izquierda. Cuando un bit es desplazado fuera del registro, dicho bit
va a la bandera de acarreo CF, que es probada luego para
determinar si el bit desplazado es 0 o 1.</p>
<p class="calibre8">Aprovechando que el código ASCII del carácter “1” es una
unidad mayor que el del carácter “0”, llegamos a una segunda
solución:</p>
<pre class="literal-block">
| ; Poner en una cadena la representación binaria de una
| ;  palabra, versión 2
|            .DATA
| Palabra   DW     ?
| Binaria   DB     16 DUP (?)
|           .CODE
| ................................
|           mov     di, OFFSET Binaria  ; Apuntar a comienzo
|           mov     ax, Palabra         ; Cargar el dato
| Repite:
|           mov     BYTE PTR [di], '0'  ; Poner un 0
|           add     ax, ax              ; 1 bit a la izquierda
|           adc     BYTE PTR [di], 0    ; Sumarle el CF
|           inc     di                  ; Ir al próximo carácter
|           cmp     di, OFFSET Binaria + 16   ; Ver si fin
|           jb      Repite                    ; Puede ser jne
</pre>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 9</strong></p>
<pre class="literal-block">
| ; Traducir una cadena de caracteres a hexadecimal
|           .DATA
| Longitud EQU     80
| Cadena   DB      Longitud DUP (?)
| Doble    EQU     Longitud * 2   ; * indica multiplicación
| Hexa     DB      Doble DUP (?)
| Tabla    DB      '0123456789ABCDEF'   ; Tabla de traducción
|           .CODE
| ................................
|           mov     si, OFFSET Cadena   ; Indice de origen
|           mov     di, OFFSET Hexa   ; Indice de destino
|           sub     bx, bx   ; Borrar BX a 0
| Mas:
|           cmp     si, OFFSET Cadena + Longitud   ; Ver si fin
|           jae     Fin
|           sub     ax, ax   ; Borrar AX a 0
|           mov     al, [si]   ; Cargar carácter
|           add     ax, ax   ; Desplazar nibble alto
|           add     ax, ax   ;  de AL a AH
|           add     ax, ax
|           add     ax, ax
|           mov     bl, ah   ; Parte baja de BX
|           mov     al, Tabla [bx]   ; Cargar hexa desde Tabla
|           mov     [di], al ; Ponerlo en destino
|           inc     di       ; Ir a próximo hexa
|           mov     bl, [si] ; Parte baja de BX
|           and     bl, 0fh  ; Borrar nibble alto de BL
|           mov     al, Tabla [bx]   ; Cargar hexa desde Tabla
|           mov     [di], al ; Ponerlo en destino
|           inc     di       ; Ir a próximo hexa
|           inc     si       ; Ir a próximo carácter
|           jmp     Mas      ; Procesar otro carácter
| Fin:
| ................................
</pre>
<p class="calibre8">Usamos una técnica distinta según procesemos el nibble alto o
el bajo del carácter. Para el nibble alto, borramos AX,
ponemos el carácter en AL y con 4 instrucciones add ax, ax
desplazamos los 4 bits altos (nibble alto) de AL al nibble
bajo de AH. Luego se transfiere AH a BL. Como BH está siempre
en 0 (lo pone en 0 sub bx, bx, y nunca se lo modifica), esto
deja en BX el índice correcto para apuntar a la tabla.</p>
<p class="calibre8">Para el nibble bajo del carácter, se carga directamente el
carácter en BL, y se borra el nibble alto de BL con and bl,
0fh.</p>
<p class="calibre8">Obsérvese que el registro BX, a diferencia de SI, DI y BP,
permite un uso fácil cuando el índice, como en este caso,
está contenido en un byte; esto se debe a su separación en BH
y BL.</p>
<p class="calibre8">Veamos ahora otra solución bastante distinta para el mismo
problema, esta vez sin usar tabla. Esta solución es posible
por la estructura de la representación hexadecimal, en la
cual cada carácter tiene un valor ASCII mayor que el anterior
en una unidad, con excepción del paso de “9” a “A”.</p>
<pre class="literal-block">
| ; Traducir una cadena de caracteres a hexadecimal, versión 2
|           .DATA
| Longitud EQU     80
| Cadena   DB      Longitud DUP (?)
| Doble    EQU     Longitud + Longitud
| Hexa     DB      Doble DUP (?)
|           .CODE
| ................................
|           mov     si, OFFSET Cadena     ; Indice de origen
|           mov     di, OFFSET Hexa       ; Indice de destino
|
| Mas:
|           cmp     si, OFFSET Cadena + Longitud  ; Ver si fin
|           jae     Fin
|           sub     ax, ax     ; Borrar AX a 0
|           mov     al, [si]   ; Cargar carácter
|           add     ax, ax     ; Desplazar nibble alto
|           add     ax, ax     ;  de AL a AH
|           add     ax, ax
|           add     ax, ax
|           add     ah, '0'    ; Ajustar a carácter
|           cmp     ah, '9'    ; Ver si superó el 9
|           jbe     Sigue
|           add     ah, 'A' - 1 - '9'   ; Transformarlo en A - F
| Sigue:
|           mov     [di], ah   ; Ponerlo en destino
|           inc     di         ; Ir a próximo hexa
|           mov     al, [si]   ; Cargar carácter
|           and     al, 0fh    ; Borrar nibble alto
|           add     al, '0'    ; Ajustar a carácter
|           cmp     al, '9'    ; Ver si superó el 9
|           jbe     Sigue2
|           add     al, 'A' - 1 - '9'   ; Transformarlo en A - F
| Sigue2:
|           mov     [di], al   ; Ponerlo en destino
|           inc     di         ; Ir a próximo hexa
|           inc     si         ; Ir a próximo carácter
|           jmp     Mas        ; Procesar otro carácter
| Fin:.
| ................................
</pre>
<p class="calibre8">En la instrucción add ah, ‘A’ - 1 - ‘9’, la expresión del
segundo operando es evaluada a un dato inmediato que podría
ser indistintamente positivo o negativo (en realidad es
positivo) y que ajusta el carácter que superó “9” para obtener un carácter en el rango “A” - “F”.</p>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 10</strong></p>
<pre class="literal-block">
| ; Eliminar blancos múltiples e iniciales de una cadena
|
|           .DATA
| Longitud EQU     100   ; Longitud fija
| Dato     DB      Longitud DUP (?)
|           .CODE
| ...............................
|           mov     si, -1   ; Indice de origen
|           mov     di, 0    ; Indice de destino
| Barrer:
|           inc     si             ; Incrementar origen
|           cmp     si, Longitud   ; Ver si se terminó
|           jae     Llenar
|           cmp     Dato [si], ' ' ; Ver si es blanco
|           je      Barrer
| Mover:
|           mov     al, Dato [si]  ; Transferir carácter
|           mov     Dato [di], al
|           inc     si             ; Ir a próximo origen
|           inc     di             ; Ir a próximo destino
|           cmp     si, Longitud   ; Ver si se terminó
|           jae     Llenar
|           cmp     Dato [si], ' ' ; Ver si es blanco
|           jne     Mover
|           mov     Dato [di], ' ' ; Poner blanco único
|           inc     di             ; Ir a próximo destino
|           jmp     Barrer
| Llenar:          ; Completar cola con blancos
|           cmp     di, Longitud   ; Ver si se terminó
|           jae     Fin
|           mov     Dato [di], ' ' ; Poner blanco
|      jmp   Llenar
| Fin:
| ................................
</pre>
<p class="calibre8">Obsérvese que en varios ejercicios anteriores hemos usado
instrucciones del tipo:</p>
<pre class="literal-block">
|           mov    si, OFFSET Dato
|           cmp    si, OFFSET Dato + Longitud
|           mov    BYTE PTR [si], ' '
</pre>
<p class="calibre8">mientras que en este caso usamos instrucciones del tipo:</p>
<pre class="literal-block">
|           mov    si, 0
|           cmp    si, Longitud
|           mov    Dato [si], ' '
</pre>
<p class="calibre8">Es decir que en el primer caso operamos con desplazamientos
absolutos y en el segundo con desplazamientos relativos al
comienzo del dato. No hay ventajas apreciables para una u
otra técnica de direccionamiento, y es tan correcto usar una
como otra.</p>
<p class="calibre8">Nótese también que en el presente ejemplo hemos comenzado
direccionando el dato a una posición antes de su comienzo
(mov si, -1). Sugerimos que se intente modificar la solución
para comenzar direccionando exactamente al comienzo del dato.</p>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 11</strong></p>
<pre class="literal-block">
| ; Eliminar blancos de un texto con la técnica de incremento
| ;  hasta 0. Caso de longitud fija
|
|           .DATA
| Longitud EQU     100               ; Longitud real del dato
| Texto    DB      Longitud DUP (?)
|           .CODE
| ................................
|           mov     si, Longitud   ; Cargar índice de origen
|           neg     si             ; Invertir el signo
|           mov     di, si         ; Cargar índice de destino
| Barrer:
|           mov     al, Texto + Longitud [si]   ; Tomar carácter
|           cmp     al, ' '        ; Ver si es blanco
|           je      Probar         ; Saltear si es blanco
|           mov     Texto + Longitud [di], al   ; Transferir
|           inc     di             ; Ir al próximo destino
| Probar:
|           inc     si             ; Ir al próximo origen
|           jnz     Barrer
|           and     di, di         ; Probar si destino lleno
|           jz      Fin            ;  sólo la primera vez
|
| Llenar:
| ; Llenar de blancos bytes de cola
|           mov     Texto + Longitud [di], ' '   ; Poner blanco
|           inc     di             ; Ir al próximo destino
|           jnz     Llenar         ; Probar si fin
| Fin:
| ................................
|
| ; Eliminar blancos de un texto con la técnica de incremento
| ;  hasta 0. Caso de longitud variable. La longitud viene en CX
|           .DATA
| Longitud EQU     1000               ; Longitud máxima
| Texto    DB   Longitud DUP (?)
|           .CODE
| ................................
|           jcxz    Fin                ; Ver si longitud = 0
|           mov     bx, cx             ; Cargar registro base
|           mov     si, bx             ; Indice de origen
|           neg     si                 ; Invertir signo
|           mov     di, si             ; Indice de destino
| Barrer:
|           mov     al, Texto [bx] [si] ; Tomar carácter
|           cmp     al, ' '            ; Ver si es blanco
|           je      Probar             ; Saltear si es blanco
|           mov     Texto [bx] [di], al ; Transferir carácter
|           inc     di                 ; Ir al próximo destino
| Probar:
|           inc     si                 ; Ir al próximo origen
|           jnz     Barrer
|           and     di, di             ; Probar si destino lleno
|           jz      Fin                ;  sólo la primera vez
| Llenar:
| ; Llenar de blancos bytes de cola
|           mov     Texto [bx] [di], ' ' ; Poner blanco
|           inc     di                 ; Ir al próximo destino
|           jnz     Llenar             ; Probar si fin
| Fin:
| ................................
</pre>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 12</strong></p>
<pre class="literal-block">
| ; Búsqueda en tabla no ordenada. Argumento byte, resultado
| ;  palabra
|          .DATA
| Argum   DB       ?
| Result  DW       ?
| Tabla   DB       'C'
| Funcion DW       13711
| Segundo DB       'A'
|          DW       4522
|          DB       'M'
|          DW       37222
| Final   EQU      $                ; Final de Tabla + 1
|          .CODE
| ................................
|          mov      Result, 0         ; Preparar no encontrado
|          mov      bx, OFFSET Tabla  ; Apuntar a tabla
|          mov      al, Argum         ; Preparar argumento
|
| Volver:
|          cmp      bx, OFFSET Final  ; Ver si fin de tabla
|          jae      Fin
|          cmp      al, [bx]          ; Buscar
|          je       Encontro
|          add      bx, Segundo - Tabla ; Próximo elemento
|          jmp      Volver
| Encontro:
|          mov      ax, 1 [bx]        ; Poner resultado
|          mov      Result, ax
| Fin:
| ................................
</pre>
<p class="calibre8">Usado en una expresión y sin hallarse entre apóstrofos, el
signo $ indica “este lugar”. El Ensamblador, a medida que va
compaginando instrucciones y directivas, lleva una cuenta de
los desplazamientos con respecto a un origen. El signo $
representa este desplazamiento.</p>
<p class="calibre8">La expresión Segundo - Tabla da la longitud del elemento
de tabla más la longitud de la función.</p>
<p class="calibre8">Si la tabla estuviera ordenada, podría terminarse la
búsqueda tan pronto como se encontrara un elemento de búsqueda menor o igual que el argumento. El programa resultante
sería:</p>
<pre class="literal-block">
| ; Búsqueda en tabla ordenada. Argumento byte, resultado
| ;  palabra
|           .DATA
| Argum    DB      ?
| Result   DW      ?
| Tabla    DB      'A'
| Funcion  DW      4522
| Segundo  DB      'C'
|           DW      13711
|           DB      'M'
|           DW      37222
| Final    EQU     $                  ; Final de Tabla + 1
|          .CODE
| ................................
|          mov      Result, 0          ; Preparar no encontrado
|          mov      bx, OFFSET Tabla   ; Apuntar a tabla
|          mov      al, Argum          ; Preparar argumento
| Volver:
|          cmp      bx, OFFSET Final   ; Ver si fin de tabla
|          jae      Fin
|          cmp      al, [bx]           ; Buscar
|          jbe      Encontro
|          add      bx, Segundo - Tabla ; Próximo elemento
|          jmp      Volver
| Encontro:
|          jb       Fin                ; Se pasó
|          mov      ax, 1 [bx]         ; Poner resultado
|          mov      Result, ax
| Fin:
| ................................
</pre>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 13</strong></p>
<pre class="literal-block">
| ; Búsqueda en tabla ordenada con centinela. Argumento byte,
| ;  resultado palabra
|
|          .DATA
| Tabla   DB       'A'
| Funcion DW       4522
| Segundo DB       'C'
|          DW       13711
|          DB       'M'
|          DW       37222
| Argum   DB       ?
| Result  DW       ?
|          .CODE
| ................................
|          mov      Result, 0        ; Preparar no encontrado
|          mov      bx, OFFSET Tabla ; Apuntar a tabla
|          mov      al, Argum        ; Preparar argumento
| Volver:
|          cmp      al, [bx]         ; Buscar
|          jbe      Encontro
|          add      bx, Segundo - Tabla ; Próximo elemento
|          jmp      Volver
|
| Encontro:
|          jb       Fin              ; Se pasó
|          mov      ax, 1 [bx]       ; Poner resultado
|          mov      Result, ax
| Fin:
| ................................
</pre>
<p class="calibre8">Analicemos los posibles eventos:</p>
<ol class="upperalpha">
<li class="calibre3">Si se sale del ciclo por igual antes del fin de la tabla, se mueve la función de tabla al resultado.</li>
<li class="calibre3">Si se sale por condición “abajo”, queda 0 en el resultado, colocado al principio del programa.</li>
<li class="calibre3">Si se llega al final de la tabla, inevitablemente se saldrá por igual, en cuyo caso el resultado (puesto en 0 al principio) se moverá sobre sí mismo.</li>
</ol>
<p class="calibre8">Esto nos muestra que el programa es correcto en todos los
casos.</p>
<p class="calibre8">No es conveniente dejar un valor inicial 0 en el resultado
por medio de DW y omitir cargarlo al principio del programa,
pues el mismo podría ejecutarse más de una vez si fuera una
subrutina (véase más adelante), con lo que el valor del
resultado cuando no se encuentra la clave sería el de la vez
anterior.</p>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 14</strong></p>
<pre class="literal-block">
| ; Búsqueda en tabla ordenada con centinela. Argumento cadena,
| ;  resultado palabra
|           .DATA
| Longitud EQU     10
| Tabla    DB      'Abascal   '
| Funcion  DW      4175
| Segundo  DB      'Gutiérrez '
|           DW      3942
|           DB      'Méndez    '
|           DW      37222
| Argum    DB      Longitud DUP (?)
| Result   DW      ?
|           .CODE
| ................................
|           mov     Result, 0         ; Preparar no encontrado
|           mov     bx, OFFSET Tabla + Longitud; Apuntar a tabla
| Volver:
|           mov     si, OFFSET Argum  ; Apuntar al argumento
|           mov     di, - Longitud    ; Preparar índice
| Otra:
|           mov     al, [si]          ; Tomar byte del argumento
|           cmp     al, [bx] [di]     ; Buscar
|           jne     No                ; Si terminó comparación
|           inc     si                ; Próximo byte argumento
|           inc     di                ; Próximo byte de tabla
|           jnz     Otra              ; Si no es fin de elemento
|           jmp     Encontro          ; Si no hubo distintos
| No:
|           jb      Fin               ; Si argumento menor
|           add     bx, Segundo - Tabla ; Próximo elemento
|           jmp     Volver
| Encontro:
|           mov     ax, [bx]          ; Poner resultado
|           mov     Result, ax
| Fin:
| ................................
</pre>
<p class="calibre8"><strong class="calibre4">Ejercicio nº 15</strong></p>
<pre class="literal-block">
| ; Programa de prueba para la subrutina Binapal
|           .MODEL  small
|           .STACK  100h
|           .DATA
| Palabra   DW     ?
| Cadena    DB     16 DUP (?)
|           .CODE
| Prueba   PROC    near
| ................................
|           mov     bx, OFFSET Cadena  ; Cargar dirección
|           push    bx                 ; Ponerla en la Pila
|           call    Binapal            ; Llamar a la subrutina
|           jc      Error              ; Ver si hubo error
|           mov     ax, Palabra        ; Guardar resultado
| ; Aquí se procesará el resultado
| ................................
| Error:
| ; Aquí se realizará el proceso de error
| ................................
| Prueba   ENDP
| ;
| ; Subrutina para traducir una cadena con 16 bytes de
| ;  representación binaria a una palabra.
| ; Preserva los registros usados.
| ; Entrada:   Dirección de la cadena en la Pila
| ; Salidas:   Resultado en AX
| ;      Si hay error, CF = 1, y AX indefinido
| Binapal  PROC    near
|           push    bp                 ; Salvar registros
|           push    di
|           push    si
|           mov   bp, sp               ; Apuntar a la Pila
| ; La primera palabra de la pila antes de salvar registros
| ;  está ocupada por el IP
| ; La segunda contiene la dirección de la cadena
| ; Pero se debe ajustar esto de acuerdo con la cantidad de
| ;  registros salvados, 3, o sea 6 bytes
|           mov     si, 8 [bp]         ; Tomar dirección
|           mov     di, si             ; Calcular dirección fin
|           add     di, 16
|           xor     ax, ax             ; Borrar AX a 0
| Otro:
|           add     ax, ax           ; Desplazar 1 bit izquierda
|           cmp     BYTE PTR [si], '1' ; Ver si es válido
|           je      Uno
|           cmp     BYTE PTR [si], '0'
|           je      Cero
| ; Si llegó aquí, hubo error
|           mov     al, 0ffh           ; Poner CF = 1
|           add     al, al
| ; Más adelante se verá una manera más directa de poner CF = 1
|           jmp     Fin
| Uno:
|           inc     ax               ; Poner último bit en 1
| Cero:
|           inc     si               ; Ir al próximo carácter
|           cmp     si, di           ; Ver si se llegó al fin
|           jb      Otro
|           and     si, si           ; Poner CF = 0
| Fin:
|           pop     si               ; Restaurar registros
|           pop     di
|           pop     bp
|           ret     2                 ; Retornar
| Binapal  ENDP
|           END     Prueba
</pre>
<p class="calibre8">El formato de la instrucción RET con un operando indica que,
tras recuperarse el IP (y el CS en caso de que fuera “lejano”), el SP se incrementará en tantas unidades como se
indiquen, a fin de desechar parámetros que queden en la Pila.
El programa llamador puso en la Pila un parámetro, que ocupa
2 bytes; por lo tanto la subrutina debe desechar 2 bytes. Si
no lo hiciera, el programa llamador debería hacerse cargo de
esta operación, que puede efectuarse con un POP o sumando 2
al SP. La subrutina no puede hacerlo con POP, pues el parámetro ha quedado bajo el IP, que debe ser recuperado por RET.
De cualquier manera, como el registro BX no se ha modificado,
no es necesario un pop bx.</p>
<p class="calibre8">Se sugiere modificar esta subrutina utilizando la técnica
de incremento hasta 0.</p>
<p class="calibre8">En la próxima entrega de este manual:</p>
<p class="calibre8">Sección 12: DESPLAZAMIENTO Y ROTACION</p>
<p class="calibre8">Sección 13: INSTRUCCIONES VARIAS</p>
<p class="calibre8">Sección 14: CICLOS</p>
</div>
</div>
</div>

</div>

</body>
</html>
