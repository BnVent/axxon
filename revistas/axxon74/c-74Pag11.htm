<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Axxón 74 - SECCIÓN: - ET AL Virtual</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" type="text/css" rel="stylesheet"/>
<link href="page_styles.css" type="text/css" rel="stylesheet"/>
</head>
  <body class="calibre">

<div id="main" class="calibre1">
<h1 class="calibre7">ET AL Virtual</h1>
<p class="calibre5"><b class="calibre4">Sergio Gaut vel Hartman y Eduardo J. Carletti</b></p><p class="calibre5"></p>
<div class="document">
<!-- # :maxLineLen=120:folding=explicit:mode=rest:wrap=soft:collapseFolds=1:encoding=windows-1252: -->
<p class="calibre5">Las fuentes de información de este revista son las propias y además:</p>
<pre class="literal-block1">
AMB : Ambito Financiero
ANA : Analog
ASI : Asimov's
AXX : Fuentes propias
BEM : BEM
CCO : Cronista Comercial
CGA : Computer Graphics and Applications
CGW : Computer Graphics World
CLA : Clarín
CUA : Cuasar
FAN : Fandom
FSF : Fantasy &amp; Science Fiction
INT : Internet
INZ : Interzone
LAN : La Nación
LAP : La Prensa
LOC : Locus
MEX : Corresponsal en México
P12 : Página 12
POR : Pórtico
SF  : Revista SF
SFA : Science Fiction Age
SFC : Science Fiction Chronicle
STA : Starlog
USA : Corresponsal en EE.UU.
WIR : Wired
</pre>
<p class="calibre5">Se agradecerá cualquier corrección, información nueva o el envío de publicaciociones para reseña. Envíe a: Axxón, Anchorena 1517 (1714) Ituzaingó (ARGENTINA)
TE/FAX  (01) 624-9267 - Internet: <a href="mailto:eduardo.carletti%40newage.net">eduardo<span>.</span>carletti<span>@</span>newage<span>.</span>net</a></p>
<div class="contents" id="contents">
<ul class="calibre2">
<li class="calibre3"><a href="#a-c-t-u-a-l-i-d-a-d-e-n-i-n-f-o-r-m-a-t-i-c-a" id="id1">A C T U A L I D A D   E N   I N F O R M A T I C A</a><ul class="calibre26">
<li class="calibre3"><a href="#continuan-los-errores-de-intel" id="id2">CONTINUAN LOS ERRORES DE INTEL</a></li>
<li class="calibre3"><a href="#asistentes-inteligentes" id="id3">ASISTENTES INTELIGENTES</a></li>
<li class="calibre3"><a href="#computadora-para-pobres" id="id4">COMPUTADORA PARA POBRES</a></li>
<li class="calibre3"><a href="#un-casi-bug-de-la-486" id="id5">UN CASI BUG DE LA 486</a></li>
</ul>
</li>
<li class="calibre3"><a href="#lenguaje-ensamblador-8086-8088-parte-2" id="id6">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 2)</a><ul class="calibre26">
<li class="calibre3"><a href="#el-procesador-8086-8088" id="id7">3. EL PROCESADOR 8086/8088</a><ul class="calibre29">
<li class="calibre3"><a href="#los-registros" id="id8">3.1. Los registros</a></li>
<li class="calibre3"><a href="#la-pila-stack" id="id9">3.2. La Pila (stack)</a></li>
<li class="calibre3"><a href="#interrupciones" id="id10">3.3. Interrupciones</a></li>
</ul>
</li>
<li class="calibre3"><a href="#sintaxis-del-ensamblador" id="id11">4. SINTAXIS DEL ENSAMBLADOR</a></li>
<li class="calibre3"><a href="#programas" id="id12">5. PROGRAMAS</a><ul class="calibre29">
<li class="calibre3"><a href="#primer-programa" id="id13">5.1. Primer programa</a></li>
<li class="calibre3"><a href="#compilacion-y-encadenado" id="id14">5.2. Compilación y encadenado</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="pri1" id="a-c-t-u-a-l-i-d-a-d-e-n-i-n-f-o-r-m-a-t-i-c-a">
<h2 class="indiceautor"><a class="toc-backref" href="#id1">A C T U A L I D A D   E N   I N F O R M A T I C A</a></h2>
<p class="calibre5"><strong class="calibre4">Alejandro Alonso y Ricardo M. Forno - 1995</strong></p>
<div class="pri1" id="continuan-los-errores-de-intel">
<h3 class="calibre27"><a class="toc-backref" href="#id2">CONTINUAN LOS ERRORES DE INTEL</a></h3>
<p class="calibre5">El P6, alias Pentium Pro, también falla…</p>
<p class="calibre5">Se repite la historia: el fabricante más grande de computadoras personales en los EEUU, Compaq, detectó un error en el
sucesor del Pentium de Intel, el Pentium Pro o P6. La falla
ocurre cuando se lo emplea en redes. Compaq decidió aplazar
la salida al mercado de PCs con ese microprocesador hasta que
Intel resuelva el problema en el primer trimestre de 1996.
Intel dice que el problema es muy infrecuente (¿no les suena?) y se da en condiciones muy poco comunes. Veremos qué
pasa con la prueba de fuego, es decir, la prueba por parte de
los usuarios, que la vez pasada fueron quienes definieron que
la “falla cada 37.000 años” del Pentium era muchísimo, pero
muchísimo más frecuente.</p>
</div>
<div class="pri1" id="asistentes-inteligentes">
<h3 class="calibre27"><a class="toc-backref" href="#id3">ASISTENTES INTELIGENTES</a></h3>
<p class="calibre5">El software evoluciona hacia conceptos más eficientes</p>
<p class="calibre5">Microsoft piensa lanzar pronto asistentes en software que se
acercan a lo que Gates ve para el futuro, es decir, un soft
“pensante” capaz de aprender y entender la palabra hablada,
reconociendo la voz de su usuario. Sabiendo los errores que
suelen tener los productos recién lanzados del por ahora
gigante del software, no habrá que esperar mucho para tener
en la PC algún monstruo (IA) como los de los cuentos de CF.</p>
</div>
<div class="pri1" id="computadora-para-pobres">
<h3 class="calibre27"><a class="toc-backref" href="#id4">COMPUTADORA PARA POBRES</a></h3>
<p class="calibre5">Hace mucho ruido el proyecto de una computadora barata</p>
<p class="calibre5">Se viene hablando mucho de la “computadora barata” para el
pueblo, de un valor de $ 500. Estas PC servirán más que nada
para conectarse a las redes, aunque independientemente no
tendrán gran poder de computación. Hay jerarcas que no quieren sistemas baratos (se notó siempre, por los programas que
hacen, aunque por fin lo dicen públicamente), aunque la presión comercial de los que quieren llegar pronto a “una PC en
cada casa” es muy fuerte y casi seguro que estas PC aparecerán. Veremos qué truco hacen los gigantes para forzar, por
medio del soft, que la PC barata no prospere.</p>
</div>
<div class="pri1" id="un-casi-bug-de-la-486">
<h3 class="calibre27"><a class="toc-backref" href="#id5">UN CASI BUG DE LA 486</a></h3>
<p class="calibre5"><strong class="calibre4">Y si vamos hacia atrás, también fallan…</strong></p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<p class="pri">¿Quién no oyó hablar del bug de la división flotante en la
Pentium (las primeras; actualmente ya no tienen el bug)?
Quizá menos notorio haya sido el bug de la instrucción POPAD
de la 386, que sin embargo afecta a casi todas en existencia.
Así como ocurre con estas, muchas máquinas en toda la
historia de la computación han sido afligidas por errores de
hardware. Recuerdo uno de los primeros: ciertas instrucciones
# (Modify Address) de la viejísima IBM 1401 (allá por 1961).
El que ahora describiré no podría con justicia denominarse
“bug”, sino “efecto no previsto”; sus síntomas, sin embargo,
son similares.</p>
<p class="calibre5">Todo empezó cuando noté que en una 486 nueva no podían
correrse ciertos programas que andaban perfectamente en una
386, 286 o simplemente 8086 u 8088. Mientras que la mayoría
de los programas funcionaba perfectamente, estos otros no lo
hacían:</p>
<ol class="loweralpha">
<li class="calibre3">El programa shareware italiano COMPACK versión 4 (un compactador de ejecutables similar al LZEXE).</li>
<li class="calibre3">Los programas compactados con COMPACK.</li>
<li class="calibre3">El PCGLOBE, en sus versiones 4 y 5 por lo menos.</li>
<li class="calibre3">El intérprete del lenguaje APL APL*STSC versión 5 (sólo en ciertas instrucciones).</li>
</ol>
<p class="calibre5">Experimenté con otros equipos, y observé lo siguiente:
mientras que cualquier 386 admitía dichos programas, en
cambio todas, absolutamente todas las 486 (ya fuesen SX, DX2
o DX4, Intel o Cyrix) sufrían el problema.</p>
<p class="calibre5">Escribí a STSC para pedirles una solución al problema, con
número de serie del producto y todo, pero no me aclararon el
panorama y me ofrecieron en cambio la versión 11, a un precio
que a ellos les habrá parecido irrisorio.</p>
<p class="calibre5">Por suerte, una carta enviada a los creadores del COMPACK
obtuvo una respuesta que me permitió dilucidar el enigma.
¿Qué tienen en común los programas señalados antes? Esto: Son
programas escritos (por lo menos parcialmente) en Assembler;
y, usando las facilidades que permite el lenguaje de máquina,
se modifican a sí mismos.</p>
<p class="calibre5">¿Cómo se hace esto y para qué sirve? Una determinada
instrucción modifica el contenido de la memoria ocupada por
otra instrucción, casi siempre posterior a la instrucción
modificante. Ello permite, por ejemplo, insertar operandos
inmediatos en las instrucciones, haciéndolas más veloces.
Otras veces se modifican los códigos de operación,
transformando una suma en resta, o una bifurcación en nooperación.</p>
<p class="calibre5">Ahora bien, muchas máquinas, entre ellas la 386 y la 486,
tienen un sistema de “look-ahead” (cámbienlo por algo así
como “previsión”) que permite pre-procesar instrucciones
antes de llegar realmente a ellas y ejecutarlas. Estas
instrucciones pre-procesadas se guardan en lo que se llama la
cola de “pre-fetch” (pre-lectura de la instrucción).</p>
<p class="calibre5">¿Qué sucede cuando la instrucción que se va a ejecutar
desde la cola de pre-fetch es modificada en la memoria por
una instrucción previa? Sencillamente, que la modificación
ocurre sólo en la memoria y no se traslada a su copia en la
cola de pre-fetch, que es la que se ejecuta. En otras
palabras, la modificación ocurre demasiado tarde para la
velocidad de la máquina.</p>
<p class="calibre5">Esto no es lo que previó el programador, y por lo tanto el
programa falla, con síntomas variados.</p>
<p class="calibre5">¿Por qué los programas mencionados fallan en una 486 y no
en una 386, siendo que ambas trabajan con una cola de prefetch? Ocurre que la cola de la 386 se reduce a una sola
instrucción en promedio, mientras que la de la 486 tiene una
longitud promedio de unas 7 instrucciones (el valor en cada
caso depende de las instrucciones particulares de que se
trate).</p>
<p class="calibre5">Entonces, si la distancia entre la instrucción modificante
y la modificada es de 2 a 6 instrucciones (en promedio), el
programa fallará en una 486 pero no en una 386.</p>
<p class="calibre5">Un sencillo programa en Assembler, que puede ser cargado
con el Debug, nos permitirá comprobarlo.</p>
<p class="calibre5">¿Hay una manera de impedir esto? Sí. Por supuesto, una
forma consiste en eliminar las modificaciones dinámicas del
programa, pero ello es muy drástico y conduce a desechar
posibilidades de optimización. Otra manera, más práctica,
consiste en insertar, entre la instrucción modificante y la
modificada, una bifurcación a la instrucción inmediata
siguiente a la bifurcación. Desde el punto de vista lógico,
esto no hace nada, pero fuerza al procesador a desechar la
cola de pre-fetch existente y generar una nueva, con lo que
el problema desaparece.</p>
<p class="calibre5">¿Qué ocurre con una Pentium? Sinceramente no lo sé, porque
no tengo acceso a una. Pero es de prever que, por las mismas
razones que en una 486, los mencionados programas fallen.
Incluso podría ser, por lo que sé de la arquitectura de las
Pentium, que la maniobra antes mencionada (insertar una
bifurcación) no funcione, pues se prevén las posibles rutas
en la construcción de la cola de pre-fetch. Si alguien tiene
información al respecto, le agradecería que me la comunicara.
¿Qué moralejas podemos extraer de todo esto? Primera: los
diseñadores de computadoras debieran prever mejor los efectos
de ciertas decisiones de arquitectura, y por lo menos
informar a los usuarios sobre dichos efectos. Segunda: la
programación en Assembler tiene más vericuetos y peligros que
los imaginados. Tercera: pese a todo el Assembler es lo que
nos permite usar a fondo todos los recursos de la máquina,
por lo cual siempre habrá quien programe de este modo.</p>
</div>
</div>
<div class="pri1" id="lenguaje-ensamblador-8086-8088-parte-2">
<h2 class="indiceautor"><a class="toc-backref" href="#id6">LENGUAJE ENSAMBLADOR 8086/8088 (Parte 2)</a></h2>
<p class="calibre5"><strong class="calibre4">Cómo adentrarse en el alma de la PC</strong></p>
<p class="calibre5">Ing. Ricardo M. Forno</p>
<div class="pri1" id="el-procesador-8086-8088">
<h3 class="calibre27"><a class="toc-backref" href="#id7">3. EL PROCESADOR 8086/8088</a></h3>
<p class="calibre5">El 8086 y el 8088 son dos procesadores que operan fundamentalmente del mismo modo. Hay pequeñas diferencias entre ellos en
cuanto a sus tiempos de operación y en algunos detalles
internos que no son aparentes para el programador, por lo que
éste puede desentenderse de tales diferencias. Cuando en este
texto nos referimos al procesador 8086, debe entenderse que la
referencia también es válida para el 8088.</p>
<p class="calibre5">Existen asimismo los procesadores 80186, 80286, 80386,
80486 y Pentium (y sus variantes), que tienen instrucciones,
registros y modos de direccionamiento adicionales, pero todos
ellos pueden ser programados como si se tratara de 8086. Más
aun, se los suele programar de tal manera, puesto que muchas
de las instrucciones adicionales tienen significación sólo
para el Sistema Operativo y no para los programas del usuario.
Por lo tanto, bastará con lo que se ve en este texto para programar aplicaciones en todos esos procesadores.</p>
<p class="calibre5">Adicionalmente a uno de estos procesadores puede estar
presente un coprocesador o procesador auxiliar 8087 (u 80287,
etc.), que realiza directamente operaciones de punto flotante,
mientras que el 8086 y los otros (excepto el 80486 y el Pentium), librados a sí mismos, deben efectuar dichas operaciones
por medio de subrutinas (subprogramas al efecto).</p>
<div class="pri1" id="los-registros">
<h4 class="calibre30"><a class="toc-backref1" href="#id8">3.1. Los registros</a></h4>
<p class="calibre5">Dentro del procesador 8086 hay una cantidad de registros, cada
uno de los cuales contiene una configuración de 16 bits. A
cada uno de dichos registros se lo conoce por un código mnemotécnico de dos letras (pueden ser mayúsculas o minúsculas
indistintamente). Estos registros son:</p>
<pre class="literal-block1">
AX BX CX DX   SI DI   SP BP    CS DS SS ES    IP  ST
</pre>
<p class="calibre5">Cada uno de estos registros tiene funciones ligeramente distintas, pero se los puede agrupar en varias clases, lo que ha
quedado reflejado gráficamente arriba.</p>
<p class="calibre5">Tenemos en primer lugar los registros de propósito general:
AX, BX, CX, DX, SI, DI, SP y BP. Todos ellos pueden usarse
para operaciones aritméticas y lógicas. A su vez, entre ellos
podemos distinguir los cuatro primeros: AX, BX, CX y DX. Cada
uno de estos cuatro registros de 16 bits se divide en dos de 8
bits. El registro AX se divide en AH y AL; el BX en BH y BL;
el CX en CH y CL; y el DX en DH y DL. Las letras H y L provienen del inglés High (alto) y Low (bajo), que indican la jerarquía de cada subregistro dentro del registro correspondiente.
Entonces, por ejemplo, el valor que contiene BX puede ser determinado en base a los de BH y BL como sigue:</p>
<p class="calibre5">BX = BH x 256 + BL</p>
<pre class="literal-block1">
+-----------------+
|   AH   |   AL   |
+-----------------+
|       A X       |
+-----------------+
</pre>
<p class="calibre5">El registro AX y su parte inferior AL son un tanto especiales.
Por razones históricas se los conoce como acumuladores. Algunas operaciones aritméticas y especiales sólo pueden realizarse con dichos registros y, por otra parte, muchas operaciones
son más rápidas u ocupan menos espacio en las instrucciones
cuando se las ejecuta con ellos.</p>
<p class="calibre5">El registro BX se usa en el direccionamiento de la memoria
y es obligatorio con ciertas instrucciones. Se lo denomina
base.</p>
<p class="calibre5">El registro CX se emplea como cuenta para realizar ciclos.
Su parte inferior CL se usa en ciertas operaciones de desplazamiento y rotación.</p>
<p class="calibre5">El registro DX se emplea en operaciones de entrada y salida
y en la multiplicación y la división.</p>
<p class="calibre5">Los registros SI y DI se emplean de manera similar al BX en
el direccionamiento y son obligatorios en ciertas instrucciones. Se los conoce como índices.</p>
<p class="calibre5">El registro SP se conoce como Stack Pointer (apuntador a la
Pila), y apunta a un lugar de la memoria donde se guarda una
Pila (stack) de datos intermedios.</p>
<p class="calibre5">El registro BP se usa como el BX, pero para direccionar la
Pila en vez del área de datos.</p>
<p class="calibre5">Otro grupo está formado por los registros de segmento CS,
DS, SS y ES. Estos registros contienen valores de segmentos
que se emplean para el cálculo de direcciones de la memoria,
como se explicó antes y como volveremos a explicar con mayor
detalle.</p>
<p class="calibre5">El registro CS (segmento de código) se usa para apuntar a
las instrucciones. El registro DS (segmento de datos) se usa
para apuntar a los datos. El registro SS (segmento de Pila) se
usa para apuntar a la Pila. El registro ES (segmento extra) se
usa para ciertas instrucciones especiales y se lo puede usar
también como auxiliar. Es posible lograr por medio de un prefijo de override (contrarrestar), y con ciertas excepciones,
que cualquiera de los registros de segmento se use para la
función de otro, por ejemplo apuntar a datos con el CS.</p>
<p class="calibre5">El último grupo lo forman registros un tanto inaccesibles
para el programador. El primero es el IP (Instruction Pointer,
apuntador a instrucción). Este registro contiene la parte de
desplazamiento (offset) de la dirección de la próxima instrucción a ser ejecutada. No es posible mover directamente valores
a este registro ni tampoco leerlos, pero en forma indirecta
puede afectarse su valor por medio de instrucciones de bifurcación y similares.</p>
<p class="calibre5">El último registro es también poco accesible. Se trata del
registro ST (Status, estado). Consiste en una serie de banderas (flags) de un bit cada una. Algunas afectan la forma de
trabajo del procesador, y otras contienen indicaciones sobre
el resultado de las últimas operaciones efectuadas. Por ejemplo, cualquier operación aritmética que deje un resultado 0
coloca en 1 la bandera de cero, denominada ZF, y en caso
contrario la coloca en 0. Hay instrucciones especiales para
poner en 0 o en 1 algunas de las banderas. Por otra parte, hay
una cantidad de instrucciones de bifurcación condicional que
examinan el estado de las banderas y siguen el programa en
otra ubicación de la memoria si el estado de las banderas es
el indicado.</p>
<pre class="literal-block1">
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|  |  |  |  |OF|DF|IF|TF|SF|ZF|  |AF|  |PF|  |CF|    ST
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
</pre>
<p class="calibre5">Las banderas son las posiciones marcadas del registro ST de
la ilustración anterior. Las que no están marcadas son posiciones reservadas, normalmente con valor 0. Oportunamente
explicaremos el uso de la mayoría de las banderas. Mientras
tanto, aclararemos que se dividen en dos grupos: 6 banderas de
estado (OF, SF, ZF, AF, PF y CF) que registran el estado del
procesador en base a lo ocurrido en instrucciones previas, y 3
banderas de control (DF, IF y TF) que afectan la forma de funcionamiento de diversas instrucciones.</p>
<p class="calibre5">Aunque muchas instrucciones afectan implícitamente las
banderas, hay ciertas instrucciones cuyo único efecto es
modificarlas, basándose en alguna prueba o comparación. Es muy
común ver una comparación usada para modificar las banderas
justo antes de una bifurcación condicional.</p>
</div>
<div class="pri1" id="la-pila-stack">
<h4 class="calibre30"><a class="toc-backref1" href="#id9">3.2. La Pila (stack)</a></h4>
<p class="calibre5">La Pila es solamente una porción de memoria que ha sido
dedicada al propósito de guardar datos temporarios.</p>
<p class="calibre5">La Pila funciona como si fuera una Pila de platos en un
restaurante de autoservicio. Los platos limpios son puestos en
lo alto de la Pila. Cada vez que se retira un plato, se lo
hace también de lo alto de la Pila. Se denomina LIFO (Last In,
First Out, o sea último que entra, primero que sale) a esta
disciplina de cola.</p>
<p class="calibre5">En la computadora, la Pila se usa para pasar datos de un
programa a otro, y tiene también varios otros usos. Al emplear
la Pila, la rutina que recibe el dato no precisa conocer una
dirección particular donde buscarlo, sino que sencillamente lo
toma de lo alto de la Pila, y el próximo dato queda listo para
ser tomado del mismo lugar.</p>
<p class="calibre5">La Pila es realizada por medio de un apuntador a lo alto de
la misma, que es el ya nombrado SP. Cuando se efectúa un PUSH
(empujar), el SP se mueve a la próxima ubicación de memoria (2
bytes hacia direcciones decrecientes), y los datos (una palabra) se insertan donde apunta el SP. Cuando se efectúa un POP
(soltar), se toma el dato desde la ubicación adonde apunta el
SP, y se retrocede el mismo (2 bytes hacia direcciones crecientes). Esto es hecho en forma automática por las instrucciones PUSH y POP. El SP contiene la parte de desplazamiento
de la dirección de la Pila; la parte de segmento está en el
SS.</p>
<p class="calibre5">Dada las funciones del SP y del SS, lo mejor que puede
hacer el programador novato es no modificarlos directamente,
sino dejar que lo hagan las instrucciones PUSH y POP y, por
supuesto, el Sistema Operativo. Por otra parte, es necesario
balancear exactamente los PUSH con los POP, pues si no la Pila
podría crecer indefinidamente o agotarse.</p>
</div>
<div class="pri1" id="interrupciones">
<h4 class="calibre30"><a class="toc-backref1" href="#id10">3.3. Interrupciones</a></h4>
<p class="calibre5">Los programas de 8086 están sujetos a dos tipos de interrupciones. Unas son las llamadas interrupciones externas (o
también asincrónicas o de hardware). Éstas pueden producirse
en cualquier momento en que corra el programa y en cualquier
ubicación en la que se encuentre ejecutando. Son debidas a
ciertos eventos externos, por ejemplo que un reloj electrónico
al que está conectado el 8086 llegue a 0, o que se toque una
tecla en el teclado. Cuando ocurren, se produce la interrupción del flujo del programa y comienza a ejecutarse una rutina
en un lugar predeterminado de la memoria. La rutina comienza
salvando el estado de los registros; luego realiza diversas
tareas adecuadas para el evento que ocasionó la interrupción.
Una vez terminada la rutina, restaura los registros y vuelve
al lugar donde se interrumpió el programa. El tiempo que toma
la rutina para ejecutarse es generalmente muy escaso, de unos
pocos milisegundos (milésimas de segundo). El programa interrumpido no se ve afectado en absoluto. Es posible enmascarar,
es decir evitar que se produzcan, algunas de estas interrupciones; otras no son enmascarables. Algunas de estas interrupciones ocurren en puntos precisos del programa, por ejemplo en
una instrucción de división que deje un cociente demasiado
grande; en tales casos, las rutinas que las procesan no suelen
retornar al programa donde ocurrieron.</p>
<p class="calibre5">Las interrupciones del segundo tipo se conocen como interrupciones de software y son programadas expresamente. En
efecto, se ejecuta una instrucción llamada INT.</p>
<p class="calibre5">Los primeros 1024 bytes de memoria de la computadora
están reservados a una serie de vectores de interrupción,
cada uno de una longitud de una doble palabra. En cada
vector se almacena una dirección de memoria en el formato
Segmento:Desplazamiento. A la instrucción INT se le suministra
(o a la interrupción de hardware le corresponde) un número
desde 0 hasta 255. El procesador multiplica este número por 4
desplazándolo 2 bits a la izquierda, con lo cual direcciona un
vector desde 0 hasta 1023, y luego hace PUSH del registro ST y
la dirección de la próxima instrucción en la Pila, bifurcando
a la dirección almacenada en el vector antes mencionado.</p>
<p class="calibre5">Comenzando en las direcciones almacenadas en los vectores,
hay una serie de rutinas que realizan tareas importantes.
Terminada la ejecución de una de estas rutinas, se retorna a
la ubicación siguiente a la interrupción que la llamó, tras
haber restaurado el registro ST.</p>
<p class="calibre5">Algunas de estas rutinas forman parte del Sistema Operativo
(DOS u otro); puede hallarse la documentación de las mismas en
un manual tal como MS-DOS Programmer’s Reference. Las restantes se encuentran almacenadas en ROM en la parte superior de
la memoria y forman el BIOS (Basic Input/Output System, Sistema de Entrada/Salida Básico); la documentación de las mismas
puede hallarse en el Hardware Technical Reference Manual. Hay
más de un libro que contiene descripciones tanto de las rutinas de DOS como de las de BIOS; uno de ellos es Programmer’s
Guide to the IBM PC, de Peter Norton y Richad Wilton. En este
texto también pueden verse las más importantes de estas
rutinas en el Apéndice C.</p>
<p class="calibre5">Estas rutinas realizan una cantidad de tareas útiles, tales
como manejar los accesos a los discos, mostrar caracteres en
la pantalla o leer datos del teclado, lo cual prácticamente
amplía las capacidades del procesador sin necesidad de programar estas tareas. En los ejemplos de programas que veremos en
este texto usaremos varias de estas rutinas.</p>
<p class="calibre5">A estas rutinas se les transmiten parámetros a través de
registros (tales como AH, BX, etc.) especificados en la documentación de las mismas. Terminada una rutina, muchas veces
devuelve resultados en otros registros especificados.</p>
<p class="calibre5">Es perfectamente posible cambiar los vectores de interrupción para que, en lugar de ejecutarse rutinas del Sistema
Operativo o del BIOS, se ejecuten otras escritas por el programador.</p>
</div>
</div>
<div class="pri1" id="sintaxis-del-ensamblador">
<h3 class="calibre27"><a class="toc-backref" href="#id11">4. SINTAXIS DEL ENSAMBLADOR</a></h3>
<p class="calibre5">Un programa en lenguaje Assembly consiste en un archivo
compuesto por líneas, cada una terminada por dos caracteres
especiales: CR (Carriage Return, retorno de carro) y LF (Line
Feed, alimentación de línea). Cada línea del archivo contiene
una instrucción o directiva en lenguaje Assembly. Las directivas son indicaciones al Ensamblador que no resultan
compaginadas como instrucciones en lenguaje de máquina.</p>
<p class="calibre5">Las instrucciones están escritas en formato libre, o sea
que sus diversas partes no comienzan necesariamente en ubicaciones fijas. No obstante, es buena práctica encolumnar las
partes correspondientes, de manera que de una ojeada al archivo impreso pueda encontrarse lo que se busca.</p>
<p class="calibre5">Cada instrucción puede ser señalada por un rótulo, que se
usará para identificar un dato, una dirección para bifurcar o
una directiva. Si este rótulo existe, debe comenzar en la
columna 1, de manera que no sea confundido con otro elemento
de la línea. Los rótulos que identifican una dirección para
bifurcar y los que aparecen solos en la línea deben terminar
con un carácter “:”, el que no forma parte del rótulo sino que
actúa como señalador; los rótulos que identifican datos o
directivas no deben llevar el carácter “:”. Cuando se use el
rótulo como dirección para bifurcar, es buena práctica escribirlo solo en una línea antes de la instrucción que señala,
para permitir que a posteriori puedan intercalarse sin dificultad instrucciones que falten. El rótulo se traducirá como
la dirección del primer byte del dato o de la instrucción a
los que precede. No se pueden usar como rótulos ciertas
palabras reservadas: los códigos de operación, los nombres de
los registros, etc.</p>
<p class="calibre5">Luego del rótulo, si existe, y separado por uno o más blancos de éste, viene el código de operación, que es una secuencia de letras mnemotécnica que identifica la función que cumple la instrucción o directiva. Si no se incluye rótulo, el
código de operación deberá escribirse después de la columna 1,
precisamente para indicar que no es un rótulo.</p>
<p class="calibre5">Después del código de operación, y separados de éste por
uno o más blancos, vienen los operandos, separados entre sí
por comas y, optativamente, blancos. Los operandos de una
instrucción pueden ser 0, 1 o 2; los de una directiva pueden
ser 0 o más.</p>
<p class="calibre5">Al final de la línea puede haber comentarios, separados del
resto de la instrucción por el carácter “;”. Los comentarios
pueden por sí mismos ocupar una línea entera. Los programas, y
más los escritos en lenguaje Assembly, suelen ser difíciles de
comprender para quien no los escribió, e incluso para su autor
pasado un tiempo; por ello es buena práctica agregarles comentarios en forma abundante.</p>
<p class="calibre5">Los códigos de operación y los operandos predeterminados
(direcciones numéricas, constantes, nombres de registros, y
otros) pueden escribirse tanto con mayúsculas como con minúsculas. En cuanto a los rótulos, existen opciones para que la
diferencia entre mayúsculas y minúsculas sea significativa o
no. En este texto supondremos que, en los rótulos, mayúsculas
y minúsculas se diferencian. En cuanto a las constantes
encerradas entre apóstrofos (‘) o comillas (“), siempre se
distinguen mayúsculas de minúsculas.</p>
<p class="calibre5">En todo lo que sigue usaremos las convenciones de uno de
los Ensambladores disponibles, el Turbo Assembler de Borland.
Los otros Ensambladores son en general compatibles con éste,
salvo pequeños detalles.</p>
<p class="calibre5">No insistiremos más con la sintaxis del Ensamblador, pues
entendemos que la mejor manera de aprenderla es a través de
ejemplos. Cada vez que aparezca un elemento nuevo, será debidamente comentado.</p>
</div>
<div class="pri1" id="programas">
<h3 class="calibre27"><a class="toc-backref" href="#id12">5. PROGRAMAS</a></h3>
<div class="pri1" id="primer-programa">
<h4 class="calibre30"><a class="toc-backref1" href="#id13">5.1. Primer programa</a></h4>
<p class="calibre5">La manera más fácil de estudiar es con ejemplos; por lo
tanto, empezaremos directamente con el primer programa, y
luego comentaremos los elementos nuevos que hayan aparecido.</p>
<pre class="literal-block1">
|           .MODEL small
|           .STACK 100h
|           .DATA
| Mensaje  DB     '¡Hola, mundo!', 13, 10, '$'
|           .CODE
| Comienzo:
|           mov    ax, @data          ; Inicializar
|           mov    ds, ax             ; Apuntar DS a datos
|           mov    ah, 9              ; Función de despliegue
|           mov    dx, OFFSET Mensaje ; Apuntar a Mensaje
|           int    21h                ; Llamar al DOS
|           mov    ah, 4ch            ; Función de terminación
|           int    21h                ; Llamar al DOS
|           END    Comienzo           ; Terminar el archivo
</pre>
<p class="calibre5">Este programa mostrará por la pantalla el mensaje ¡Hola,
mundo! y luego retornará al DOS (Disk Operating System),
sistema operativo que usaremos de ahora en adelante. Además de
la coma para separar operandos, hemos usado blancos adicionales para una mejor visualización, pero ellos no son necesarios.</p>
<p class="calibre5">A continuación explicaremos en detalle cada línea de este
programa.</p>
<pre class="literal-block1">
|         .MODEL small
</pre>
<p class="calibre5">Esta es una directiva que no genera instrucciones en
lenguaje de máquina, sino que le indica al Ensamblador cómo
compaginar el resto de las operaciones. Específicamente en
este caso, se le indica al Ensamblador que el programa es
pequeño y los datos también, por lo que deberá generar determinadas instrucciones en un formato que use el desplazamiento
y no el segmento. Esta sentencia podría escribirse con mayúsculas o con minúsculas indistintamente; si escribimos una
parte con mayúsculas y otra con minúsculas es sólo por razones
de mejor visualización.:</p>
<pre class="literal-block1">
|         .STACK 100h
</pre>
<p class="calibre5">Esta directiva da un tamaño de 100 (hexadecimal, o sea 256
decimal) bytes a la Pila.</p>
<pre class="literal-block1">
|         .DATA
</pre>
<p class="calibre5">Esta directiva indica que lo que sigue son los datos del
segmento de datos.</p>
<pre class="literal-block1">
|    Mensaje  DB  '¡Hola, mundo!', 13, 10, '$'
</pre>
<p class="calibre5">Esta es una directiva que, si bien no genera instrucciones,
reserva espacio en la memoria. El rótulo Mensaje será traducido por el Ensamblador a una dirección en el segmento de datos.
Este rótulo se escribe sin el signo “:”, porque precede a una
directiva.</p>
<p class="calibre5">La directiva DB (definir byte) indica que a continuación
viene una serie de datos que ocuparán un byte cada uno. Si se
quisiera que ocuparan una palabra, el código sería DW (definir
palabra), y DD (definir doble palabra) si fueran dobles
palabras.</p>
<p class="calibre5">Dentro de los apóstrofos (‘) se escriben constantes o literales alfanuméricos como el presente; allí las mayúsculas y
minúsculas se diferencian, pues se usarán tal cual.</p>
<p class="calibre5">A continuación del texto aparecen los números 13 y 10.
Estos números son el valor decimal de dos caracteres no
imprimibles: CR (retorno de carro) y LF (alimentación de
línea), que harán que, luego de desplegarse el mensaje, el
cursor retorne al principio de la línea y luego baje una
línea, tal como lo hace la palanca de una máquina de escribir
mecánica.</p>
<p class="calibre5">Finalmente aparece un carácter $, que le indicará al DOS
que finalizó el texto.</p>
<p class="calibre5">Los apóstrofos pueden sustituirse por comillas (“). Puede
uno preguntarse cómo podrían incluirse los caracteres “, ‘ y $
en un texto. Los apóstrofos y comillas pueden incluirse de
tres maneras: a) usándolos dentro de un par de los otros, es
decir, un apóstrofo entre dos comillas, por ejemplo “D’Hont”,
o al revés, una comilla entre dos apóstrofos; b) duplicándolos, por ejemplo ‘D”Hont’; c) incluyéndolos con sus códigos
numéricos, como hicimos antes con los caracteres CR y LF; los
códigos numéricos de ” y ‘ son 34 y 39, respectivamente. Esto
quedaría así: ‘D’,39,‘Hont’.</p>
<p class="calibre5">En cuanto al carácter $, se lo puede incluir directamente,
sin ningún artificio, en un literal alfanumérico como el
presente. El problema es que la rutina del DOS que usaremos
ahora lo reconoce como fin del texto, y por lo tanto no
mostrará el $ ni los caracteres que lo sigan. Esto puede
solucionarse usando otra rutina del DOS, como haremos más
adelante.</p>
<pre class="literal-block1">
|         .CODE
</pre>
<p class="calibre5">Esta directiva indica que lo que sigue son instrucciones en
el segmento de código.</p>
<pre class="literal-block1">
|    Comienzo:
</pre>
<p class="calibre5">Este rótulo indica el punto de comienzo del programa.
Necesita el carácter “:” porque va solo en una línea. También
lo necesitaría si precediera a una instrucción.</p>
<pre class="literal-block1">
|     mov    ax, @data         ; Inicializar
</pre>
<p class="calibre5">MOV es el primer código de instrucción que vemos. Indica
movimiento de datos, que en realidad debería llamarse copia,
pues no se alteran en la ubicación original. @data es una
constante preestablecida por el Ensamblador, y contiene el
valor que deberá cargarse en el registro de segmento de datos
DS para que apunte a lo que hemos indicado como .DATA. El
movimiento se produce siempre desde el segundo operando al
primero, o sea en este caso desde @data al registro AX.</p>
<p class="calibre5">Con esta instrucción se intenta cargar el registro DS con
el valor de @data; pero sucede que no existen instrucciones
que carguen directamente un registro de segmento desde constantes en la propia instrucción. Si bien hay instrucciones que
cargan directamente un registro de segmento con datos residentes en la memoria, fuera de la instrucción, eso no es factible
en este caso porque para direccionar la memoria se necesita
que el DS tenga cargado el valor correcto, que es precisamente
lo que intentamos hacer. Se sale de este círculo vicioso por
medio de esta secuencia de dos instrucciones: se carga una
constante residente en la propia instrucción en un registro de
propósito general, por ejemplo el AX, y luego se copia este
registro al DS.</p>
<pre class="literal-block1">
|      mov    ds, ax             ; DS apunta a datos
</pre>
<p class="calibre5">Esta instrucción realiza la segunda parte de la tarea
explicada.</p>
<pre class="literal-block1">
|      mov    ah, 9              ; Función de despliegue
</pre>
<p class="calibre5">Con esta instrucción preparamos la llamada al DOS para que
despliegue el mensaje. Las especificaciones de la interrupción
21h del DOS requieren que se le pase en el registro AH el
número de la función a ejecutar. La función 9 (9 decimal es lo
mismo que 9 hexadecimal) es una de las funciones de despliegue
por pantalla.</p>
<pre class="literal-block1">
|      mov    dx, OFFSET Mensaje ; Apuntar a Mensaje
</pre>
<p class="calibre5">La función 9 requiere a su vez que en el registro DX se le
pase el desplazamiento (offset) del comienzo del texto que se
desplegará. Si no hubiéramos usado la palabra OFFSET, al
registro DX hubiera ido no ya el desplazamiento de Mensaje,
sino los 2 primeros caracteres del texto (“¡H”), lo cual
seguramente hubiera ocasionado eventos que no deseamos.</p>
<p class="calibre5">La palabra OFFSET puede escribirse con mayúsculas o con
minúsculas indistintamente; lo hacemos con mayúsculas para
destacarla.</p>
<pre class="literal-block1">
|      int    21h                ; Llamar al DOS
</pre>
<p class="calibre5">Finalmente, llamamos a la rutina del DOS que realizará la
tarea de mostrar el mensaje por la pantalla.:</p>
<pre class="literal-block1">
|      mov    ah, 4ch            ; Función de terminación
</pre>
<p class="calibre5">Una vez finalizado el despliegue, el DOS devuelve el
control a nuestro programa; y no teniendo otra cosa que hacer,
debemos indicar que finalizó la tarea. Esto se hace llamando a
la función de terminación, cuyo número es 4c hexadecimal, por
lo que cargamos este valor en AH para luego ejecutar la
interrupción 21h. Si no hiciéramos esto, el equipo se colgaría
y deberíamos reinicializarlo.:</p>
<pre class="literal-block1">
|     int    21h                 ; Llamar al DOS
</pre>
<p class="calibre5">Una vez más llamamos al DOS, ahora para finalizar nuestro
programa.</p>
<pre class="literal-block1">
|     END    Comienzo            ; Terminar el archivo
</pre>
<p class="calibre5">La directiva END le indica al Ensamblador que finalizó el
archivo fuente. Adicionalmente, indica que el programa deberá
comenzarse a ejecutar desde el rótulo Comienzo, y que el
registro CS debe cargarse con el valor del segmento correspondiente.</p>
<p class="calibre5">Como se ve, la programación en lenguaje Assembly lleva
mucha escritura para realizar tareas simples, pero en el fondo
no es demasiado compleja.</p>
</div>
<div class="pri1" id="compilacion-y-encadenado">
<h4 class="calibre30"><a class="toc-backref1" href="#id14">5.2. Compilación y encadenado</a></h4>
<p class="calibre5">El archivo que contiene el código fuente se crea con un
procesador de textos cualquiera, usado con la opción de
generar texto ASCII. Este archivo no se puede ejecutar
directamente. Debe ser procesado por el Ensamblador, que
producirá un listado y un archivo objeto.</p>
<p class="calibre5">El archivo objeto debe ser luego sometido a una operación
conocida como encadenado (link o link-edit). Esta operación, a
cargo de un programa llamado precisamente link o tlink, tiene
por fin unir el programa objeto con otros subprogramas que
hayan sido compaginados separadamente, y también dar valores
definitivos a ciertas constantes que han quedado generadas a
medias por el Ensamblador. Esta operación produce un archivo
conocido como archivo ejecutable.</p>
<p class="calibre5">Para ejecutarlo, este último archivo deberá ser cargado a
través de los servicios del DOS cada vez que se lo necesite.
Esta operación la realiza el loader, que se invoca
sencillamente por medio del nombre de nuestro programa
ejecutable (.EXE). Esto producirá los resultados buscados.</p>
<p class="calibre5">En la próxima entrega de este manual:</p>
<p class="calibre5">Seccion 6:</p>
<ul class="calibre2">
<li class="calibre3">Direccionamiento.</li>
</ul>
<p class="calibre5">Sección 7:</p>
<ul class="calibre2">
<li class="calibre3">Instrucciones Básicas.</li>
</ul>
</div>
</div>
</div>
</div>

</div>

</body>
</html>
